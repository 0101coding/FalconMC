#![allow(dead_code)]
use std::str::FromStr;
use ahash::AHashMap;
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum Blocks {
    Air,
    Stone,
    Granite,
    PolishedGranite,
    Diorite,
    PolishedDiorite,
    Andesite,
    PolishedAndesite,
    GrassBlock(GrassBlockState),
    Dirt,
    CoarseDirt,
    Podzol(PodzolState),
    Cobblestone,
    OakPlanks,
    SprucePlanks,
    BirchPlanks,
    JunglePlanks,
    AcaciaPlanks,
    DarkOakPlanks,
    OakSapling(OakSaplingState),
    SpruceSapling(SpruceSaplingState),
    BirchSapling(BirchSaplingState),
    JungleSapling(JungleSaplingState),
    AcaciaSapling(AcaciaSaplingState),
    DarkOakSapling(DarkOakSaplingState),
    Bedrock,
    Water(WaterState),
    Lava(LavaState),
    Sand,
    RedSand,
    Gravel,
    GoldOre,
    DeepslateGoldOre,
    IronOre,
    DeepslateIronOre,
    CoalOre,
    DeepslateCoalOre,
    NetherGoldOre,
    OakLog(OakLogState),
    SpruceLog(SpruceLogState),
    BirchLog(BirchLogState),
    JungleLog(JungleLogState),
    AcaciaLog(AcaciaLogState),
    DarkOakLog(DarkOakLogState),
    StrippedSpruceLog(StrippedSpruceLogState),
    StrippedBirchLog(StrippedBirchLogState),
    StrippedJungleLog(StrippedJungleLogState),
    StrippedAcaciaLog(StrippedAcaciaLogState),
    StrippedDarkOakLog(StrippedDarkOakLogState),
    StrippedOakLog(StrippedOakLogState),
    OakWood(OakWoodState),
    SpruceWood(SpruceWoodState),
    BirchWood(BirchWoodState),
    JungleWood(JungleWoodState),
    AcaciaWood(AcaciaWoodState),
    DarkOakWood(DarkOakWoodState),
    StrippedOakWood(StrippedOakWoodState),
    StrippedSpruceWood(StrippedSpruceWoodState),
    StrippedBirchWood(StrippedBirchWoodState),
    StrippedJungleWood(StrippedJungleWoodState),
    StrippedAcaciaWood(StrippedAcaciaWoodState),
    StrippedDarkOakWood(StrippedDarkOakWoodState),
    OakLeaves(OakLeavesState),
    SpruceLeaves(SpruceLeavesState),
    BirchLeaves(BirchLeavesState),
    JungleLeaves(JungleLeavesState),
    AcaciaLeaves(AcaciaLeavesState),
    DarkOakLeaves(DarkOakLeavesState),
    AzaleaLeaves(AzaleaLeavesState),
    FloweringAzaleaLeaves(FloweringAzaleaLeavesState),
    Sponge,
    WetSponge,
    Glass,
    LapisOre,
    DeepslateLapisOre,
    LapisBlock,
    Dispenser(DispenserState),
    Sandstone,
    ChiseledSandstone,
    CutSandstone,
    NoteBlock(NoteBlockState),
    WhiteBed(WhiteBedState),
    OrangeBed(OrangeBedState),
    MagentaBed(MagentaBedState),
    LightBlueBed(LightBlueBedState),
    YellowBed(YellowBedState),
    LimeBed(LimeBedState),
    PinkBed(PinkBedState),
    GrayBed(GrayBedState),
    LightGrayBed(LightGrayBedState),
    CyanBed(CyanBedState),
    PurpleBed(PurpleBedState),
    BlueBed(BlueBedState),
    BrownBed(BrownBedState),
    GreenBed(GreenBedState),
    RedBed(RedBedState),
    BlackBed(BlackBedState),
    PoweredRail(PoweredRailState),
    DetectorRail(DetectorRailState),
    StickyPiston(StickyPistonState),
    Cobweb,
    Grass,
    Fern,
    DeadBush,
    Seagrass,
    TallSeagrass(TallSeagrassState),
    Piston(PistonState),
    PistonHead(PistonHeadState),
    WhiteWool,
    OrangeWool,
    MagentaWool,
    LightBlueWool,
    YellowWool,
    LimeWool,
    PinkWool,
    GrayWool,
    LightGrayWool,
    CyanWool,
    PurpleWool,
    BlueWool,
    BrownWool,
    GreenWool,
    RedWool,
    BlackWool,
    MovingPiston(MovingPistonState),
    Dandelion,
    Poppy,
    BlueOrchid,
    Allium,
    AzureBluet,
    RedTulip,
    OrangeTulip,
    WhiteTulip,
    PinkTulip,
    OxeyeDaisy,
    Cornflower,
    WitherRose,
    LilyOfTheValley,
    BrownMushroom,
    RedMushroom,
    GoldBlock,
    IronBlock,
    Bricks,
    Tnt(TntState),
    Bookshelf,
    MossyCobblestone,
    Obsidian,
    Torch,
    WallTorch(WallTorchState),
    Fire(FireState),
    SoulFire,
    Spawner,
    OakStairs(OakStairsState),
    Chest(ChestState),
    RedstoneWire(RedstoneWireState),
    DiamondOre,
    DeepslateDiamondOre,
    DiamondBlock,
    CraftingTable,
    Wheat(WheatState),
    Farmland(FarmlandState),
    Furnace(FurnaceState),
    OakSign(OakSignState),
    SpruceSign(SpruceSignState),
    BirchSign(BirchSignState),
    AcaciaSign(AcaciaSignState),
    JungleSign(JungleSignState),
    DarkOakSign(DarkOakSignState),
    OakDoor(OakDoorState),
    Ladder(LadderState),
    Rail(RailState),
    CobblestoneStairs(CobblestoneStairsState),
    OakWallSign(OakWallSignState),
    SpruceWallSign(SpruceWallSignState),
    BirchWallSign(BirchWallSignState),
    AcaciaWallSign(AcaciaWallSignState),
    JungleWallSign(JungleWallSignState),
    DarkOakWallSign(DarkOakWallSignState),
    Lever(LeverState),
    StonePressurePlate(StonePressurePlateState),
    IronDoor(IronDoorState),
    OakPressurePlate(OakPressurePlateState),
    SprucePressurePlate(SprucePressurePlateState),
    BirchPressurePlate(BirchPressurePlateState),
    JunglePressurePlate(JunglePressurePlateState),
    AcaciaPressurePlate(AcaciaPressurePlateState),
    DarkOakPressurePlate(DarkOakPressurePlateState),
    RedstoneOre(RedstoneOreState),
    DeepslateRedstoneOre(DeepslateRedstoneOreState),
    RedstoneTorch(RedstoneTorchState),
    RedstoneWallTorch(RedstoneWallTorchState),
    StoneButton(StoneButtonState),
    Snow(SnowState),
    Ice,
    SnowBlock,
    Cactus(CactusState),
    Clay,
    SugarCane(SugarCaneState),
    Jukebox(JukeboxState),
    OakFence(OakFenceState),
    Pumpkin,
    Netherrack,
    SoulSand,
    SoulSoil,
    Basalt(BasaltState),
    PolishedBasalt(PolishedBasaltState),
    SoulTorch,
    SoulWallTorch(SoulWallTorchState),
    Glowstone,
    NetherPortal(NetherPortalState),
    CarvedPumpkin(CarvedPumpkinState),
    JackOLantern(JackOLanternState),
    Cake(CakeState),
    Repeater(RepeaterState),
    WhiteStainedGlass,
    OrangeStainedGlass,
    MagentaStainedGlass,
    LightBlueStainedGlass,
    YellowStainedGlass,
    LimeStainedGlass,
    PinkStainedGlass,
    GrayStainedGlass,
    LightGrayStainedGlass,
    CyanStainedGlass,
    PurpleStainedGlass,
    BlueStainedGlass,
    BrownStainedGlass,
    GreenStainedGlass,
    RedStainedGlass,
    BlackStainedGlass,
    OakTrapdoor(OakTrapdoorState),
    SpruceTrapdoor(SpruceTrapdoorState),
    BirchTrapdoor(BirchTrapdoorState),
    JungleTrapdoor(JungleTrapdoorState),
    AcaciaTrapdoor(AcaciaTrapdoorState),
    DarkOakTrapdoor(DarkOakTrapdoorState),
    StoneBricks,
    MossyStoneBricks,
    CrackedStoneBricks,
    ChiseledStoneBricks,
    InfestedStone,
    InfestedCobblestone,
    InfestedStoneBricks,
    InfestedMossyStoneBricks,
    InfestedCrackedStoneBricks,
    InfestedChiseledStoneBricks,
    BrownMushroomBlock(BrownMushroomBlockState),
    RedMushroomBlock(RedMushroomBlockState),
    MushroomStem(MushroomStemState),
    IronBars(IronBarsState),
    Chain(ChainState),
    GlassPane(GlassPaneState),
    Melon,
    AttachedPumpkinStem(AttachedPumpkinStemState),
    AttachedMelonStem(AttachedMelonStemState),
    PumpkinStem(PumpkinStemState),
    MelonStem(MelonStemState),
    Vine(VineState),
    GlowLichen(GlowLichenState),
    OakFenceGate(OakFenceGateState),
    BrickStairs(BrickStairsState),
    StoneBrickStairs(StoneBrickStairsState),
    Mycelium(MyceliumState),
    LilyPad,
    NetherBricks,
    NetherBrickFence(NetherBrickFenceState),
    NetherBrickStairs(NetherBrickStairsState),
    NetherWart(NetherWartState),
    EnchantingTable,
    BrewingStand(BrewingStandState),
    Cauldron,
    WaterCauldron(WaterCauldronState),
    LavaCauldron,
    PowderSnowCauldron(PowderSnowCauldronState),
    EndPortal,
    EndPortalFrame(EndPortalFrameState),
    EndStone,
    DragonEgg,
    RedstoneLamp(RedstoneLampState),
    Cocoa(CocoaState),
    SandstoneStairs(SandstoneStairsState),
    EmeraldOre,
    DeepslateEmeraldOre,
    EnderChest(EnderChestState),
    TripwireHook(TripwireHookState),
    Tripwire(TripwireState),
    EmeraldBlock,
    SpruceStairs(SpruceStairsState),
    BirchStairs(BirchStairsState),
    JungleStairs(JungleStairsState),
    CommandBlock(CommandBlockState),
    Beacon,
    CobblestoneWall(CobblestoneWallState),
    MossyCobblestoneWall(MossyCobblestoneWallState),
    FlowerPot,
    PottedOakSapling,
    PottedSpruceSapling,
    PottedBirchSapling,
    PottedJungleSapling,
    PottedAcaciaSapling,
    PottedDarkOakSapling,
    PottedFern,
    PottedDandelion,
    PottedPoppy,
    PottedBlueOrchid,
    PottedAllium,
    PottedAzureBluet,
    PottedRedTulip,
    PottedOrangeTulip,
    PottedWhiteTulip,
    PottedPinkTulip,
    PottedOxeyeDaisy,
    PottedCornflower,
    PottedLilyOfTheValley,
    PottedWitherRose,
    PottedRedMushroom,
    PottedBrownMushroom,
    PottedDeadBush,
    PottedCactus,
    Carrots(CarrotsState),
    Potatoes(PotatoesState),
    OakButton(OakButtonState),
    SpruceButton(SpruceButtonState),
    BirchButton(BirchButtonState),
    JungleButton(JungleButtonState),
    AcaciaButton(AcaciaButtonState),
    DarkOakButton(DarkOakButtonState),
    SkeletonSkull(SkeletonSkullState),
    SkeletonWallSkull(SkeletonWallSkullState),
    WitherSkeletonSkull(WitherSkeletonSkullState),
    WitherSkeletonWallSkull(WitherSkeletonWallSkullState),
    ZombieHead(ZombieHeadState),
    ZombieWallHead(ZombieWallHeadState),
    PlayerHead(PlayerHeadState),
    PlayerWallHead(PlayerWallHeadState),
    CreeperHead(CreeperHeadState),
    CreeperWallHead(CreeperWallHeadState),
    DragonHead(DragonHeadState),
    DragonWallHead(DragonWallHeadState),
    Anvil(AnvilState),
    ChippedAnvil(ChippedAnvilState),
    DamagedAnvil(DamagedAnvilState),
    TrappedChest(TrappedChestState),
    LightWeightedPressurePlate(LightWeightedPressurePlateState),
    HeavyWeightedPressurePlate(HeavyWeightedPressurePlateState),
    Comparator(ComparatorState),
    DaylightDetector(DaylightDetectorState),
    RedstoneBlock,
    NetherQuartzOre,
    Hopper(HopperState),
    QuartzBlock,
    ChiseledQuartzBlock,
    QuartzPillar(QuartzPillarState),
    QuartzStairs(QuartzStairsState),
    ActivatorRail(ActivatorRailState),
    Dropper(DropperState),
    WhiteTerracotta,
    OrangeTerracotta,
    MagentaTerracotta,
    LightBlueTerracotta,
    YellowTerracotta,
    LimeTerracotta,
    PinkTerracotta,
    GrayTerracotta,
    LightGrayTerracotta,
    CyanTerracotta,
    PurpleTerracotta,
    BlueTerracotta,
    BrownTerracotta,
    GreenTerracotta,
    RedTerracotta,
    BlackTerracotta,
    WhiteStainedGlassPane(WhiteStainedGlassPaneState),
    OrangeStainedGlassPane(OrangeStainedGlassPaneState),
    MagentaStainedGlassPane(MagentaStainedGlassPaneState),
    LightBlueStainedGlassPane(LightBlueStainedGlassPaneState),
    YellowStainedGlassPane(YellowStainedGlassPaneState),
    LimeStainedGlassPane(LimeStainedGlassPaneState),
    PinkStainedGlassPane(PinkStainedGlassPaneState),
    GrayStainedGlassPane(GrayStainedGlassPaneState),
    LightGrayStainedGlassPane(LightGrayStainedGlassPaneState),
    CyanStainedGlassPane(CyanStainedGlassPaneState),
    PurpleStainedGlassPane(PurpleStainedGlassPaneState),
    BlueStainedGlassPane(BlueStainedGlassPaneState),
    BrownStainedGlassPane(BrownStainedGlassPaneState),
    GreenStainedGlassPane(GreenStainedGlassPaneState),
    RedStainedGlassPane(RedStainedGlassPaneState),
    BlackStainedGlassPane(BlackStainedGlassPaneState),
    AcaciaStairs(AcaciaStairsState),
    DarkOakStairs(DarkOakStairsState),
    SlimeBlock,
    Barrier,
    Light(LightState),
    IronTrapdoor(IronTrapdoorState),
    Prismarine,
    PrismarineBricks,
    DarkPrismarine,
    PrismarineStairs(PrismarineStairsState),
    PrismarineBrickStairs(PrismarineBrickStairsState),
    DarkPrismarineStairs(DarkPrismarineStairsState),
    PrismarineSlab(PrismarineSlabState),
    PrismarineBrickSlab(PrismarineBrickSlabState),
    DarkPrismarineSlab(DarkPrismarineSlabState),
    SeaLantern,
    HayBlock(HayBlockState),
    WhiteCarpet,
    OrangeCarpet,
    MagentaCarpet,
    LightBlueCarpet,
    YellowCarpet,
    LimeCarpet,
    PinkCarpet,
    GrayCarpet,
    LightGrayCarpet,
    CyanCarpet,
    PurpleCarpet,
    BlueCarpet,
    BrownCarpet,
    GreenCarpet,
    RedCarpet,
    BlackCarpet,
    Terracotta,
    CoalBlock,
    PackedIce,
    Sunflower(SunflowerState),
    Lilac(LilacState),
    RoseBush(RoseBushState),
    Peony(PeonyState),
    TallGrass(TallGrassState),
    LargeFern(LargeFernState),
    WhiteBanner(WhiteBannerState),
    OrangeBanner(OrangeBannerState),
    MagentaBanner(MagentaBannerState),
    LightBlueBanner(LightBlueBannerState),
    YellowBanner(YellowBannerState),
    LimeBanner(LimeBannerState),
    PinkBanner(PinkBannerState),
    GrayBanner(GrayBannerState),
    LightGrayBanner(LightGrayBannerState),
    CyanBanner(CyanBannerState),
    PurpleBanner(PurpleBannerState),
    BlueBanner(BlueBannerState),
    BrownBanner(BrownBannerState),
    GreenBanner(GreenBannerState),
    RedBanner(RedBannerState),
    BlackBanner(BlackBannerState),
    WhiteWallBanner(WhiteWallBannerState),
    OrangeWallBanner(OrangeWallBannerState),
    MagentaWallBanner(MagentaWallBannerState),
    LightBlueWallBanner(LightBlueWallBannerState),
    YellowWallBanner(YellowWallBannerState),
    LimeWallBanner(LimeWallBannerState),
    PinkWallBanner(PinkWallBannerState),
    GrayWallBanner(GrayWallBannerState),
    LightGrayWallBanner(LightGrayWallBannerState),
    CyanWallBanner(CyanWallBannerState),
    PurpleWallBanner(PurpleWallBannerState),
    BlueWallBanner(BlueWallBannerState),
    BrownWallBanner(BrownWallBannerState),
    GreenWallBanner(GreenWallBannerState),
    RedWallBanner(RedWallBannerState),
    BlackWallBanner(BlackWallBannerState),
    RedSandstone,
    ChiseledRedSandstone,
    CutRedSandstone,
    RedSandstoneStairs(RedSandstoneStairsState),
    OakSlab(OakSlabState),
    SpruceSlab(SpruceSlabState),
    BirchSlab(BirchSlabState),
    JungleSlab(JungleSlabState),
    AcaciaSlab(AcaciaSlabState),
    DarkOakSlab(DarkOakSlabState),
    StoneSlab(StoneSlabState),
    SmoothStoneSlab(SmoothStoneSlabState),
    SandstoneSlab(SandstoneSlabState),
    CutSandstoneSlab(CutSandstoneSlabState),
    PetrifiedOakSlab(PetrifiedOakSlabState),
    CobblestoneSlab(CobblestoneSlabState),
    BrickSlab(BrickSlabState),
    StoneBrickSlab(StoneBrickSlabState),
    NetherBrickSlab(NetherBrickSlabState),
    QuartzSlab(QuartzSlabState),
    RedSandstoneSlab(RedSandstoneSlabState),
    CutRedSandstoneSlab(CutRedSandstoneSlabState),
    PurpurSlab(PurpurSlabState),
    SmoothStone,
    SmoothSandstone,
    SmoothQuartz,
    SmoothRedSandstone,
    SpruceFenceGate(SpruceFenceGateState),
    BirchFenceGate(BirchFenceGateState),
    JungleFenceGate(JungleFenceGateState),
    AcaciaFenceGate(AcaciaFenceGateState),
    DarkOakFenceGate(DarkOakFenceGateState),
    SpruceFence(SpruceFenceState),
    BirchFence(BirchFenceState),
    JungleFence(JungleFenceState),
    AcaciaFence(AcaciaFenceState),
    DarkOakFence(DarkOakFenceState),
    SpruceDoor(SpruceDoorState),
    BirchDoor(BirchDoorState),
    JungleDoor(JungleDoorState),
    AcaciaDoor(AcaciaDoorState),
    DarkOakDoor(DarkOakDoorState),
    EndRod(EndRodState),
    ChorusPlant(ChorusPlantState),
    ChorusFlower(ChorusFlowerState),
    PurpurBlock,
    PurpurPillar(PurpurPillarState),
    PurpurStairs(PurpurStairsState),
    EndStoneBricks,
    Beetroots(BeetrootsState),
    DirtPath,
    EndGateway,
    RepeatingCommandBlock(RepeatingCommandBlockState),
    ChainCommandBlock(ChainCommandBlockState),
    FrostedIce(FrostedIceState),
    MagmaBlock,
    NetherWartBlock,
    RedNetherBricks,
    BoneBlock(BoneBlockState),
    StructureVoid,
    Observer(ObserverState),
    ShulkerBox(ShulkerBoxState),
    WhiteShulkerBox(WhiteShulkerBoxState),
    OrangeShulkerBox(OrangeShulkerBoxState),
    MagentaShulkerBox(MagentaShulkerBoxState),
    LightBlueShulkerBox(LightBlueShulkerBoxState),
    YellowShulkerBox(YellowShulkerBoxState),
    LimeShulkerBox(LimeShulkerBoxState),
    PinkShulkerBox(PinkShulkerBoxState),
    GrayShulkerBox(GrayShulkerBoxState),
    LightGrayShulkerBox(LightGrayShulkerBoxState),
    CyanShulkerBox(CyanShulkerBoxState),
    PurpleShulkerBox(PurpleShulkerBoxState),
    BlueShulkerBox(BlueShulkerBoxState),
    BrownShulkerBox(BrownShulkerBoxState),
    GreenShulkerBox(GreenShulkerBoxState),
    RedShulkerBox(RedShulkerBoxState),
    BlackShulkerBox(BlackShulkerBoxState),
    WhiteGlazedTerracotta(WhiteGlazedTerracottaState),
    OrangeGlazedTerracotta(OrangeGlazedTerracottaState),
    MagentaGlazedTerracotta(MagentaGlazedTerracottaState),
    LightBlueGlazedTerracotta(LightBlueGlazedTerracottaState),
    YellowGlazedTerracotta(YellowGlazedTerracottaState),
    LimeGlazedTerracotta(LimeGlazedTerracottaState),
    PinkGlazedTerracotta(PinkGlazedTerracottaState),
    GrayGlazedTerracotta(GrayGlazedTerracottaState),
    LightGrayGlazedTerracotta(LightGrayGlazedTerracottaState),
    CyanGlazedTerracotta(CyanGlazedTerracottaState),
    PurpleGlazedTerracotta(PurpleGlazedTerracottaState),
    BlueGlazedTerracotta(BlueGlazedTerracottaState),
    BrownGlazedTerracotta(BrownGlazedTerracottaState),
    GreenGlazedTerracotta(GreenGlazedTerracottaState),
    RedGlazedTerracotta(RedGlazedTerracottaState),
    BlackGlazedTerracotta(BlackGlazedTerracottaState),
    WhiteConcrete,
    OrangeConcrete,
    MagentaConcrete,
    LightBlueConcrete,
    YellowConcrete,
    LimeConcrete,
    PinkConcrete,
    GrayConcrete,
    LightGrayConcrete,
    CyanConcrete,
    PurpleConcrete,
    BlueConcrete,
    BrownConcrete,
    GreenConcrete,
    RedConcrete,
    BlackConcrete,
    WhiteConcretePowder,
    OrangeConcretePowder,
    MagentaConcretePowder,
    LightBlueConcretePowder,
    YellowConcretePowder,
    LimeConcretePowder,
    PinkConcretePowder,
    GrayConcretePowder,
    LightGrayConcretePowder,
    CyanConcretePowder,
    PurpleConcretePowder,
    BlueConcretePowder,
    BrownConcretePowder,
    GreenConcretePowder,
    RedConcretePowder,
    BlackConcretePowder,
    Kelp(KelpState),
    KelpPlant,
    DriedKelpBlock,
    TurtleEgg(TurtleEggState),
    DeadTubeCoralBlock,
    DeadBrainCoralBlock,
    DeadBubbleCoralBlock,
    DeadFireCoralBlock,
    DeadHornCoralBlock,
    TubeCoralBlock,
    BrainCoralBlock,
    BubbleCoralBlock,
    FireCoralBlock,
    HornCoralBlock,
    DeadTubeCoral(DeadTubeCoralState),
    DeadBrainCoral(DeadBrainCoralState),
    DeadBubbleCoral(DeadBubbleCoralState),
    DeadFireCoral(DeadFireCoralState),
    DeadHornCoral(DeadHornCoralState),
    TubeCoral(TubeCoralState),
    BrainCoral(BrainCoralState),
    BubbleCoral(BubbleCoralState),
    FireCoral(FireCoralState),
    HornCoral(HornCoralState),
    DeadTubeCoralFan(DeadTubeCoralFanState),
    DeadBrainCoralFan(DeadBrainCoralFanState),
    DeadBubbleCoralFan(DeadBubbleCoralFanState),
    DeadFireCoralFan(DeadFireCoralFanState),
    DeadHornCoralFan(DeadHornCoralFanState),
    TubeCoralFan(TubeCoralFanState),
    BrainCoralFan(BrainCoralFanState),
    BubbleCoralFan(BubbleCoralFanState),
    FireCoralFan(FireCoralFanState),
    HornCoralFan(HornCoralFanState),
    DeadTubeCoralWallFan(DeadTubeCoralWallFanState),
    DeadBrainCoralWallFan(DeadBrainCoralWallFanState),
    DeadBubbleCoralWallFan(DeadBubbleCoralWallFanState),
    DeadFireCoralWallFan(DeadFireCoralWallFanState),
    DeadHornCoralWallFan(DeadHornCoralWallFanState),
    TubeCoralWallFan(TubeCoralWallFanState),
    BrainCoralWallFan(BrainCoralWallFanState),
    BubbleCoralWallFan(BubbleCoralWallFanState),
    FireCoralWallFan(FireCoralWallFanState),
    HornCoralWallFan(HornCoralWallFanState),
    SeaPickle(SeaPickleState),
    BlueIce,
    Conduit(ConduitState),
    BambooSapling,
    Bamboo(BambooState),
    PottedBamboo,
    VoidAir,
    CaveAir,
    BubbleColumn(BubbleColumnState),
    PolishedGraniteStairs(PolishedGraniteStairsState),
    SmoothRedSandstoneStairs(SmoothRedSandstoneStairsState),
    MossyStoneBrickStairs(MossyStoneBrickStairsState),
    PolishedDioriteStairs(PolishedDioriteStairsState),
    MossyCobblestoneStairs(MossyCobblestoneStairsState),
    EndStoneBrickStairs(EndStoneBrickStairsState),
    StoneStairs(StoneStairsState),
    SmoothSandstoneStairs(SmoothSandstoneStairsState),
    SmoothQuartzStairs(SmoothQuartzStairsState),
    GraniteStairs(GraniteStairsState),
    AndesiteStairs(AndesiteStairsState),
    RedNetherBrickStairs(RedNetherBrickStairsState),
    PolishedAndesiteStairs(PolishedAndesiteStairsState),
    DioriteStairs(DioriteStairsState),
    PolishedGraniteSlab(PolishedGraniteSlabState),
    SmoothRedSandstoneSlab(SmoothRedSandstoneSlabState),
    MossyStoneBrickSlab(MossyStoneBrickSlabState),
    PolishedDioriteSlab(PolishedDioriteSlabState),
    MossyCobblestoneSlab(MossyCobblestoneSlabState),
    EndStoneBrickSlab(EndStoneBrickSlabState),
    SmoothSandstoneSlab(SmoothSandstoneSlabState),
    SmoothQuartzSlab(SmoothQuartzSlabState),
    GraniteSlab(GraniteSlabState),
    AndesiteSlab(AndesiteSlabState),
    RedNetherBrickSlab(RedNetherBrickSlabState),
    PolishedAndesiteSlab(PolishedAndesiteSlabState),
    DioriteSlab(DioriteSlabState),
    BrickWall(BrickWallState),
    PrismarineWall(PrismarineWallState),
    RedSandstoneWall(RedSandstoneWallState),
    MossyStoneBrickWall(MossyStoneBrickWallState),
    GraniteWall(GraniteWallState),
    StoneBrickWall(StoneBrickWallState),
    NetherBrickWall(NetherBrickWallState),
    AndesiteWall(AndesiteWallState),
    RedNetherBrickWall(RedNetherBrickWallState),
    SandstoneWall(SandstoneWallState),
    EndStoneBrickWall(EndStoneBrickWallState),
    DioriteWall(DioriteWallState),
    Scaffolding(ScaffoldingState),
    Loom(LoomState),
    Barrel(BarrelState),
    Smoker(SmokerState),
    BlastFurnace(BlastFurnaceState),
    CartographyTable,
    FletchingTable,
    Grindstone(GrindstoneState),
    Lectern(LecternState),
    SmithingTable,
    Stonecutter(StonecutterState),
    Bell(BellState),
    Lantern(LanternState),
    SoulLantern(SoulLanternState),
    Campfire(CampfireState),
    SoulCampfire(SoulCampfireState),
    SweetBerryBush(SweetBerryBushState),
    WarpedStem(WarpedStemState),
    StrippedWarpedStem(StrippedWarpedStemState),
    WarpedHyphae(WarpedHyphaeState),
    StrippedWarpedHyphae(StrippedWarpedHyphaeState),
    WarpedNylium,
    WarpedFungus,
    WarpedWartBlock,
    WarpedRoots,
    NetherSprouts,
    CrimsonStem(CrimsonStemState),
    StrippedCrimsonStem(StrippedCrimsonStemState),
    CrimsonHyphae(CrimsonHyphaeState),
    StrippedCrimsonHyphae(StrippedCrimsonHyphaeState),
    CrimsonNylium,
    CrimsonFungus,
    Shroomlight,
    WeepingVines(WeepingVinesState),
    WeepingVinesPlant,
    TwistingVines(TwistingVinesState),
    TwistingVinesPlant,
    CrimsonRoots,
    CrimsonPlanks,
    WarpedPlanks,
    CrimsonSlab(CrimsonSlabState),
    WarpedSlab(WarpedSlabState),
    CrimsonPressurePlate(CrimsonPressurePlateState),
    WarpedPressurePlate(WarpedPressurePlateState),
    CrimsonFence(CrimsonFenceState),
    WarpedFence(WarpedFenceState),
    CrimsonTrapdoor(CrimsonTrapdoorState),
    WarpedTrapdoor(WarpedTrapdoorState),
    CrimsonFenceGate(CrimsonFenceGateState),
    WarpedFenceGate(WarpedFenceGateState),
    CrimsonStairs(CrimsonStairsState),
    WarpedStairs(WarpedStairsState),
    CrimsonButton(CrimsonButtonState),
    WarpedButton(WarpedButtonState),
    CrimsonDoor(CrimsonDoorState),
    WarpedDoor(WarpedDoorState),
    CrimsonSign(CrimsonSignState),
    WarpedSign(WarpedSignState),
    CrimsonWallSign(CrimsonWallSignState),
    WarpedWallSign(WarpedWallSignState),
    StructureBlock(StructureBlockState),
    Jigsaw(JigsawState),
    Composter(ComposterState),
    Target(TargetState),
    BeeNest(BeeNestState),
    Beehive(BeehiveState),
    HoneyBlock,
    HoneycombBlock,
    NetheriteBlock,
    AncientDebris,
    CryingObsidian,
    RespawnAnchor(RespawnAnchorState),
    PottedCrimsonFungus,
    PottedWarpedFungus,
    PottedCrimsonRoots,
    PottedWarpedRoots,
    Lodestone,
    Blackstone,
    BlackstoneStairs(BlackstoneStairsState),
    BlackstoneWall(BlackstoneWallState),
    BlackstoneSlab(BlackstoneSlabState),
    PolishedBlackstone,
    PolishedBlackstoneBricks,
    CrackedPolishedBlackstoneBricks,
    ChiseledPolishedBlackstone,
    PolishedBlackstoneBrickSlab(PolishedBlackstoneBrickSlabState),
    PolishedBlackstoneBrickStairs(PolishedBlackstoneBrickStairsState),
    PolishedBlackstoneBrickWall(PolishedBlackstoneBrickWallState),
    GildedBlackstone,
    PolishedBlackstoneStairs(PolishedBlackstoneStairsState),
    PolishedBlackstoneSlab(PolishedBlackstoneSlabState),
    PolishedBlackstonePressurePlate(PolishedBlackstonePressurePlateState),
    PolishedBlackstoneButton(PolishedBlackstoneButtonState),
    PolishedBlackstoneWall(PolishedBlackstoneWallState),
    ChiseledNetherBricks,
    CrackedNetherBricks,
    QuartzBricks,
    Candle(CandleState),
    WhiteCandle(WhiteCandleState),
    OrangeCandle(OrangeCandleState),
    MagentaCandle(MagentaCandleState),
    LightBlueCandle(LightBlueCandleState),
    YellowCandle(YellowCandleState),
    LimeCandle(LimeCandleState),
    PinkCandle(PinkCandleState),
    GrayCandle(GrayCandleState),
    LightGrayCandle(LightGrayCandleState),
    CyanCandle(CyanCandleState),
    PurpleCandle(PurpleCandleState),
    BlueCandle(BlueCandleState),
    BrownCandle(BrownCandleState),
    GreenCandle(GreenCandleState),
    RedCandle(RedCandleState),
    BlackCandle(BlackCandleState),
    CandleCake(CandleCakeState),
    WhiteCandleCake(WhiteCandleCakeState),
    OrangeCandleCake(OrangeCandleCakeState),
    MagentaCandleCake(MagentaCandleCakeState),
    LightBlueCandleCake(LightBlueCandleCakeState),
    YellowCandleCake(YellowCandleCakeState),
    LimeCandleCake(LimeCandleCakeState),
    PinkCandleCake(PinkCandleCakeState),
    GrayCandleCake(GrayCandleCakeState),
    LightGrayCandleCake(LightGrayCandleCakeState),
    CyanCandleCake(CyanCandleCakeState),
    PurpleCandleCake(PurpleCandleCakeState),
    BlueCandleCake(BlueCandleCakeState),
    BrownCandleCake(BrownCandleCakeState),
    GreenCandleCake(GreenCandleCakeState),
    RedCandleCake(RedCandleCakeState),
    BlackCandleCake(BlackCandleCakeState),
    AmethystBlock,
    BuddingAmethyst,
    AmethystCluster(AmethystClusterState),
    LargeAmethystBud(LargeAmethystBudState),
    MediumAmethystBud(MediumAmethystBudState),
    SmallAmethystBud(SmallAmethystBudState),
    Tuff,
    Calcite,
    TintedGlass,
    PowderSnow,
    SculkSensor(SculkSensorState),
    OxidizedCopper,
    WeatheredCopper,
    ExposedCopper,
    CopperBlock,
    CopperOre,
    DeepslateCopperOre,
    OxidizedCutCopper,
    WeatheredCutCopper,
    ExposedCutCopper,
    CutCopper,
    OxidizedCutCopperStairs(OxidizedCutCopperStairsState),
    WeatheredCutCopperStairs(WeatheredCutCopperStairsState),
    ExposedCutCopperStairs(ExposedCutCopperStairsState),
    CutCopperStairs(CutCopperStairsState),
    OxidizedCutCopperSlab(OxidizedCutCopperSlabState),
    WeatheredCutCopperSlab(WeatheredCutCopperSlabState),
    ExposedCutCopperSlab(ExposedCutCopperSlabState),
    CutCopperSlab(CutCopperSlabState),
    WaxedCopperBlock,
    WaxedWeatheredCopper,
    WaxedExposedCopper,
    WaxedOxidizedCopper,
    WaxedOxidizedCutCopper,
    WaxedWeatheredCutCopper,
    WaxedExposedCutCopper,
    WaxedCutCopper,
    WaxedOxidizedCutCopperStairs(WaxedOxidizedCutCopperStairsState),
    WaxedWeatheredCutCopperStairs(WaxedWeatheredCutCopperStairsState),
    WaxedExposedCutCopperStairs(WaxedExposedCutCopperStairsState),
    WaxedCutCopperStairs(WaxedCutCopperStairsState),
    WaxedOxidizedCutCopperSlab(WaxedOxidizedCutCopperSlabState),
    WaxedWeatheredCutCopperSlab(WaxedWeatheredCutCopperSlabState),
    WaxedExposedCutCopperSlab(WaxedExposedCutCopperSlabState),
    WaxedCutCopperSlab(WaxedCutCopperSlabState),
    LightningRod(LightningRodState),
    PointedDripstone(PointedDripstoneState),
    DripstoneBlock,
    CaveVines(CaveVinesState),
    CaveVinesPlant(CaveVinesPlantState),
    SporeBlossom,
    Azalea,
    FloweringAzalea,
    MossCarpet,
    MossBlock,
    BigDripleaf(BigDripleafState),
    BigDripleafStem(BigDripleafStemState),
    SmallDripleaf(SmallDripleafState),
    HangingRoots(HangingRootsState),
    RootedDirt,
    Deepslate(DeepslateState),
    CobbledDeepslate,
    CobbledDeepslateStairs(CobbledDeepslateStairsState),
    CobbledDeepslateSlab(CobbledDeepslateSlabState),
    CobbledDeepslateWall(CobbledDeepslateWallState),
    PolishedDeepslate,
    PolishedDeepslateStairs(PolishedDeepslateStairsState),
    PolishedDeepslateSlab(PolishedDeepslateSlabState),
    PolishedDeepslateWall(PolishedDeepslateWallState),
    DeepslateTiles,
    DeepslateTileStairs(DeepslateTileStairsState),
    DeepslateTileSlab(DeepslateTileSlabState),
    DeepslateTileWall(DeepslateTileWallState),
    DeepslateBricks,
    DeepslateBrickStairs(DeepslateBrickStairsState),
    DeepslateBrickSlab(DeepslateBrickSlabState),
    DeepslateBrickWall(DeepslateBrickWallState),
    ChiseledDeepslate,
    CrackedDeepslateBricks,
    CrackedDeepslateTiles,
    InfestedDeepslate(InfestedDeepslateState),
    SmoothBasalt,
    RawIronBlock,
    RawCopperBlock,
    RawGoldBlock,
    PottedAzaleaBush,
    PottedFloweringAzaleaBush,
}
impl Blocks {
    pub fn get_global_id_2586(&self) -> Option<i32> {
        match self {
            Blocks::Air => Some(0),
            Blocks::Stone => Some(1),
            Blocks::Granite => Some(2),
            Blocks::PolishedGranite => Some(3),
            Blocks::Diorite => Some(4),
            Blocks::PolishedDiorite => Some(5),
            Blocks::Andesite => Some(6),
            Blocks::PolishedAndesite => Some(7),
            Blocks::GrassBlock(state) => {
                Some(8 + (!state.snowy() as i32))
            }
            Blocks::Dirt => Some(10),
            Blocks::CoarseDirt => Some(11),
            Blocks::Podzol(state) => {
                Some(12 + (!state.snowy() as i32))
            }
            Blocks::Cobblestone => Some(14),
            Blocks::OakPlanks => Some(15),
            Blocks::SprucePlanks => Some(16),
            Blocks::BirchPlanks => Some(17),
            Blocks::JunglePlanks => Some(18),
            Blocks::AcaciaPlanks => Some(19),
            Blocks::DarkOakPlanks => Some(20),
            Blocks::OakSapling(state) => {
                Some(21 + state.stage)
            }
            Blocks::SpruceSapling(state) => {
                Some(23 + state.stage)
            }
            Blocks::BirchSapling(state) => {
                Some(25 + state.stage)
            }
            Blocks::JungleSapling(state) => {
                Some(27 + state.stage)
            }
            Blocks::AcaciaSapling(state) => {
                Some(29 + state.stage)
            }
            Blocks::DarkOakSapling(state) => {
                Some(31 + state.stage)
            }
            Blocks::Bedrock => Some(33),
            Blocks::Water(state) => {
                Some(34 + state.level)
            }
            Blocks::Lava(state) => {
                Some(50 + state.level)
            }
            Blocks::Sand => Some(66),
            Blocks::RedSand => Some(67),
            Blocks::Gravel => Some(68),
            Blocks::GoldOre => Some(69),
            Blocks::DeepslateGoldOre => None,
            Blocks::IronOre => Some(70),
            Blocks::DeepslateIronOre => None,
            Blocks::CoalOre => Some(71),
            Blocks::DeepslateCoalOre => None,
            Blocks::NetherGoldOre => Some(72),
            Blocks::OakLog(state) => {
                Some(73 + (state.axis as i32))
            }
            Blocks::SpruceLog(state) => {
                Some(76 + (state.axis as i32))
            }
            Blocks::BirchLog(state) => {
                Some(79 + (state.axis as i32))
            }
            Blocks::JungleLog(state) => {
                Some(82 + (state.axis as i32))
            }
            Blocks::AcaciaLog(state) => {
                Some(85 + (state.axis as i32))
            }
            Blocks::DarkOakLog(state) => {
                Some(88 + (state.axis as i32))
            }
            Blocks::StrippedSpruceLog(state) => {
                Some(91 + (state.axis as i32))
            }
            Blocks::StrippedBirchLog(state) => {
                Some(94 + (state.axis as i32))
            }
            Blocks::StrippedJungleLog(state) => {
                Some(97 + (state.axis as i32))
            }
            Blocks::StrippedAcaciaLog(state) => {
                Some(100 + (state.axis as i32))
            }
            Blocks::StrippedDarkOakLog(state) => {
                Some(103 + (state.axis as i32))
            }
            Blocks::StrippedOakLog(state) => {
                Some(106 + (state.axis as i32))
            }
            Blocks::OakWood(state) => {
                Some(109 + (state.axis as i32))
            }
            Blocks::SpruceWood(state) => {
                Some(112 + (state.axis as i32))
            }
            Blocks::BirchWood(state) => {
                Some(115 + (state.axis as i32))
            }
            Blocks::JungleWood(state) => {
                Some(118 + (state.axis as i32))
            }
            Blocks::AcaciaWood(state) => {
                Some(121 + (state.axis as i32))
            }
            Blocks::DarkOakWood(state) => {
                Some(124 + (state.axis as i32))
            }
            Blocks::StrippedOakWood(state) => {
                Some(127 + (state.axis as i32))
            }
            Blocks::StrippedSpruceWood(state) => {
                Some(130 + (state.axis as i32))
            }
            Blocks::StrippedBirchWood(state) => {
                Some(133 + (state.axis as i32))
            }
            Blocks::StrippedJungleWood(state) => {
                Some(136 + (state.axis as i32))
            }
            Blocks::StrippedAcaciaWood(state) => {
                Some(139 + (state.axis as i32))
            }
            Blocks::StrippedDarkOakWood(state) => {
                Some(142 + (state.axis as i32))
            }
            Blocks::OakLeaves(state) => {
                Some(145 + (!state.persistent() as i32) + 2 * state.distance)
            }
            Blocks::SpruceLeaves(state) => {
                Some(159 + (!state.persistent() as i32) + 2 * state.distance)
            }
            Blocks::BirchLeaves(state) => {
                Some(173 + (!state.persistent() as i32) + 2 * state.distance)
            }
            Blocks::JungleLeaves(state) => {
                Some(187 + (!state.persistent() as i32) + 2 * state.distance)
            }
            Blocks::AcaciaLeaves(state) => {
                Some(201 + (!state.persistent() as i32) + 2 * state.distance)
            }
            Blocks::DarkOakLeaves(state) => {
                Some(215 + (!state.persistent() as i32) + 2 * state.distance)
            }
            Blocks::AzaleaLeaves(_) => None,
            Blocks::FloweringAzaleaLeaves(_) => None,
            Blocks::Sponge => Some(229),
            Blocks::WetSponge => Some(230),
            Blocks::Glass => Some(231),
            Blocks::LapisOre => Some(232),
            Blocks::DeepslateLapisOre => None,
            Blocks::LapisBlock => Some(233),
            Blocks::Dispenser(state) => {
                Some(234 + (!state.triggered() as i32) + 2 * (state.facing as i32))
            }
            Blocks::Sandstone => Some(246),
            Blocks::ChiseledSandstone => Some(247),
            Blocks::CutSandstone => Some(248),
            Blocks::NoteBlock(state) => {
                Some(249 + (!state.powered() as i32) + 2 * state.note + 50 * (state.instrument as i32))
            }
            Blocks::WhiteBed(state) => {
                Some(1049 + (state.part as i32) + 2 * (!state.occupied() as i32) + 4 * (state.facing as i32))
            }
            Blocks::OrangeBed(state) => {
                Some(1065 + (state.part as i32) + 2 * (!state.occupied() as i32) + 4 * (state.facing as i32))
            }
            Blocks::MagentaBed(state) => {
                Some(1081 + (state.part as i32) + 2 * (!state.occupied() as i32) + 4 * (state.facing as i32))
            }
            Blocks::LightBlueBed(state) => {
                Some(1097 + (state.part as i32) + 2 * (!state.occupied() as i32) + 4 * (state.facing as i32))
            }
            Blocks::YellowBed(state) => {
                Some(1113 + (state.part as i32) + 2 * (!state.occupied() as i32) + 4 * (state.facing as i32))
            }
            Blocks::LimeBed(state) => {
                Some(1129 + (state.part as i32) + 2 * (!state.occupied() as i32) + 4 * (state.facing as i32))
            }
            Blocks::PinkBed(state) => {
                Some(1145 + (state.part as i32) + 2 * (!state.occupied() as i32) + 4 * (state.facing as i32))
            }
            Blocks::GrayBed(state) => {
                Some(1161 + (state.part as i32) + 2 * (!state.occupied() as i32) + 4 * (state.facing as i32))
            }
            Blocks::LightGrayBed(state) => {
                Some(1177 + (state.part as i32) + 2 * (!state.occupied() as i32) + 4 * (state.facing as i32))
            }
            Blocks::CyanBed(state) => {
                Some(1193 + (state.part as i32) + 2 * (!state.occupied() as i32) + 4 * (state.facing as i32))
            }
            Blocks::PurpleBed(state) => {
                Some(1209 + (state.part as i32) + 2 * (!state.occupied() as i32) + 4 * (state.facing as i32))
            }
            Blocks::BlueBed(state) => {
                Some(1225 + (state.part as i32) + 2 * (!state.occupied() as i32) + 4 * (state.facing as i32))
            }
            Blocks::BrownBed(state) => {
                Some(1241 + (state.part as i32) + 2 * (!state.occupied() as i32) + 4 * (state.facing as i32))
            }
            Blocks::GreenBed(state) => {
                Some(1257 + (state.part as i32) + 2 * (!state.occupied() as i32) + 4 * (state.facing as i32))
            }
            Blocks::RedBed(state) => {
                Some(1273 + (state.part as i32) + 2 * (!state.occupied() as i32) + 4 * (state.facing as i32))
            }
            Blocks::BlackBed(state) => {
                Some(1289 + (state.part as i32) + 2 * (!state.occupied() as i32) + 4 * (state.facing as i32))
            }
            Blocks::PoweredRail(state) => {
                Some(1305 + (state.shape as i32) + 6 * (!state.powered() as i32))
            }
            Blocks::DetectorRail(state) => {
                Some(1317 + (state.shape as i32) + 6 * (!state.powered() as i32))
            }
            Blocks::StickyPiston(state) => {
                Some(1329 + (state.facing as i32) + 6 * (!state.extended() as i32))
            }
            Blocks::Cobweb => Some(1341),
            Blocks::Grass => Some(1342),
            Blocks::Fern => Some(1343),
            Blocks::DeadBush => Some(1344),
            Blocks::Seagrass => Some(1345),
            Blocks::TallSeagrass(state) => {
                Some(1346 + (state.half as i32))
            }
            Blocks::Piston(state) => {
                Some(1348 + (state.facing as i32) + 6 * (!state.extended() as i32))
            }
            Blocks::PistonHead(state) => {
                Some(1360 + (state.typed as i32) + 2 * (!state.short() as i32) + 4 * (state.facing as i32))
            }
            Blocks::WhiteWool => Some(1384),
            Blocks::OrangeWool => Some(1385),
            Blocks::MagentaWool => Some(1386),
            Blocks::LightBlueWool => Some(1387),
            Blocks::YellowWool => Some(1388),
            Blocks::LimeWool => Some(1389),
            Blocks::PinkWool => Some(1390),
            Blocks::GrayWool => Some(1391),
            Blocks::LightGrayWool => Some(1392),
            Blocks::CyanWool => Some(1393),
            Blocks::PurpleWool => Some(1394),
            Blocks::BlueWool => Some(1395),
            Blocks::BrownWool => Some(1396),
            Blocks::GreenWool => Some(1397),
            Blocks::RedWool => Some(1398),
            Blocks::BlackWool => Some(1399),
            Blocks::MovingPiston(state) => {
                Some(1400 + (state.typed as i32) + 2 * (state.facing as i32))
            }
            Blocks::Dandelion => Some(1412),
            Blocks::Poppy => Some(1413),
            Blocks::BlueOrchid => Some(1414),
            Blocks::Allium => Some(1415),
            Blocks::AzureBluet => Some(1416),
            Blocks::RedTulip => Some(1417),
            Blocks::OrangeTulip => Some(1418),
            Blocks::WhiteTulip => Some(1419),
            Blocks::PinkTulip => Some(1420),
            Blocks::OxeyeDaisy => Some(1421),
            Blocks::Cornflower => Some(1422),
            Blocks::WitherRose => Some(1423),
            Blocks::LilyOfTheValley => Some(1424),
            Blocks::BrownMushroom => Some(1425),
            Blocks::RedMushroom => Some(1426),
            Blocks::GoldBlock => Some(1427),
            Blocks::IronBlock => Some(1428),
            Blocks::Bricks => Some(1429),
            Blocks::Tnt(state) => {
                Some(1430 + (!state.unstable() as i32))
            }
            Blocks::Bookshelf => Some(1432),
            Blocks::MossyCobblestone => Some(1433),
            Blocks::Obsidian => Some(1434),
            Blocks::Torch => Some(1435),
            Blocks::WallTorch(state) => {
                Some(1436 + (state.facing as i32))
            }
            Blocks::Fire(state) => {
                Some(1440 + (!state.west() as i32) + 2 * (!state.up() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32) + 32 * state.age)
            }
            Blocks::SoulFire => Some(1952),
            Blocks::Spawner => Some(1953),
            Blocks::OakStairs(state) => {
                Some(1954 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::Chest(state) => {
                Some(2034 + (!state.waterlogged() as i32) + 2 * (state.typed as i32) + 6 * (state.facing as i32))
            }
            Blocks::RedstoneWire(state) => {
                Some(2058 + (state.west as i32) + 3 * (state.south as i32) + 9 * state.power + 144 * (state.north as i32) + 432 * (state.east as i32))
            }
            Blocks::DiamondOre => Some(3354),
            Blocks::DeepslateDiamondOre => None,
            Blocks::DiamondBlock => Some(3355),
            Blocks::CraftingTable => Some(3356),
            Blocks::Wheat(state) => {
                Some(3357 + state.age)
            }
            Blocks::Farmland(state) => {
                Some(3365 + state.moisture)
            }
            Blocks::Furnace(state) => {
                Some(3373 + (!state.lit() as i32) + 2 * (state.facing as i32))
            }
            Blocks::OakSign(state) => {
                Some(3381 + (!state.waterlogged() as i32) + 2 * state.rotation)
            }
            Blocks::SpruceSign(state) => {
                Some(3413 + (!state.waterlogged() as i32) + 2 * state.rotation)
            }
            Blocks::BirchSign(state) => {
                Some(3445 + (!state.waterlogged() as i32) + 2 * state.rotation)
            }
            Blocks::AcaciaSign(state) => {
                Some(3477 + (!state.waterlogged() as i32) + 2 * state.rotation)
            }
            Blocks::JungleSign(state) => {
                Some(3509 + (!state.waterlogged() as i32) + 2 * state.rotation)
            }
            Blocks::DarkOakSign(state) => {
                Some(3541 + (!state.waterlogged() as i32) + 2 * state.rotation)
            }
            Blocks::OakDoor(state) => {
                Some(3573 + (!state.powered() as i32) + 2 * (!state.open() as i32) + 4 * (state.hinge as i32) + 8 * (state.half as i32) + 16 * (state.facing as i32))
            }
            Blocks::Ladder(state) => {
                Some(3637 + (!state.waterlogged() as i32) + 2 * (state.facing as i32))
            }
            Blocks::Rail(state) => {
                Some(3645 + (state.shape as i32))
            }
            Blocks::CobblestoneStairs(state) => {
                Some(3655 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::OakWallSign(state) => {
                Some(3735 + (!state.waterlogged() as i32) + 2 * (state.facing as i32))
            }
            Blocks::SpruceWallSign(state) => {
                Some(3743 + (!state.waterlogged() as i32) + 2 * (state.facing as i32))
            }
            Blocks::BirchWallSign(state) => {
                Some(3751 + (!state.waterlogged() as i32) + 2 * (state.facing as i32))
            }
            Blocks::AcaciaWallSign(state) => {
                Some(3759 + (!state.waterlogged() as i32) + 2 * (state.facing as i32))
            }
            Blocks::JungleWallSign(state) => {
                Some(3767 + (!state.waterlogged() as i32) + 2 * (state.facing as i32))
            }
            Blocks::DarkOakWallSign(state) => {
                Some(3775 + (!state.waterlogged() as i32) + 2 * (state.facing as i32))
            }
            Blocks::Lever(state) => {
                Some(3783 + (!state.powered() as i32) + 2 * (state.facing as i32) + 8 * (state.face as i32))
            }
            Blocks::StonePressurePlate(state) => {
                Some(3807 + (!state.powered() as i32))
            }
            Blocks::IronDoor(state) => {
                Some(3809 + (!state.powered() as i32) + 2 * (!state.open() as i32) + 4 * (state.hinge as i32) + 8 * (state.half as i32) + 16 * (state.facing as i32))
            }
            Blocks::OakPressurePlate(state) => {
                Some(3873 + (!state.powered() as i32))
            }
            Blocks::SprucePressurePlate(state) => {
                Some(3875 + (!state.powered() as i32))
            }
            Blocks::BirchPressurePlate(state) => {
                Some(3877 + (!state.powered() as i32))
            }
            Blocks::JunglePressurePlate(state) => {
                Some(3879 + (!state.powered() as i32))
            }
            Blocks::AcaciaPressurePlate(state) => {
                Some(3881 + (!state.powered() as i32))
            }
            Blocks::DarkOakPressurePlate(state) => {
                Some(3883 + (!state.powered() as i32))
            }
            Blocks::RedstoneOre(state) => {
                Some(3885 + (!state.lit() as i32))
            }
            Blocks::DeepslateRedstoneOre(_) => None,
            Blocks::RedstoneTorch(state) => {
                Some(3887 + (!state.lit() as i32))
            }
            Blocks::RedstoneWallTorch(state) => {
                Some(3889 + (!state.lit() as i32) + 2 * (state.facing as i32))
            }
            Blocks::StoneButton(state) => {
                Some(3897 + (!state.powered() as i32) + 2 * (state.facing as i32) + 8 * (state.face as i32))
            }
            Blocks::Snow(state) => {
                Some(3921 + state.layers)
            }
            Blocks::Ice => Some(3929),
            Blocks::SnowBlock => Some(3930),
            Blocks::Cactus(state) => {
                Some(3931 + state.age)
            }
            Blocks::Clay => Some(3947),
            Blocks::SugarCane(state) => {
                Some(3948 + state.age)
            }
            Blocks::Jukebox(state) => {
                Some(3964 + (!state.has_record() as i32))
            }
            Blocks::OakFence(state) => {
                Some(3966 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::Pumpkin => Some(3998),
            Blocks::Netherrack => Some(3999),
            Blocks::SoulSand => Some(4000),
            Blocks::SoulSoil => Some(4001),
            Blocks::Basalt(state) => {
                Some(4002 + (state.axis as i32))
            }
            Blocks::PolishedBasalt(state) => {
                Some(4005 + (state.axis as i32))
            }
            Blocks::SoulTorch => Some(4008),
            Blocks::SoulWallTorch(state) => {
                Some(4009 + (state.facing as i32))
            }
            Blocks::Glowstone => Some(4013),
            Blocks::NetherPortal(state) => {
                Some(4014 + (state.axis as i32))
            }
            Blocks::CarvedPumpkin(state) => {
                Some(4016 + (state.facing as i32))
            }
            Blocks::JackOLantern(state) => {
                Some(4020 + (state.facing as i32))
            }
            Blocks::Cake(state) => {
                Some(4024 + state.bites)
            }
            Blocks::Repeater(state) => {
                Some(4031 + (!state.powered() as i32) + 2 * (!state.locked() as i32) + 4 * (state.facing as i32) + 16 * state.delay)
            }
            Blocks::WhiteStainedGlass => Some(4095),
            Blocks::OrangeStainedGlass => Some(4096),
            Blocks::MagentaStainedGlass => Some(4097),
            Blocks::LightBlueStainedGlass => Some(4098),
            Blocks::YellowStainedGlass => Some(4099),
            Blocks::LimeStainedGlass => Some(4100),
            Blocks::PinkStainedGlass => Some(4101),
            Blocks::GrayStainedGlass => Some(4102),
            Blocks::LightGrayStainedGlass => Some(4103),
            Blocks::CyanStainedGlass => Some(4104),
            Blocks::PurpleStainedGlass => Some(4105),
            Blocks::BlueStainedGlass => Some(4106),
            Blocks::BrownStainedGlass => Some(4107),
            Blocks::GreenStainedGlass => Some(4108),
            Blocks::RedStainedGlass => Some(4109),
            Blocks::BlackStainedGlass => Some(4110),
            Blocks::OakTrapdoor(state) => {
                Some(4111 + (!state.waterlogged() as i32) + 2 * (!state.powered() as i32) + 4 * (!state.open() as i32) + 8 * (state.half as i32) + 16 * (state.facing as i32))
            }
            Blocks::SpruceTrapdoor(state) => {
                Some(4175 + (!state.waterlogged() as i32) + 2 * (!state.powered() as i32) + 4 * (!state.open() as i32) + 8 * (state.half as i32) + 16 * (state.facing as i32))
            }
            Blocks::BirchTrapdoor(state) => {
                Some(4239 + (!state.waterlogged() as i32) + 2 * (!state.powered() as i32) + 4 * (!state.open() as i32) + 8 * (state.half as i32) + 16 * (state.facing as i32))
            }
            Blocks::JungleTrapdoor(state) => {
                Some(4303 + (!state.waterlogged() as i32) + 2 * (!state.powered() as i32) + 4 * (!state.open() as i32) + 8 * (state.half as i32) + 16 * (state.facing as i32))
            }
            Blocks::AcaciaTrapdoor(state) => {
                Some(4367 + (!state.waterlogged() as i32) + 2 * (!state.powered() as i32) + 4 * (!state.open() as i32) + 8 * (state.half as i32) + 16 * (state.facing as i32))
            }
            Blocks::DarkOakTrapdoor(state) => {
                Some(4431 + (!state.waterlogged() as i32) + 2 * (!state.powered() as i32) + 4 * (!state.open() as i32) + 8 * (state.half as i32) + 16 * (state.facing as i32))
            }
            Blocks::StoneBricks => Some(4495),
            Blocks::MossyStoneBricks => Some(4496),
            Blocks::CrackedStoneBricks => Some(4497),
            Blocks::ChiseledStoneBricks => Some(4498),
            Blocks::InfestedStone => Some(4499),
            Blocks::InfestedCobblestone => Some(4500),
            Blocks::InfestedStoneBricks => Some(4501),
            Blocks::InfestedMossyStoneBricks => Some(4502),
            Blocks::InfestedCrackedStoneBricks => Some(4503),
            Blocks::InfestedChiseledStoneBricks => Some(4504),
            Blocks::BrownMushroomBlock(state) => {
                Some(4505 + (!state.west() as i32) + 2 * (!state.up() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32) + 32 * (!state.down() as i32))
            }
            Blocks::RedMushroomBlock(state) => {
                Some(4569 + (!state.west() as i32) + 2 * (!state.up() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32) + 32 * (!state.down() as i32))
            }
            Blocks::MushroomStem(state) => {
                Some(4633 + (!state.west() as i32) + 2 * (!state.up() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32) + 32 * (!state.down() as i32))
            }
            Blocks::IronBars(state) => {
                Some(4697 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::Chain(state) => {
                Some(4729 + (!state.waterlogged() as i32) + 2 * (state.axis as i32))
            }
            Blocks::GlassPane(state) => {
                Some(4735 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::Melon => Some(4767),
            Blocks::AttachedPumpkinStem(state) => {
                Some(4768 + (state.facing as i32))
            }
            Blocks::AttachedMelonStem(state) => {
                Some(4772 + (state.facing as i32))
            }
            Blocks::PumpkinStem(state) => {
                Some(4776 + state.age)
            }
            Blocks::MelonStem(state) => {
                Some(4784 + state.age)
            }
            Blocks::Vine(state) => {
                Some(4792 + (!state.west() as i32) + 2 * (!state.up() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::GlowLichen(_) => None,
            Blocks::OakFenceGate(state) => {
                Some(4824 + (!state.powered() as i32) + 2 * (!state.open() as i32) + 4 * (!state.in_wall() as i32) + 8 * (state.facing as i32))
            }
            Blocks::BrickStairs(state) => {
                Some(4856 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::StoneBrickStairs(state) => {
                Some(4936 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::Mycelium(state) => {
                Some(5016 + (!state.snowy() as i32))
            }
            Blocks::LilyPad => Some(5018),
            Blocks::NetherBricks => Some(5019),
            Blocks::NetherBrickFence(state) => {
                Some(5020 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::NetherBrickStairs(state) => {
                Some(5052 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::NetherWart(state) => {
                Some(5132 + state.age)
            }
            Blocks::EnchantingTable => Some(5136),
            Blocks::BrewingStand(state) => {
                Some(5137 + (!state.has_bottle_2() as i32) + 2 * (!state.has_bottle_1() as i32) + 4 * (!state.has_bottle_0() as i32))
            }
            Blocks::Cauldron => Some(5145),
            Blocks::WaterCauldron(state) => {
                Some(5146 + state.level)
            }
            Blocks::LavaCauldron => None,
            Blocks::PowderSnowCauldron(_) => None,
            Blocks::EndPortal => Some(5149),
            Blocks::EndPortalFrame(state) => {
                Some(5150 + (state.facing as i32) + 4 * (!state.eye() as i32))
            }
            Blocks::EndStone => Some(5158),
            Blocks::DragonEgg => Some(5159),
            Blocks::RedstoneLamp(state) => {
                Some(5160 + (!state.lit() as i32))
            }
            Blocks::Cocoa(state) => {
                Some(5162 + (state.facing as i32) + 4 * state.age)
            }
            Blocks::SandstoneStairs(state) => {
                Some(5174 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::EmeraldOre => Some(5254),
            Blocks::DeepslateEmeraldOre => None,
            Blocks::EnderChest(state) => {
                Some(5255 + (!state.waterlogged() as i32) + 2 * (state.facing as i32))
            }
            Blocks::TripwireHook(state) => {
                Some(5263 + (!state.powered() as i32) + 2 * (state.facing as i32) + 8 * (!state.attached() as i32))
            }
            Blocks::Tripwire(state) => {
                Some(5279 + (!state.west() as i32) + 2 * (!state.south() as i32) + 4 * (!state.powered() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32) + 32 * (!state.disarmed() as i32) + 64 * (!state.attached() as i32))
            }
            Blocks::EmeraldBlock => Some(5407),
            Blocks::SpruceStairs(state) => {
                Some(5408 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::BirchStairs(state) => {
                Some(5488 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::JungleStairs(state) => {
                Some(5568 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::CommandBlock(state) => {
                Some(5648 + (state.facing as i32) + 6 * (!state.conditional() as i32))
            }
            Blocks::Beacon => Some(5660),
            Blocks::CobblestoneWall(state) => {
                Some(5661 + (state.west as i32) + 3 * (!state.waterlogged() as i32) + 6 * (!state.up() as i32) + 12 * (state.south as i32) + 36 * (state.north as i32) + 108 * (state.east as i32))
            }
            Blocks::MossyCobblestoneWall(state) => {
                Some(5985 + (state.west as i32) + 3 * (!state.waterlogged() as i32) + 6 * (!state.up() as i32) + 12 * (state.south as i32) + 36 * (state.north as i32) + 108 * (state.east as i32))
            }
            Blocks::FlowerPot => Some(6309),
            Blocks::PottedOakSapling => Some(6310),
            Blocks::PottedSpruceSapling => Some(6311),
            Blocks::PottedBirchSapling => Some(6312),
            Blocks::PottedJungleSapling => Some(6313),
            Blocks::PottedAcaciaSapling => Some(6314),
            Blocks::PottedDarkOakSapling => Some(6315),
            Blocks::PottedFern => Some(6316),
            Blocks::PottedDandelion => Some(6317),
            Blocks::PottedPoppy => Some(6318),
            Blocks::PottedBlueOrchid => Some(6319),
            Blocks::PottedAllium => Some(6320),
            Blocks::PottedAzureBluet => Some(6321),
            Blocks::PottedRedTulip => Some(6322),
            Blocks::PottedOrangeTulip => Some(6323),
            Blocks::PottedWhiteTulip => Some(6324),
            Blocks::PottedPinkTulip => Some(6325),
            Blocks::PottedOxeyeDaisy => Some(6326),
            Blocks::PottedCornflower => Some(6327),
            Blocks::PottedLilyOfTheValley => Some(6328),
            Blocks::PottedWitherRose => Some(6329),
            Blocks::PottedRedMushroom => Some(6330),
            Blocks::PottedBrownMushroom => Some(6331),
            Blocks::PottedDeadBush => Some(6332),
            Blocks::PottedCactus => Some(6333),
            Blocks::Carrots(state) => {
                Some(6334 + state.age)
            }
            Blocks::Potatoes(state) => {
                Some(6342 + state.age)
            }
            Blocks::OakButton(state) => {
                Some(6350 + (!state.powered() as i32) + 2 * (state.facing as i32) + 8 * (state.face as i32))
            }
            Blocks::SpruceButton(state) => {
                Some(6374 + (!state.powered() as i32) + 2 * (state.facing as i32) + 8 * (state.face as i32))
            }
            Blocks::BirchButton(state) => {
                Some(6398 + (!state.powered() as i32) + 2 * (state.facing as i32) + 8 * (state.face as i32))
            }
            Blocks::JungleButton(state) => {
                Some(6422 + (!state.powered() as i32) + 2 * (state.facing as i32) + 8 * (state.face as i32))
            }
            Blocks::AcaciaButton(state) => {
                Some(6446 + (!state.powered() as i32) + 2 * (state.facing as i32) + 8 * (state.face as i32))
            }
            Blocks::DarkOakButton(state) => {
                Some(6470 + (!state.powered() as i32) + 2 * (state.facing as i32) + 8 * (state.face as i32))
            }
            Blocks::SkeletonSkull(state) => {
                Some(6494 + state.rotation)
            }
            Blocks::SkeletonWallSkull(state) => {
                Some(6510 + (state.facing as i32))
            }
            Blocks::WitherSkeletonSkull(state) => {
                Some(6514 + state.rotation)
            }
            Blocks::WitherSkeletonWallSkull(state) => {
                Some(6530 + (state.facing as i32))
            }
            Blocks::ZombieHead(state) => {
                Some(6534 + state.rotation)
            }
            Blocks::ZombieWallHead(state) => {
                Some(6550 + (state.facing as i32))
            }
            Blocks::PlayerHead(state) => {
                Some(6554 + state.rotation)
            }
            Blocks::PlayerWallHead(state) => {
                Some(6570 + (state.facing as i32))
            }
            Blocks::CreeperHead(state) => {
                Some(6574 + state.rotation)
            }
            Blocks::CreeperWallHead(state) => {
                Some(6590 + (state.facing as i32))
            }
            Blocks::DragonHead(state) => {
                Some(6594 + state.rotation)
            }
            Blocks::DragonWallHead(state) => {
                Some(6610 + (state.facing as i32))
            }
            Blocks::Anvil(state) => {
                Some(6614 + (state.facing as i32))
            }
            Blocks::ChippedAnvil(state) => {
                Some(6618 + (state.facing as i32))
            }
            Blocks::DamagedAnvil(state) => {
                Some(6622 + (state.facing as i32))
            }
            Blocks::TrappedChest(state) => {
                Some(6626 + (!state.waterlogged() as i32) + 2 * (state.typed as i32) + 6 * (state.facing as i32))
            }
            Blocks::LightWeightedPressurePlate(state) => {
                Some(6650 + state.power)
            }
            Blocks::HeavyWeightedPressurePlate(state) => {
                Some(6666 + state.power)
            }
            Blocks::Comparator(state) => {
                Some(6682 + (!state.powered() as i32) + 2 * (state.mode as i32) + 4 * (state.facing as i32))
            }
            Blocks::DaylightDetector(state) => {
                Some(6698 + state.power + 16 * (!state.inverted() as i32))
            }
            Blocks::RedstoneBlock => Some(6730),
            Blocks::NetherQuartzOre => Some(6731),
            Blocks::Hopper(state) => {
                Some(6732 + (state.facing as i32) + 5 * (!state.enabled() as i32))
            }
            Blocks::QuartzBlock => Some(6742),
            Blocks::ChiseledQuartzBlock => Some(6743),
            Blocks::QuartzPillar(state) => {
                Some(6744 + (state.axis as i32))
            }
            Blocks::QuartzStairs(state) => {
                Some(6747 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::ActivatorRail(state) => {
                Some(6827 + (state.shape as i32) + 6 * (!state.powered() as i32))
            }
            Blocks::Dropper(state) => {
                Some(6839 + (!state.triggered() as i32) + 2 * (state.facing as i32))
            }
            Blocks::WhiteTerracotta => Some(6851),
            Blocks::OrangeTerracotta => Some(6852),
            Blocks::MagentaTerracotta => Some(6853),
            Blocks::LightBlueTerracotta => Some(6854),
            Blocks::YellowTerracotta => Some(6855),
            Blocks::LimeTerracotta => Some(6856),
            Blocks::PinkTerracotta => Some(6857),
            Blocks::GrayTerracotta => Some(6858),
            Blocks::LightGrayTerracotta => Some(6859),
            Blocks::CyanTerracotta => Some(6860),
            Blocks::PurpleTerracotta => Some(6861),
            Blocks::BlueTerracotta => Some(6862),
            Blocks::BrownTerracotta => Some(6863),
            Blocks::GreenTerracotta => Some(6864),
            Blocks::RedTerracotta => Some(6865),
            Blocks::BlackTerracotta => Some(6866),
            Blocks::WhiteStainedGlassPane(state) => {
                Some(6867 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::OrangeStainedGlassPane(state) => {
                Some(6899 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::MagentaStainedGlassPane(state) => {
                Some(6931 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::LightBlueStainedGlassPane(state) => {
                Some(6963 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::YellowStainedGlassPane(state) => {
                Some(6995 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::LimeStainedGlassPane(state) => {
                Some(7027 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::PinkStainedGlassPane(state) => {
                Some(7059 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::GrayStainedGlassPane(state) => {
                Some(7091 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::LightGrayStainedGlassPane(state) => {
                Some(7123 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::CyanStainedGlassPane(state) => {
                Some(7155 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::PurpleStainedGlassPane(state) => {
                Some(7187 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::BlueStainedGlassPane(state) => {
                Some(7219 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::BrownStainedGlassPane(state) => {
                Some(7251 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::GreenStainedGlassPane(state) => {
                Some(7283 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::RedStainedGlassPane(state) => {
                Some(7315 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::BlackStainedGlassPane(state) => {
                Some(7347 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::AcaciaStairs(state) => {
                Some(7379 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::DarkOakStairs(state) => {
                Some(7459 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::SlimeBlock => Some(7539),
            Blocks::Barrier => Some(7540),
            Blocks::Light(_) => None,
            Blocks::IronTrapdoor(state) => {
                Some(7541 + (!state.waterlogged() as i32) + 2 * (!state.powered() as i32) + 4 * (!state.open() as i32) + 8 * (state.half as i32) + 16 * (state.facing as i32))
            }
            Blocks::Prismarine => Some(7605),
            Blocks::PrismarineBricks => Some(7606),
            Blocks::DarkPrismarine => Some(7607),
            Blocks::PrismarineStairs(state) => {
                Some(7608 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::PrismarineBrickStairs(state) => {
                Some(7688 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::DarkPrismarineStairs(state) => {
                Some(7768 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::PrismarineSlab(state) => {
                Some(7848 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::PrismarineBrickSlab(state) => {
                Some(7854 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::DarkPrismarineSlab(state) => {
                Some(7860 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::SeaLantern => Some(7866),
            Blocks::HayBlock(state) => {
                Some(7867 + (state.axis as i32))
            }
            Blocks::WhiteCarpet => Some(7870),
            Blocks::OrangeCarpet => Some(7871),
            Blocks::MagentaCarpet => Some(7872),
            Blocks::LightBlueCarpet => Some(7873),
            Blocks::YellowCarpet => Some(7874),
            Blocks::LimeCarpet => Some(7875),
            Blocks::PinkCarpet => Some(7876),
            Blocks::GrayCarpet => Some(7877),
            Blocks::LightGrayCarpet => Some(7878),
            Blocks::CyanCarpet => Some(7879),
            Blocks::PurpleCarpet => Some(7880),
            Blocks::BlueCarpet => Some(7881),
            Blocks::BrownCarpet => Some(7882),
            Blocks::GreenCarpet => Some(7883),
            Blocks::RedCarpet => Some(7884),
            Blocks::BlackCarpet => Some(7885),
            Blocks::Terracotta => Some(7886),
            Blocks::CoalBlock => Some(7887),
            Blocks::PackedIce => Some(7888),
            Blocks::Sunflower(state) => {
                Some(7889 + (state.half as i32))
            }
            Blocks::Lilac(state) => {
                Some(7891 + (state.half as i32))
            }
            Blocks::RoseBush(state) => {
                Some(7893 + (state.half as i32))
            }
            Blocks::Peony(state) => {
                Some(7895 + (state.half as i32))
            }
            Blocks::TallGrass(state) => {
                Some(7897 + (state.half as i32))
            }
            Blocks::LargeFern(state) => {
                Some(7899 + (state.half as i32))
            }
            Blocks::WhiteBanner(state) => {
                Some(7901 + state.rotation)
            }
            Blocks::OrangeBanner(state) => {
                Some(7917 + state.rotation)
            }
            Blocks::MagentaBanner(state) => {
                Some(7933 + state.rotation)
            }
            Blocks::LightBlueBanner(state) => {
                Some(7949 + state.rotation)
            }
            Blocks::YellowBanner(state) => {
                Some(7965 + state.rotation)
            }
            Blocks::LimeBanner(state) => {
                Some(7981 + state.rotation)
            }
            Blocks::PinkBanner(state) => {
                Some(7997 + state.rotation)
            }
            Blocks::GrayBanner(state) => {
                Some(8013 + state.rotation)
            }
            Blocks::LightGrayBanner(state) => {
                Some(8029 + state.rotation)
            }
            Blocks::CyanBanner(state) => {
                Some(8045 + state.rotation)
            }
            Blocks::PurpleBanner(state) => {
                Some(8061 + state.rotation)
            }
            Blocks::BlueBanner(state) => {
                Some(8077 + state.rotation)
            }
            Blocks::BrownBanner(state) => {
                Some(8093 + state.rotation)
            }
            Blocks::GreenBanner(state) => {
                Some(8109 + state.rotation)
            }
            Blocks::RedBanner(state) => {
                Some(8125 + state.rotation)
            }
            Blocks::BlackBanner(state) => {
                Some(8141 + state.rotation)
            }
            Blocks::WhiteWallBanner(state) => {
                Some(8157 + (state.facing as i32))
            }
            Blocks::OrangeWallBanner(state) => {
                Some(8161 + (state.facing as i32))
            }
            Blocks::MagentaWallBanner(state) => {
                Some(8165 + (state.facing as i32))
            }
            Blocks::LightBlueWallBanner(state) => {
                Some(8169 + (state.facing as i32))
            }
            Blocks::YellowWallBanner(state) => {
                Some(8173 + (state.facing as i32))
            }
            Blocks::LimeWallBanner(state) => {
                Some(8177 + (state.facing as i32))
            }
            Blocks::PinkWallBanner(state) => {
                Some(8181 + (state.facing as i32))
            }
            Blocks::GrayWallBanner(state) => {
                Some(8185 + (state.facing as i32))
            }
            Blocks::LightGrayWallBanner(state) => {
                Some(8189 + (state.facing as i32))
            }
            Blocks::CyanWallBanner(state) => {
                Some(8193 + (state.facing as i32))
            }
            Blocks::PurpleWallBanner(state) => {
                Some(8197 + (state.facing as i32))
            }
            Blocks::BlueWallBanner(state) => {
                Some(8201 + (state.facing as i32))
            }
            Blocks::BrownWallBanner(state) => {
                Some(8205 + (state.facing as i32))
            }
            Blocks::GreenWallBanner(state) => {
                Some(8209 + (state.facing as i32))
            }
            Blocks::RedWallBanner(state) => {
                Some(8213 + (state.facing as i32))
            }
            Blocks::BlackWallBanner(state) => {
                Some(8217 + (state.facing as i32))
            }
            Blocks::RedSandstone => Some(8221),
            Blocks::ChiseledRedSandstone => Some(8222),
            Blocks::CutRedSandstone => Some(8223),
            Blocks::RedSandstoneStairs(state) => {
                Some(8224 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::OakSlab(state) => {
                Some(8304 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::SpruceSlab(state) => {
                Some(8310 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::BirchSlab(state) => {
                Some(8316 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::JungleSlab(state) => {
                Some(8322 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::AcaciaSlab(state) => {
                Some(8328 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::DarkOakSlab(state) => {
                Some(8334 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::StoneSlab(state) => {
                Some(8340 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::SmoothStoneSlab(state) => {
                Some(8346 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::SandstoneSlab(state) => {
                Some(8352 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::CutSandstoneSlab(state) => {
                Some(8358 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::PetrifiedOakSlab(state) => {
                Some(8364 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::CobblestoneSlab(state) => {
                Some(8370 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::BrickSlab(state) => {
                Some(8376 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::StoneBrickSlab(state) => {
                Some(8382 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::NetherBrickSlab(state) => {
                Some(8388 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::QuartzSlab(state) => {
                Some(8394 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::RedSandstoneSlab(state) => {
                Some(8400 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::CutRedSandstoneSlab(state) => {
                Some(8406 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::PurpurSlab(state) => {
                Some(8412 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::SmoothStone => Some(8418),
            Blocks::SmoothSandstone => Some(8419),
            Blocks::SmoothQuartz => Some(8420),
            Blocks::SmoothRedSandstone => Some(8421),
            Blocks::SpruceFenceGate(state) => {
                Some(8422 + (!state.powered() as i32) + 2 * (!state.open() as i32) + 4 * (!state.in_wall() as i32) + 8 * (state.facing as i32))
            }
            Blocks::BirchFenceGate(state) => {
                Some(8454 + (!state.powered() as i32) + 2 * (!state.open() as i32) + 4 * (!state.in_wall() as i32) + 8 * (state.facing as i32))
            }
            Blocks::JungleFenceGate(state) => {
                Some(8486 + (!state.powered() as i32) + 2 * (!state.open() as i32) + 4 * (!state.in_wall() as i32) + 8 * (state.facing as i32))
            }
            Blocks::AcaciaFenceGate(state) => {
                Some(8518 + (!state.powered() as i32) + 2 * (!state.open() as i32) + 4 * (!state.in_wall() as i32) + 8 * (state.facing as i32))
            }
            Blocks::DarkOakFenceGate(state) => {
                Some(8550 + (!state.powered() as i32) + 2 * (!state.open() as i32) + 4 * (!state.in_wall() as i32) + 8 * (state.facing as i32))
            }
            Blocks::SpruceFence(state) => {
                Some(8582 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::BirchFence(state) => {
                Some(8614 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::JungleFence(state) => {
                Some(8646 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::AcaciaFence(state) => {
                Some(8678 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::DarkOakFence(state) => {
                Some(8710 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::SpruceDoor(state) => {
                Some(8742 + (!state.powered() as i32) + 2 * (!state.open() as i32) + 4 * (state.hinge as i32) + 8 * (state.half as i32) + 16 * (state.facing as i32))
            }
            Blocks::BirchDoor(state) => {
                Some(8806 + (!state.powered() as i32) + 2 * (!state.open() as i32) + 4 * (state.hinge as i32) + 8 * (state.half as i32) + 16 * (state.facing as i32))
            }
            Blocks::JungleDoor(state) => {
                Some(8870 + (!state.powered() as i32) + 2 * (!state.open() as i32) + 4 * (state.hinge as i32) + 8 * (state.half as i32) + 16 * (state.facing as i32))
            }
            Blocks::AcaciaDoor(state) => {
                Some(8934 + (!state.powered() as i32) + 2 * (!state.open() as i32) + 4 * (state.hinge as i32) + 8 * (state.half as i32) + 16 * (state.facing as i32))
            }
            Blocks::DarkOakDoor(state) => {
                Some(8998 + (!state.powered() as i32) + 2 * (!state.open() as i32) + 4 * (state.hinge as i32) + 8 * (state.half as i32) + 16 * (state.facing as i32))
            }
            Blocks::EndRod(state) => {
                Some(9062 + (state.facing as i32))
            }
            Blocks::ChorusPlant(state) => {
                Some(9068 + (!state.west() as i32) + 2 * (!state.up() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32) + 32 * (!state.down() as i32))
            }
            Blocks::ChorusFlower(state) => {
                Some(9132 + state.age)
            }
            Blocks::PurpurBlock => Some(9138),
            Blocks::PurpurPillar(state) => {
                Some(9139 + (state.axis as i32))
            }
            Blocks::PurpurStairs(state) => {
                Some(9142 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::EndStoneBricks => Some(9222),
            Blocks::Beetroots(state) => {
                Some(9223 + state.age)
            }
            Blocks::DirtPath => Some(9227),
            Blocks::EndGateway => Some(9228),
            Blocks::RepeatingCommandBlock(state) => {
                Some(9229 + (state.facing as i32) + 6 * (!state.conditional() as i32))
            }
            Blocks::ChainCommandBlock(state) => {
                Some(9241 + (state.facing as i32) + 6 * (!state.conditional() as i32))
            }
            Blocks::FrostedIce(state) => {
                Some(9253 + state.age)
            }
            Blocks::MagmaBlock => Some(9257),
            Blocks::NetherWartBlock => Some(9258),
            Blocks::RedNetherBricks => Some(9259),
            Blocks::BoneBlock(state) => {
                Some(9260 + (state.axis as i32))
            }
            Blocks::StructureVoid => Some(9263),
            Blocks::Observer(state) => {
                Some(9264 + (!state.powered() as i32) + 2 * (state.facing as i32))
            }
            Blocks::ShulkerBox(state) => {
                Some(9276 + (state.facing as i32))
            }
            Blocks::WhiteShulkerBox(state) => {
                Some(9282 + (state.facing as i32))
            }
            Blocks::OrangeShulkerBox(state) => {
                Some(9288 + (state.facing as i32))
            }
            Blocks::MagentaShulkerBox(state) => {
                Some(9294 + (state.facing as i32))
            }
            Blocks::LightBlueShulkerBox(state) => {
                Some(9300 + (state.facing as i32))
            }
            Blocks::YellowShulkerBox(state) => {
                Some(9306 + (state.facing as i32))
            }
            Blocks::LimeShulkerBox(state) => {
                Some(9312 + (state.facing as i32))
            }
            Blocks::PinkShulkerBox(state) => {
                Some(9318 + (state.facing as i32))
            }
            Blocks::GrayShulkerBox(state) => {
                Some(9324 + (state.facing as i32))
            }
            Blocks::LightGrayShulkerBox(state) => {
                Some(9330 + (state.facing as i32))
            }
            Blocks::CyanShulkerBox(state) => {
                Some(9336 + (state.facing as i32))
            }
            Blocks::PurpleShulkerBox(state) => {
                Some(9342 + (state.facing as i32))
            }
            Blocks::BlueShulkerBox(state) => {
                Some(9348 + (state.facing as i32))
            }
            Blocks::BrownShulkerBox(state) => {
                Some(9354 + (state.facing as i32))
            }
            Blocks::GreenShulkerBox(state) => {
                Some(9360 + (state.facing as i32))
            }
            Blocks::RedShulkerBox(state) => {
                Some(9366 + (state.facing as i32))
            }
            Blocks::BlackShulkerBox(state) => {
                Some(9372 + (state.facing as i32))
            }
            Blocks::WhiteGlazedTerracotta(state) => {
                Some(9378 + (state.facing as i32))
            }
            Blocks::OrangeGlazedTerracotta(state) => {
                Some(9382 + (state.facing as i32))
            }
            Blocks::MagentaGlazedTerracotta(state) => {
                Some(9386 + (state.facing as i32))
            }
            Blocks::LightBlueGlazedTerracotta(state) => {
                Some(9390 + (state.facing as i32))
            }
            Blocks::YellowGlazedTerracotta(state) => {
                Some(9394 + (state.facing as i32))
            }
            Blocks::LimeGlazedTerracotta(state) => {
                Some(9398 + (state.facing as i32))
            }
            Blocks::PinkGlazedTerracotta(state) => {
                Some(9402 + (state.facing as i32))
            }
            Blocks::GrayGlazedTerracotta(state) => {
                Some(9406 + (state.facing as i32))
            }
            Blocks::LightGrayGlazedTerracotta(state) => {
                Some(9410 + (state.facing as i32))
            }
            Blocks::CyanGlazedTerracotta(state) => {
                Some(9414 + (state.facing as i32))
            }
            Blocks::PurpleGlazedTerracotta(state) => {
                Some(9418 + (state.facing as i32))
            }
            Blocks::BlueGlazedTerracotta(state) => {
                Some(9422 + (state.facing as i32))
            }
            Blocks::BrownGlazedTerracotta(state) => {
                Some(9426 + (state.facing as i32))
            }
            Blocks::GreenGlazedTerracotta(state) => {
                Some(9430 + (state.facing as i32))
            }
            Blocks::RedGlazedTerracotta(state) => {
                Some(9434 + (state.facing as i32))
            }
            Blocks::BlackGlazedTerracotta(state) => {
                Some(9438 + (state.facing as i32))
            }
            Blocks::WhiteConcrete => Some(9442),
            Blocks::OrangeConcrete => Some(9443),
            Blocks::MagentaConcrete => Some(9444),
            Blocks::LightBlueConcrete => Some(9445),
            Blocks::YellowConcrete => Some(9446),
            Blocks::LimeConcrete => Some(9447),
            Blocks::PinkConcrete => Some(9448),
            Blocks::GrayConcrete => Some(9449),
            Blocks::LightGrayConcrete => Some(9450),
            Blocks::CyanConcrete => Some(9451),
            Blocks::PurpleConcrete => Some(9452),
            Blocks::BlueConcrete => Some(9453),
            Blocks::BrownConcrete => Some(9454),
            Blocks::GreenConcrete => Some(9455),
            Blocks::RedConcrete => Some(9456),
            Blocks::BlackConcrete => Some(9457),
            Blocks::WhiteConcretePowder => Some(9458),
            Blocks::OrangeConcretePowder => Some(9459),
            Blocks::MagentaConcretePowder => Some(9460),
            Blocks::LightBlueConcretePowder => Some(9461),
            Blocks::YellowConcretePowder => Some(9462),
            Blocks::LimeConcretePowder => Some(9463),
            Blocks::PinkConcretePowder => Some(9464),
            Blocks::GrayConcretePowder => Some(9465),
            Blocks::LightGrayConcretePowder => Some(9466),
            Blocks::CyanConcretePowder => Some(9467),
            Blocks::PurpleConcretePowder => Some(9468),
            Blocks::BlueConcretePowder => Some(9469),
            Blocks::BrownConcretePowder => Some(9470),
            Blocks::GreenConcretePowder => Some(9471),
            Blocks::RedConcretePowder => Some(9472),
            Blocks::BlackConcretePowder => Some(9473),
            Blocks::Kelp(state) => {
                Some(9474 + state.age)
            }
            Blocks::KelpPlant => Some(9500),
            Blocks::DriedKelpBlock => Some(9501),
            Blocks::TurtleEgg(state) => {
                Some(9502 + state.hatch + 3 * state.eggs)
            }
            Blocks::DeadTubeCoralBlock => Some(9514),
            Blocks::DeadBrainCoralBlock => Some(9515),
            Blocks::DeadBubbleCoralBlock => Some(9516),
            Blocks::DeadFireCoralBlock => Some(9517),
            Blocks::DeadHornCoralBlock => Some(9518),
            Blocks::TubeCoralBlock => Some(9519),
            Blocks::BrainCoralBlock => Some(9520),
            Blocks::BubbleCoralBlock => Some(9521),
            Blocks::FireCoralBlock => Some(9522),
            Blocks::HornCoralBlock => Some(9523),
            Blocks::DeadTubeCoral(state) => {
                Some(9524 + (!state.waterlogged() as i32))
            }
            Blocks::DeadBrainCoral(state) => {
                Some(9526 + (!state.waterlogged() as i32))
            }
            Blocks::DeadBubbleCoral(state) => {
                Some(9528 + (!state.waterlogged() as i32))
            }
            Blocks::DeadFireCoral(state) => {
                Some(9530 + (!state.waterlogged() as i32))
            }
            Blocks::DeadHornCoral(state) => {
                Some(9532 + (!state.waterlogged() as i32))
            }
            Blocks::TubeCoral(state) => {
                Some(9534 + (!state.waterlogged() as i32))
            }
            Blocks::BrainCoral(state) => {
                Some(9536 + (!state.waterlogged() as i32))
            }
            Blocks::BubbleCoral(state) => {
                Some(9538 + (!state.waterlogged() as i32))
            }
            Blocks::FireCoral(state) => {
                Some(9540 + (!state.waterlogged() as i32))
            }
            Blocks::HornCoral(state) => {
                Some(9542 + (!state.waterlogged() as i32))
            }
            Blocks::DeadTubeCoralFan(state) => {
                Some(9544 + (!state.waterlogged() as i32))
            }
            Blocks::DeadBrainCoralFan(state) => {
                Some(9546 + (!state.waterlogged() as i32))
            }
            Blocks::DeadBubbleCoralFan(state) => {
                Some(9548 + (!state.waterlogged() as i32))
            }
            Blocks::DeadFireCoralFan(state) => {
                Some(9550 + (!state.waterlogged() as i32))
            }
            Blocks::DeadHornCoralFan(state) => {
                Some(9552 + (!state.waterlogged() as i32))
            }
            Blocks::TubeCoralFan(state) => {
                Some(9554 + (!state.waterlogged() as i32))
            }
            Blocks::BrainCoralFan(state) => {
                Some(9556 + (!state.waterlogged() as i32))
            }
            Blocks::BubbleCoralFan(state) => {
                Some(9558 + (!state.waterlogged() as i32))
            }
            Blocks::FireCoralFan(state) => {
                Some(9560 + (!state.waterlogged() as i32))
            }
            Blocks::HornCoralFan(state) => {
                Some(9562 + (!state.waterlogged() as i32))
            }
            Blocks::DeadTubeCoralWallFan(state) => {
                Some(9564 + (!state.waterlogged() as i32) + 2 * (state.facing as i32))
            }
            Blocks::DeadBrainCoralWallFan(state) => {
                Some(9572 + (!state.waterlogged() as i32) + 2 * (state.facing as i32))
            }
            Blocks::DeadBubbleCoralWallFan(state) => {
                Some(9580 + (!state.waterlogged() as i32) + 2 * (state.facing as i32))
            }
            Blocks::DeadFireCoralWallFan(state) => {
                Some(9588 + (!state.waterlogged() as i32) + 2 * (state.facing as i32))
            }
            Blocks::DeadHornCoralWallFan(state) => {
                Some(9596 + (!state.waterlogged() as i32) + 2 * (state.facing as i32))
            }
            Blocks::TubeCoralWallFan(state) => {
                Some(9604 + (!state.waterlogged() as i32) + 2 * (state.facing as i32))
            }
            Blocks::BrainCoralWallFan(state) => {
                Some(9612 + (!state.waterlogged() as i32) + 2 * (state.facing as i32))
            }
            Blocks::BubbleCoralWallFan(state) => {
                Some(9620 + (!state.waterlogged() as i32) + 2 * (state.facing as i32))
            }
            Blocks::FireCoralWallFan(state) => {
                Some(9628 + (!state.waterlogged() as i32) + 2 * (state.facing as i32))
            }
            Blocks::HornCoralWallFan(state) => {
                Some(9636 + (!state.waterlogged() as i32) + 2 * (state.facing as i32))
            }
            Blocks::SeaPickle(state) => {
                Some(9644 + (!state.waterlogged() as i32) + 2 * state.pickles)
            }
            Blocks::BlueIce => Some(9652),
            Blocks::Conduit(state) => {
                Some(9653 + (!state.waterlogged() as i32))
            }
            Blocks::BambooSapling => Some(9655),
            Blocks::Bamboo(state) => {
                Some(9656 + state.stage + 2 * (state.leaves as i32) + 6 * state.age)
            }
            Blocks::PottedBamboo => Some(9668),
            Blocks::VoidAir => Some(9669),
            Blocks::CaveAir => Some(9670),
            Blocks::BubbleColumn(state) => {
                Some(9671 + (!state.drag() as i32))
            }
            Blocks::PolishedGraniteStairs(state) => {
                Some(9673 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::SmoothRedSandstoneStairs(state) => {
                Some(9753 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::MossyStoneBrickStairs(state) => {
                Some(9833 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::PolishedDioriteStairs(state) => {
                Some(9913 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::MossyCobblestoneStairs(state) => {
                Some(9993 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::EndStoneBrickStairs(state) => {
                Some(10073 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::StoneStairs(state) => {
                Some(10153 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::SmoothSandstoneStairs(state) => {
                Some(10233 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::SmoothQuartzStairs(state) => {
                Some(10313 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::GraniteStairs(state) => {
                Some(10393 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::AndesiteStairs(state) => {
                Some(10473 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::RedNetherBrickStairs(state) => {
                Some(10553 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::PolishedAndesiteStairs(state) => {
                Some(10633 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::DioriteStairs(state) => {
                Some(10713 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::PolishedGraniteSlab(state) => {
                Some(10793 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::SmoothRedSandstoneSlab(state) => {
                Some(10799 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::MossyStoneBrickSlab(state) => {
                Some(10805 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::PolishedDioriteSlab(state) => {
                Some(10811 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::MossyCobblestoneSlab(state) => {
                Some(10817 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::EndStoneBrickSlab(state) => {
                Some(10823 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::SmoothSandstoneSlab(state) => {
                Some(10829 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::SmoothQuartzSlab(state) => {
                Some(10835 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::GraniteSlab(state) => {
                Some(10841 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::AndesiteSlab(state) => {
                Some(10847 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::RedNetherBrickSlab(state) => {
                Some(10853 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::PolishedAndesiteSlab(state) => {
                Some(10859 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::DioriteSlab(state) => {
                Some(10865 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::BrickWall(state) => {
                Some(10871 + (state.west as i32) + 3 * (!state.waterlogged() as i32) + 6 * (!state.up() as i32) + 12 * (state.south as i32) + 36 * (state.north as i32) + 108 * (state.east as i32))
            }
            Blocks::PrismarineWall(state) => {
                Some(11195 + (state.west as i32) + 3 * (!state.waterlogged() as i32) + 6 * (!state.up() as i32) + 12 * (state.south as i32) + 36 * (state.north as i32) + 108 * (state.east as i32))
            }
            Blocks::RedSandstoneWall(state) => {
                Some(11519 + (state.west as i32) + 3 * (!state.waterlogged() as i32) + 6 * (!state.up() as i32) + 12 * (state.south as i32) + 36 * (state.north as i32) + 108 * (state.east as i32))
            }
            Blocks::MossyStoneBrickWall(state) => {
                Some(11843 + (state.west as i32) + 3 * (!state.waterlogged() as i32) + 6 * (!state.up() as i32) + 12 * (state.south as i32) + 36 * (state.north as i32) + 108 * (state.east as i32))
            }
            Blocks::GraniteWall(state) => {
                Some(12167 + (state.west as i32) + 3 * (!state.waterlogged() as i32) + 6 * (!state.up() as i32) + 12 * (state.south as i32) + 36 * (state.north as i32) + 108 * (state.east as i32))
            }
            Blocks::StoneBrickWall(state) => {
                Some(12491 + (state.west as i32) + 3 * (!state.waterlogged() as i32) + 6 * (!state.up() as i32) + 12 * (state.south as i32) + 36 * (state.north as i32) + 108 * (state.east as i32))
            }
            Blocks::NetherBrickWall(state) => {
                Some(12815 + (state.west as i32) + 3 * (!state.waterlogged() as i32) + 6 * (!state.up() as i32) + 12 * (state.south as i32) + 36 * (state.north as i32) + 108 * (state.east as i32))
            }
            Blocks::AndesiteWall(state) => {
                Some(13139 + (state.west as i32) + 3 * (!state.waterlogged() as i32) + 6 * (!state.up() as i32) + 12 * (state.south as i32) + 36 * (state.north as i32) + 108 * (state.east as i32))
            }
            Blocks::RedNetherBrickWall(state) => {
                Some(13463 + (state.west as i32) + 3 * (!state.waterlogged() as i32) + 6 * (!state.up() as i32) + 12 * (state.south as i32) + 36 * (state.north as i32) + 108 * (state.east as i32))
            }
            Blocks::SandstoneWall(state) => {
                Some(13787 + (state.west as i32) + 3 * (!state.waterlogged() as i32) + 6 * (!state.up() as i32) + 12 * (state.south as i32) + 36 * (state.north as i32) + 108 * (state.east as i32))
            }
            Blocks::EndStoneBrickWall(state) => {
                Some(14111 + (state.west as i32) + 3 * (!state.waterlogged() as i32) + 6 * (!state.up() as i32) + 12 * (state.south as i32) + 36 * (state.north as i32) + 108 * (state.east as i32))
            }
            Blocks::DioriteWall(state) => {
                Some(14435 + (state.west as i32) + 3 * (!state.waterlogged() as i32) + 6 * (!state.up() as i32) + 12 * (state.south as i32) + 36 * (state.north as i32) + 108 * (state.east as i32))
            }
            Blocks::Scaffolding(state) => {
                Some(14759 + (!state.waterlogged() as i32) + 2 * state.distance + 16 * (!state.bottom() as i32))
            }
            Blocks::Loom(state) => {
                Some(14791 + (state.facing as i32))
            }
            Blocks::Barrel(state) => {
                Some(14795 + (!state.open() as i32) + 2 * (state.facing as i32))
            }
            Blocks::Smoker(state) => {
                Some(14807 + (!state.lit() as i32) + 2 * (state.facing as i32))
            }
            Blocks::BlastFurnace(state) => {
                Some(14815 + (!state.lit() as i32) + 2 * (state.facing as i32))
            }
            Blocks::CartographyTable => Some(14823),
            Blocks::FletchingTable => Some(14824),
            Blocks::Grindstone(state) => {
                Some(14825 + (state.facing as i32) + 4 * (state.face as i32))
            }
            Blocks::Lectern(state) => {
                Some(14837 + (!state.powered() as i32) + 2 * (!state.has_book() as i32) + 4 * (state.facing as i32))
            }
            Blocks::SmithingTable => Some(14853),
            Blocks::Stonecutter(state) => {
                Some(14854 + (state.facing as i32))
            }
            Blocks::Bell(state) => {
                Some(14858 + (!state.powered() as i32) + 2 * (state.facing as i32) + 8 * (state.attachment as i32))
            }
            Blocks::Lantern(state) => {
                Some(14890 + (!state.waterlogged() as i32) + 2 * (!state.hanging() as i32))
            }
            Blocks::SoulLantern(state) => {
                Some(14894 + (!state.waterlogged() as i32) + 2 * (!state.hanging() as i32))
            }
            Blocks::Campfire(state) => {
                Some(14898 + (!state.waterlogged() as i32) + 2 * (!state.signal_fire() as i32) + 4 * (!state.lit() as i32) + 8 * (state.facing as i32))
            }
            Blocks::SoulCampfire(state) => {
                Some(14930 + (!state.waterlogged() as i32) + 2 * (!state.signal_fire() as i32) + 4 * (!state.lit() as i32) + 8 * (state.facing as i32))
            }
            Blocks::SweetBerryBush(state) => {
                Some(14962 + state.age)
            }
            Blocks::WarpedStem(state) => {
                Some(14966 + (state.axis as i32))
            }
            Blocks::StrippedWarpedStem(state) => {
                Some(14969 + (state.axis as i32))
            }
            Blocks::WarpedHyphae(state) => {
                Some(14972 + (state.axis as i32))
            }
            Blocks::StrippedWarpedHyphae(state) => {
                Some(14975 + (state.axis as i32))
            }
            Blocks::WarpedNylium => Some(14978),
            Blocks::WarpedFungus => Some(14979),
            Blocks::WarpedWartBlock => Some(14980),
            Blocks::WarpedRoots => Some(14981),
            Blocks::NetherSprouts => Some(14982),
            Blocks::CrimsonStem(state) => {
                Some(14983 + (state.axis as i32))
            }
            Blocks::StrippedCrimsonStem(state) => {
                Some(14986 + (state.axis as i32))
            }
            Blocks::CrimsonHyphae(state) => {
                Some(14989 + (state.axis as i32))
            }
            Blocks::StrippedCrimsonHyphae(state) => {
                Some(14992 + (state.axis as i32))
            }
            Blocks::CrimsonNylium => Some(14995),
            Blocks::CrimsonFungus => Some(14996),
            Blocks::Shroomlight => Some(14997),
            Blocks::WeepingVines(state) => {
                Some(14998 + state.age)
            }
            Blocks::WeepingVinesPlant => Some(15024),
            Blocks::TwistingVines(state) => {
                Some(15025 + state.age)
            }
            Blocks::TwistingVinesPlant => Some(15051),
            Blocks::CrimsonRoots => Some(15052),
            Blocks::CrimsonPlanks => Some(15053),
            Blocks::WarpedPlanks => Some(15054),
            Blocks::CrimsonSlab(state) => {
                Some(15055 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::WarpedSlab(state) => {
                Some(15061 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::CrimsonPressurePlate(state) => {
                Some(15067 + (!state.powered() as i32))
            }
            Blocks::WarpedPressurePlate(state) => {
                Some(15069 + (!state.powered() as i32))
            }
            Blocks::CrimsonFence(state) => {
                Some(15071 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::WarpedFence(state) => {
                Some(15103 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::CrimsonTrapdoor(state) => {
                Some(15135 + (!state.waterlogged() as i32) + 2 * (!state.powered() as i32) + 4 * (!state.open() as i32) + 8 * (state.half as i32) + 16 * (state.facing as i32))
            }
            Blocks::WarpedTrapdoor(state) => {
                Some(15199 + (!state.waterlogged() as i32) + 2 * (!state.powered() as i32) + 4 * (!state.open() as i32) + 8 * (state.half as i32) + 16 * (state.facing as i32))
            }
            Blocks::CrimsonFenceGate(state) => {
                Some(15263 + (!state.powered() as i32) + 2 * (!state.open() as i32) + 4 * (!state.in_wall() as i32) + 8 * (state.facing as i32))
            }
            Blocks::WarpedFenceGate(state) => {
                Some(15295 + (!state.powered() as i32) + 2 * (!state.open() as i32) + 4 * (!state.in_wall() as i32) + 8 * (state.facing as i32))
            }
            Blocks::CrimsonStairs(state) => {
                Some(15327 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::WarpedStairs(state) => {
                Some(15407 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::CrimsonButton(state) => {
                Some(15487 + (!state.powered() as i32) + 2 * (state.facing as i32) + 8 * (state.face as i32))
            }
            Blocks::WarpedButton(state) => {
                Some(15511 + (!state.powered() as i32) + 2 * (state.facing as i32) + 8 * (state.face as i32))
            }
            Blocks::CrimsonDoor(state) => {
                Some(15535 + (!state.powered() as i32) + 2 * (!state.open() as i32) + 4 * (state.hinge as i32) + 8 * (state.half as i32) + 16 * (state.facing as i32))
            }
            Blocks::WarpedDoor(state) => {
                Some(15599 + (!state.powered() as i32) + 2 * (!state.open() as i32) + 4 * (state.hinge as i32) + 8 * (state.half as i32) + 16 * (state.facing as i32))
            }
            Blocks::CrimsonSign(state) => {
                Some(15663 + (!state.waterlogged() as i32) + 2 * state.rotation)
            }
            Blocks::WarpedSign(state) => {
                Some(15695 + (!state.waterlogged() as i32) + 2 * state.rotation)
            }
            Blocks::CrimsonWallSign(state) => {
                Some(15727 + (!state.waterlogged() as i32) + 2 * (state.facing as i32))
            }
            Blocks::WarpedWallSign(state) => {
                Some(15735 + (!state.waterlogged() as i32) + 2 * (state.facing as i32))
            }
            Blocks::StructureBlock(state) => {
                Some(15743 + (state.mode as i32))
            }
            Blocks::Jigsaw(state) => {
                Some(15747 + (state.orientation as i32))
            }
            Blocks::Composter(state) => {
                Some(15759 + state.level)
            }
            Blocks::Target(state) => {
                Some(15768 + state.power)
            }
            Blocks::BeeNest(state) => {
                Some(15784 + state.honey_level + 6 * (state.facing as i32))
            }
            Blocks::Beehive(state) => {
                Some(15808 + state.honey_level + 6 * (state.facing as i32))
            }
            Blocks::HoneyBlock => Some(15832),
            Blocks::HoneycombBlock => Some(15833),
            Blocks::NetheriteBlock => Some(15834),
            Blocks::AncientDebris => Some(15835),
            Blocks::CryingObsidian => Some(15836),
            Blocks::RespawnAnchor(state) => {
                Some(15837 + state.charges)
            }
            Blocks::PottedCrimsonFungus => Some(15842),
            Blocks::PottedWarpedFungus => Some(15843),
            Blocks::PottedCrimsonRoots => Some(15844),
            Blocks::PottedWarpedRoots => Some(15845),
            Blocks::Lodestone => Some(15846),
            Blocks::Blackstone => Some(15847),
            Blocks::BlackstoneStairs(state) => {
                Some(15848 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::BlackstoneWall(state) => {
                Some(15928 + (state.west as i32) + 3 * (!state.waterlogged() as i32) + 6 * (!state.up() as i32) + 12 * (state.south as i32) + 36 * (state.north as i32) + 108 * (state.east as i32))
            }
            Blocks::BlackstoneSlab(state) => {
                Some(16252 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::PolishedBlackstone => Some(16258),
            Blocks::PolishedBlackstoneBricks => Some(16259),
            Blocks::CrackedPolishedBlackstoneBricks => Some(16260),
            Blocks::ChiseledPolishedBlackstone => Some(16261),
            Blocks::PolishedBlackstoneBrickSlab(state) => {
                Some(16262 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::PolishedBlackstoneBrickStairs(state) => {
                Some(16268 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::PolishedBlackstoneBrickWall(state) => {
                Some(16348 + (state.west as i32) + 3 * (!state.waterlogged() as i32) + 6 * (!state.up() as i32) + 12 * (state.south as i32) + 36 * (state.north as i32) + 108 * (state.east as i32))
            }
            Blocks::GildedBlackstone => Some(16672),
            Blocks::PolishedBlackstoneStairs(state) => {
                Some(16673 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::PolishedBlackstoneSlab(state) => {
                Some(16753 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::PolishedBlackstonePressurePlate(state) => {
                Some(16759 + (!state.powered() as i32))
            }
            Blocks::PolishedBlackstoneButton(state) => {
                Some(16761 + (!state.powered() as i32) + 2 * (state.facing as i32) + 8 * (state.face as i32))
            }
            Blocks::PolishedBlackstoneWall(state) => {
                Some(16785 + (state.west as i32) + 3 * (!state.waterlogged() as i32) + 6 * (!state.up() as i32) + 12 * (state.south as i32) + 36 * (state.north as i32) + 108 * (state.east as i32))
            }
            Blocks::ChiseledNetherBricks => Some(17109),
            Blocks::CrackedNetherBricks => Some(17110),
            Blocks::QuartzBricks => Some(17111),
            Blocks::Candle(_) => None,
            Blocks::WhiteCandle(_) => None,
            Blocks::OrangeCandle(_) => None,
            Blocks::MagentaCandle(_) => None,
            Blocks::LightBlueCandle(_) => None,
            Blocks::YellowCandle(_) => None,
            Blocks::LimeCandle(_) => None,
            Blocks::PinkCandle(_) => None,
            Blocks::GrayCandle(_) => None,
            Blocks::LightGrayCandle(_) => None,
            Blocks::CyanCandle(_) => None,
            Blocks::PurpleCandle(_) => None,
            Blocks::BlueCandle(_) => None,
            Blocks::BrownCandle(_) => None,
            Blocks::GreenCandle(_) => None,
            Blocks::RedCandle(_) => None,
            Blocks::BlackCandle(_) => None,
            Blocks::CandleCake(_) => None,
            Blocks::WhiteCandleCake(_) => None,
            Blocks::OrangeCandleCake(_) => None,
            Blocks::MagentaCandleCake(_) => None,
            Blocks::LightBlueCandleCake(_) => None,
            Blocks::YellowCandleCake(_) => None,
            Blocks::LimeCandleCake(_) => None,
            Blocks::PinkCandleCake(_) => None,
            Blocks::GrayCandleCake(_) => None,
            Blocks::LightGrayCandleCake(_) => None,
            Blocks::CyanCandleCake(_) => None,
            Blocks::PurpleCandleCake(_) => None,
            Blocks::BlueCandleCake(_) => None,
            Blocks::BrownCandleCake(_) => None,
            Blocks::GreenCandleCake(_) => None,
            Blocks::RedCandleCake(_) => None,
            Blocks::BlackCandleCake(_) => None,
            Blocks::AmethystBlock => None,
            Blocks::BuddingAmethyst => None,
            Blocks::AmethystCluster(_) => None,
            Blocks::LargeAmethystBud(_) => None,
            Blocks::MediumAmethystBud(_) => None,
            Blocks::SmallAmethystBud(_) => None,
            Blocks::Tuff => None,
            Blocks::Calcite => None,
            Blocks::TintedGlass => None,
            Blocks::PowderSnow => None,
            Blocks::SculkSensor(_) => None,
            Blocks::OxidizedCopper => None,
            Blocks::WeatheredCopper => None,
            Blocks::ExposedCopper => None,
            Blocks::CopperBlock => None,
            Blocks::CopperOre => None,
            Blocks::DeepslateCopperOre => None,
            Blocks::OxidizedCutCopper => None,
            Blocks::WeatheredCutCopper => None,
            Blocks::ExposedCutCopper => None,
            Blocks::CutCopper => None,
            Blocks::OxidizedCutCopperStairs(_) => None,
            Blocks::WeatheredCutCopperStairs(_) => None,
            Blocks::ExposedCutCopperStairs(_) => None,
            Blocks::CutCopperStairs(_) => None,
            Blocks::OxidizedCutCopperSlab(_) => None,
            Blocks::WeatheredCutCopperSlab(_) => None,
            Blocks::ExposedCutCopperSlab(_) => None,
            Blocks::CutCopperSlab(_) => None,
            Blocks::WaxedCopperBlock => None,
            Blocks::WaxedWeatheredCopper => None,
            Blocks::WaxedExposedCopper => None,
            Blocks::WaxedOxidizedCopper => None,
            Blocks::WaxedOxidizedCutCopper => None,
            Blocks::WaxedWeatheredCutCopper => None,
            Blocks::WaxedExposedCutCopper => None,
            Blocks::WaxedCutCopper => None,
            Blocks::WaxedOxidizedCutCopperStairs(_) => None,
            Blocks::WaxedWeatheredCutCopperStairs(_) => None,
            Blocks::WaxedExposedCutCopperStairs(_) => None,
            Blocks::WaxedCutCopperStairs(_) => None,
            Blocks::WaxedOxidizedCutCopperSlab(_) => None,
            Blocks::WaxedWeatheredCutCopperSlab(_) => None,
            Blocks::WaxedExposedCutCopperSlab(_) => None,
            Blocks::WaxedCutCopperSlab(_) => None,
            Blocks::LightningRod(_) => None,
            Blocks::PointedDripstone(_) => None,
            Blocks::DripstoneBlock => None,
            Blocks::CaveVines(_) => None,
            Blocks::CaveVinesPlant(_) => None,
            Blocks::SporeBlossom => None,
            Blocks::Azalea => None,
            Blocks::FloweringAzalea => None,
            Blocks::MossCarpet => None,
            Blocks::MossBlock => None,
            Blocks::BigDripleaf(_) => None,
            Blocks::BigDripleafStem(_) => None,
            Blocks::SmallDripleaf(_) => None,
            Blocks::HangingRoots(_) => None,
            Blocks::RootedDirt => None,
            Blocks::Deepslate(_) => None,
            Blocks::CobbledDeepslate => None,
            Blocks::CobbledDeepslateStairs(_) => None,
            Blocks::CobbledDeepslateSlab(_) => None,
            Blocks::CobbledDeepslateWall(_) => None,
            Blocks::PolishedDeepslate => None,
            Blocks::PolishedDeepslateStairs(_) => None,
            Blocks::PolishedDeepslateSlab(_) => None,
            Blocks::PolishedDeepslateWall(_) => None,
            Blocks::DeepslateTiles => None,
            Blocks::DeepslateTileStairs(_) => None,
            Blocks::DeepslateTileSlab(_) => None,
            Blocks::DeepslateTileWall(_) => None,
            Blocks::DeepslateBricks => None,
            Blocks::DeepslateBrickStairs(_) => None,
            Blocks::DeepslateBrickSlab(_) => None,
            Blocks::DeepslateBrickWall(_) => None,
            Blocks::ChiseledDeepslate => None,
            Blocks::CrackedDeepslateBricks => None,
            Blocks::CrackedDeepslateTiles => None,
            Blocks::InfestedDeepslate(_) => None,
            Blocks::SmoothBasalt => None,
            Blocks::RawIronBlock => None,
            Blocks::RawCopperBlock => None,
            Blocks::RawGoldBlock => None,
            Blocks::PottedAzaleaBush => None,
            Blocks::PottedFloweringAzaleaBush => None,
        }
    }
    pub fn get_global_id_2567(&self) -> Option<i32> {
        match self {
            Blocks::Air => Some(0),
            Blocks::Stone => Some(1),
            Blocks::Granite => Some(2),
            Blocks::PolishedGranite => Some(3),
            Blocks::Diorite => Some(4),
            Blocks::PolishedDiorite => Some(5),
            Blocks::Andesite => Some(6),
            Blocks::PolishedAndesite => Some(7),
            Blocks::GrassBlock(state) => {
                Some(8 + (!state.snowy() as i32))
            }
            Blocks::Dirt => Some(10),
            Blocks::CoarseDirt => Some(11),
            Blocks::Podzol(state) => {
                Some(12 + (!state.snowy() as i32))
            }
            Blocks::Cobblestone => Some(14),
            Blocks::OakPlanks => Some(15),
            Blocks::SprucePlanks => Some(16),
            Blocks::BirchPlanks => Some(17),
            Blocks::JunglePlanks => Some(18),
            Blocks::AcaciaPlanks => Some(19),
            Blocks::DarkOakPlanks => Some(20),
            Blocks::OakSapling(state) => {
                Some(21 + state.stage)
            }
            Blocks::SpruceSapling(state) => {
                Some(23 + state.stage)
            }
            Blocks::BirchSapling(state) => {
                Some(25 + state.stage)
            }
            Blocks::JungleSapling(state) => {
                Some(27 + state.stage)
            }
            Blocks::AcaciaSapling(state) => {
                Some(29 + state.stage)
            }
            Blocks::DarkOakSapling(state) => {
                Some(31 + state.stage)
            }
            Blocks::Bedrock => Some(33),
            Blocks::Water(state) => {
                Some(34 + state.level)
            }
            Blocks::Lava(state) => {
                Some(50 + state.level)
            }
            Blocks::Sand => Some(66),
            Blocks::RedSand => Some(67),
            Blocks::Gravel => Some(68),
            Blocks::GoldOre => Some(69),
            Blocks::DeepslateGoldOre => None,
            Blocks::IronOre => Some(70),
            Blocks::DeepslateIronOre => None,
            Blocks::CoalOre => Some(71),
            Blocks::DeepslateCoalOre => None,
            Blocks::NetherGoldOre => Some(72),
            Blocks::OakLog(state) => {
                Some(73 + (state.axis as i32))
            }
            Blocks::SpruceLog(state) => {
                Some(76 + (state.axis as i32))
            }
            Blocks::BirchLog(state) => {
                Some(79 + (state.axis as i32))
            }
            Blocks::JungleLog(state) => {
                Some(82 + (state.axis as i32))
            }
            Blocks::AcaciaLog(state) => {
                Some(85 + (state.axis as i32))
            }
            Blocks::DarkOakLog(state) => {
                Some(88 + (state.axis as i32))
            }
            Blocks::StrippedSpruceLog(state) => {
                Some(91 + (state.axis as i32))
            }
            Blocks::StrippedBirchLog(state) => {
                Some(94 + (state.axis as i32))
            }
            Blocks::StrippedJungleLog(state) => {
                Some(97 + (state.axis as i32))
            }
            Blocks::StrippedAcaciaLog(state) => {
                Some(100 + (state.axis as i32))
            }
            Blocks::StrippedDarkOakLog(state) => {
                Some(103 + (state.axis as i32))
            }
            Blocks::StrippedOakLog(state) => {
                Some(106 + (state.axis as i32))
            }
            Blocks::OakWood(state) => {
                Some(109 + (state.axis as i32))
            }
            Blocks::SpruceWood(state) => {
                Some(112 + (state.axis as i32))
            }
            Blocks::BirchWood(state) => {
                Some(115 + (state.axis as i32))
            }
            Blocks::JungleWood(state) => {
                Some(118 + (state.axis as i32))
            }
            Blocks::AcaciaWood(state) => {
                Some(121 + (state.axis as i32))
            }
            Blocks::DarkOakWood(state) => {
                Some(124 + (state.axis as i32))
            }
            Blocks::StrippedOakWood(state) => {
                Some(127 + (state.axis as i32))
            }
            Blocks::StrippedSpruceWood(state) => {
                Some(130 + (state.axis as i32))
            }
            Blocks::StrippedBirchWood(state) => {
                Some(133 + (state.axis as i32))
            }
            Blocks::StrippedJungleWood(state) => {
                Some(136 + (state.axis as i32))
            }
            Blocks::StrippedAcaciaWood(state) => {
                Some(139 + (state.axis as i32))
            }
            Blocks::StrippedDarkOakWood(state) => {
                Some(142 + (state.axis as i32))
            }
            Blocks::OakLeaves(state) => {
                Some(145 + (!state.persistent() as i32) + 2 * state.distance)
            }
            Blocks::SpruceLeaves(state) => {
                Some(159 + (!state.persistent() as i32) + 2 * state.distance)
            }
            Blocks::BirchLeaves(state) => {
                Some(173 + (!state.persistent() as i32) + 2 * state.distance)
            }
            Blocks::JungleLeaves(state) => {
                Some(187 + (!state.persistent() as i32) + 2 * state.distance)
            }
            Blocks::AcaciaLeaves(state) => {
                Some(201 + (!state.persistent() as i32) + 2 * state.distance)
            }
            Blocks::DarkOakLeaves(state) => {
                Some(215 + (!state.persistent() as i32) + 2 * state.distance)
            }
            Blocks::AzaleaLeaves(_) => None,
            Blocks::FloweringAzaleaLeaves(_) => None,
            Blocks::Sponge => Some(229),
            Blocks::WetSponge => Some(230),
            Blocks::Glass => Some(231),
            Blocks::LapisOre => Some(232),
            Blocks::DeepslateLapisOre => None,
            Blocks::LapisBlock => Some(233),
            Blocks::Dispenser(state) => {
                Some(234 + (!state.triggered() as i32) + 2 * (state.facing as i32))
            }
            Blocks::Sandstone => Some(246),
            Blocks::ChiseledSandstone => Some(247),
            Blocks::CutSandstone => Some(248),
            Blocks::NoteBlock(state) => {
                Some(249 + (!state.powered() as i32) + 2 * state.note + 50 * (state.instrument as i32))
            }
            Blocks::WhiteBed(state) => {
                Some(1049 + (state.part as i32) + 2 * (!state.occupied() as i32) + 4 * (state.facing as i32))
            }
            Blocks::OrangeBed(state) => {
                Some(1065 + (state.part as i32) + 2 * (!state.occupied() as i32) + 4 * (state.facing as i32))
            }
            Blocks::MagentaBed(state) => {
                Some(1081 + (state.part as i32) + 2 * (!state.occupied() as i32) + 4 * (state.facing as i32))
            }
            Blocks::LightBlueBed(state) => {
                Some(1097 + (state.part as i32) + 2 * (!state.occupied() as i32) + 4 * (state.facing as i32))
            }
            Blocks::YellowBed(state) => {
                Some(1113 + (state.part as i32) + 2 * (!state.occupied() as i32) + 4 * (state.facing as i32))
            }
            Blocks::LimeBed(state) => {
                Some(1129 + (state.part as i32) + 2 * (!state.occupied() as i32) + 4 * (state.facing as i32))
            }
            Blocks::PinkBed(state) => {
                Some(1145 + (state.part as i32) + 2 * (!state.occupied() as i32) + 4 * (state.facing as i32))
            }
            Blocks::GrayBed(state) => {
                Some(1161 + (state.part as i32) + 2 * (!state.occupied() as i32) + 4 * (state.facing as i32))
            }
            Blocks::LightGrayBed(state) => {
                Some(1177 + (state.part as i32) + 2 * (!state.occupied() as i32) + 4 * (state.facing as i32))
            }
            Blocks::CyanBed(state) => {
                Some(1193 + (state.part as i32) + 2 * (!state.occupied() as i32) + 4 * (state.facing as i32))
            }
            Blocks::PurpleBed(state) => {
                Some(1209 + (state.part as i32) + 2 * (!state.occupied() as i32) + 4 * (state.facing as i32))
            }
            Blocks::BlueBed(state) => {
                Some(1225 + (state.part as i32) + 2 * (!state.occupied() as i32) + 4 * (state.facing as i32))
            }
            Blocks::BrownBed(state) => {
                Some(1241 + (state.part as i32) + 2 * (!state.occupied() as i32) + 4 * (state.facing as i32))
            }
            Blocks::GreenBed(state) => {
                Some(1257 + (state.part as i32) + 2 * (!state.occupied() as i32) + 4 * (state.facing as i32))
            }
            Blocks::RedBed(state) => {
                Some(1273 + (state.part as i32) + 2 * (!state.occupied() as i32) + 4 * (state.facing as i32))
            }
            Blocks::BlackBed(state) => {
                Some(1289 + (state.part as i32) + 2 * (!state.occupied() as i32) + 4 * (state.facing as i32))
            }
            Blocks::PoweredRail(state) => {
                Some(1305 + (state.shape as i32) + 6 * (!state.powered() as i32))
            }
            Blocks::DetectorRail(state) => {
                Some(1317 + (state.shape as i32) + 6 * (!state.powered() as i32))
            }
            Blocks::StickyPiston(state) => {
                Some(1329 + (state.facing as i32) + 6 * (!state.extended() as i32))
            }
            Blocks::Cobweb => Some(1341),
            Blocks::Grass => Some(1342),
            Blocks::Fern => Some(1343),
            Blocks::DeadBush => Some(1344),
            Blocks::Seagrass => Some(1345),
            Blocks::TallSeagrass(state) => {
                Some(1346 + (state.half as i32))
            }
            Blocks::Piston(state) => {
                Some(1348 + (state.facing as i32) + 6 * (!state.extended() as i32))
            }
            Blocks::PistonHead(state) => {
                Some(1360 + (state.typed as i32) + 2 * (!state.short() as i32) + 4 * (state.facing as i32))
            }
            Blocks::WhiteWool => Some(1384),
            Blocks::OrangeWool => Some(1385),
            Blocks::MagentaWool => Some(1386),
            Blocks::LightBlueWool => Some(1387),
            Blocks::YellowWool => Some(1388),
            Blocks::LimeWool => Some(1389),
            Blocks::PinkWool => Some(1390),
            Blocks::GrayWool => Some(1391),
            Blocks::LightGrayWool => Some(1392),
            Blocks::CyanWool => Some(1393),
            Blocks::PurpleWool => Some(1394),
            Blocks::BlueWool => Some(1395),
            Blocks::BrownWool => Some(1396),
            Blocks::GreenWool => Some(1397),
            Blocks::RedWool => Some(1398),
            Blocks::BlackWool => Some(1399),
            Blocks::MovingPiston(state) => {
                Some(1400 + (state.typed as i32) + 2 * (state.facing as i32))
            }
            Blocks::Dandelion => Some(1412),
            Blocks::Poppy => Some(1413),
            Blocks::BlueOrchid => Some(1414),
            Blocks::Allium => Some(1415),
            Blocks::AzureBluet => Some(1416),
            Blocks::RedTulip => Some(1417),
            Blocks::OrangeTulip => Some(1418),
            Blocks::WhiteTulip => Some(1419),
            Blocks::PinkTulip => Some(1420),
            Blocks::OxeyeDaisy => Some(1421),
            Blocks::Cornflower => Some(1422),
            Blocks::WitherRose => Some(1423),
            Blocks::LilyOfTheValley => Some(1424),
            Blocks::BrownMushroom => Some(1425),
            Blocks::RedMushroom => Some(1426),
            Blocks::GoldBlock => Some(1427),
            Blocks::IronBlock => Some(1428),
            Blocks::Bricks => Some(1429),
            Blocks::Tnt(state) => {
                Some(1430 + (!state.unstable() as i32))
            }
            Blocks::Bookshelf => Some(1432),
            Blocks::MossyCobblestone => Some(1433),
            Blocks::Obsidian => Some(1434),
            Blocks::Torch => Some(1435),
            Blocks::WallTorch(state) => {
                Some(1436 + (state.facing as i32))
            }
            Blocks::Fire(state) => {
                Some(1440 + (!state.west() as i32) + 2 * (!state.up() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32) + 32 * state.age)
            }
            Blocks::SoulFire => Some(1952),
            Blocks::Spawner => Some(1953),
            Blocks::OakStairs(state) => {
                Some(1954 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::Chest(state) => {
                Some(2034 + (!state.waterlogged() as i32) + 2 * (state.typed as i32) + 6 * (state.facing as i32))
            }
            Blocks::RedstoneWire(state) => {
                Some(2058 + (state.west as i32) + 3 * (state.south as i32) + 9 * state.power + 144 * (state.north as i32) + 432 * (state.east as i32))
            }
            Blocks::DiamondOre => Some(3354),
            Blocks::DeepslateDiamondOre => None,
            Blocks::DiamondBlock => Some(3355),
            Blocks::CraftingTable => Some(3356),
            Blocks::Wheat(state) => {
                Some(3357 + state.age)
            }
            Blocks::Farmland(state) => {
                Some(3365 + state.moisture)
            }
            Blocks::Furnace(state) => {
                Some(3373 + (!state.lit() as i32) + 2 * (state.facing as i32))
            }
            Blocks::OakSign(state) => {
                Some(3381 + (!state.waterlogged() as i32) + 2 * state.rotation)
            }
            Blocks::SpruceSign(state) => {
                Some(3413 + (!state.waterlogged() as i32) + 2 * state.rotation)
            }
            Blocks::BirchSign(state) => {
                Some(3445 + (!state.waterlogged() as i32) + 2 * state.rotation)
            }
            Blocks::AcaciaSign(state) => {
                Some(3477 + (!state.waterlogged() as i32) + 2 * state.rotation)
            }
            Blocks::JungleSign(state) => {
                Some(3509 + (!state.waterlogged() as i32) + 2 * state.rotation)
            }
            Blocks::DarkOakSign(state) => {
                Some(3541 + (!state.waterlogged() as i32) + 2 * state.rotation)
            }
            Blocks::OakDoor(state) => {
                Some(3573 + (!state.powered() as i32) + 2 * (!state.open() as i32) + 4 * (state.hinge as i32) + 8 * (state.half as i32) + 16 * (state.facing as i32))
            }
            Blocks::Ladder(state) => {
                Some(3637 + (!state.waterlogged() as i32) + 2 * (state.facing as i32))
            }
            Blocks::Rail(state) => {
                Some(3645 + (state.shape as i32))
            }
            Blocks::CobblestoneStairs(state) => {
                Some(3655 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::OakWallSign(state) => {
                Some(3735 + (!state.waterlogged() as i32) + 2 * (state.facing as i32))
            }
            Blocks::SpruceWallSign(state) => {
                Some(3743 + (!state.waterlogged() as i32) + 2 * (state.facing as i32))
            }
            Blocks::BirchWallSign(state) => {
                Some(3751 + (!state.waterlogged() as i32) + 2 * (state.facing as i32))
            }
            Blocks::AcaciaWallSign(state) => {
                Some(3759 + (!state.waterlogged() as i32) + 2 * (state.facing as i32))
            }
            Blocks::JungleWallSign(state) => {
                Some(3767 + (!state.waterlogged() as i32) + 2 * (state.facing as i32))
            }
            Blocks::DarkOakWallSign(state) => {
                Some(3775 + (!state.waterlogged() as i32) + 2 * (state.facing as i32))
            }
            Blocks::Lever(state) => {
                Some(3783 + (!state.powered() as i32) + 2 * (state.facing as i32) + 8 * (state.face as i32))
            }
            Blocks::StonePressurePlate(state) => {
                Some(3807 + (!state.powered() as i32))
            }
            Blocks::IronDoor(state) => {
                Some(3809 + (!state.powered() as i32) + 2 * (!state.open() as i32) + 4 * (state.hinge as i32) + 8 * (state.half as i32) + 16 * (state.facing as i32))
            }
            Blocks::OakPressurePlate(state) => {
                Some(3873 + (!state.powered() as i32))
            }
            Blocks::SprucePressurePlate(state) => {
                Some(3875 + (!state.powered() as i32))
            }
            Blocks::BirchPressurePlate(state) => {
                Some(3877 + (!state.powered() as i32))
            }
            Blocks::JunglePressurePlate(state) => {
                Some(3879 + (!state.powered() as i32))
            }
            Blocks::AcaciaPressurePlate(state) => {
                Some(3881 + (!state.powered() as i32))
            }
            Blocks::DarkOakPressurePlate(state) => {
                Some(3883 + (!state.powered() as i32))
            }
            Blocks::RedstoneOre(state) => {
                Some(3885 + (!state.lit() as i32))
            }
            Blocks::DeepslateRedstoneOre(_) => None,
            Blocks::RedstoneTorch(state) => {
                Some(3887 + (!state.lit() as i32))
            }
            Blocks::RedstoneWallTorch(state) => {
                Some(3889 + (!state.lit() as i32) + 2 * (state.facing as i32))
            }
            Blocks::StoneButton(state) => {
                Some(3897 + (!state.powered() as i32) + 2 * (state.facing as i32) + 8 * (state.face as i32))
            }
            Blocks::Snow(state) => {
                Some(3921 + state.layers)
            }
            Blocks::Ice => Some(3929),
            Blocks::SnowBlock => Some(3930),
            Blocks::Cactus(state) => {
                Some(3931 + state.age)
            }
            Blocks::Clay => Some(3947),
            Blocks::SugarCane(state) => {
                Some(3948 + state.age)
            }
            Blocks::Jukebox(state) => {
                Some(3964 + (!state.has_record() as i32))
            }
            Blocks::OakFence(state) => {
                Some(3966 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::Pumpkin => Some(3998),
            Blocks::Netherrack => Some(3999),
            Blocks::SoulSand => Some(4000),
            Blocks::SoulSoil => Some(4001),
            Blocks::Basalt(state) => {
                Some(4002 + (state.axis as i32))
            }
            Blocks::PolishedBasalt(state) => {
                Some(4005 + (state.axis as i32))
            }
            Blocks::SoulTorch => Some(4008),
            Blocks::SoulWallTorch(state) => {
                Some(4009 + (state.facing as i32))
            }
            Blocks::Glowstone => Some(4013),
            Blocks::NetherPortal(state) => {
                Some(4014 + (state.axis as i32))
            }
            Blocks::CarvedPumpkin(state) => {
                Some(4016 + (state.facing as i32))
            }
            Blocks::JackOLantern(state) => {
                Some(4020 + (state.facing as i32))
            }
            Blocks::Cake(state) => {
                Some(4024 + state.bites)
            }
            Blocks::Repeater(state) => {
                Some(4031 + (!state.powered() as i32) + 2 * (!state.locked() as i32) + 4 * (state.facing as i32) + 16 * state.delay)
            }
            Blocks::WhiteStainedGlass => Some(4095),
            Blocks::OrangeStainedGlass => Some(4096),
            Blocks::MagentaStainedGlass => Some(4097),
            Blocks::LightBlueStainedGlass => Some(4098),
            Blocks::YellowStainedGlass => Some(4099),
            Blocks::LimeStainedGlass => Some(4100),
            Blocks::PinkStainedGlass => Some(4101),
            Blocks::GrayStainedGlass => Some(4102),
            Blocks::LightGrayStainedGlass => Some(4103),
            Blocks::CyanStainedGlass => Some(4104),
            Blocks::PurpleStainedGlass => Some(4105),
            Blocks::BlueStainedGlass => Some(4106),
            Blocks::BrownStainedGlass => Some(4107),
            Blocks::GreenStainedGlass => Some(4108),
            Blocks::RedStainedGlass => Some(4109),
            Blocks::BlackStainedGlass => Some(4110),
            Blocks::OakTrapdoor(state) => {
                Some(4111 + (!state.waterlogged() as i32) + 2 * (!state.powered() as i32) + 4 * (!state.open() as i32) + 8 * (state.half as i32) + 16 * (state.facing as i32))
            }
            Blocks::SpruceTrapdoor(state) => {
                Some(4175 + (!state.waterlogged() as i32) + 2 * (!state.powered() as i32) + 4 * (!state.open() as i32) + 8 * (state.half as i32) + 16 * (state.facing as i32))
            }
            Blocks::BirchTrapdoor(state) => {
                Some(4239 + (!state.waterlogged() as i32) + 2 * (!state.powered() as i32) + 4 * (!state.open() as i32) + 8 * (state.half as i32) + 16 * (state.facing as i32))
            }
            Blocks::JungleTrapdoor(state) => {
                Some(4303 + (!state.waterlogged() as i32) + 2 * (!state.powered() as i32) + 4 * (!state.open() as i32) + 8 * (state.half as i32) + 16 * (state.facing as i32))
            }
            Blocks::AcaciaTrapdoor(state) => {
                Some(4367 + (!state.waterlogged() as i32) + 2 * (!state.powered() as i32) + 4 * (!state.open() as i32) + 8 * (state.half as i32) + 16 * (state.facing as i32))
            }
            Blocks::DarkOakTrapdoor(state) => {
                Some(4431 + (!state.waterlogged() as i32) + 2 * (!state.powered() as i32) + 4 * (!state.open() as i32) + 8 * (state.half as i32) + 16 * (state.facing as i32))
            }
            Blocks::StoneBricks => Some(4495),
            Blocks::MossyStoneBricks => Some(4496),
            Blocks::CrackedStoneBricks => Some(4497),
            Blocks::ChiseledStoneBricks => Some(4498),
            Blocks::InfestedStone => Some(4499),
            Blocks::InfestedCobblestone => Some(4500),
            Blocks::InfestedStoneBricks => Some(4501),
            Blocks::InfestedMossyStoneBricks => Some(4502),
            Blocks::InfestedCrackedStoneBricks => Some(4503),
            Blocks::InfestedChiseledStoneBricks => Some(4504),
            Blocks::BrownMushroomBlock(state) => {
                Some(4505 + (!state.west() as i32) + 2 * (!state.up() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32) + 32 * (!state.down() as i32))
            }
            Blocks::RedMushroomBlock(state) => {
                Some(4569 + (!state.west() as i32) + 2 * (!state.up() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32) + 32 * (!state.down() as i32))
            }
            Blocks::MushroomStem(state) => {
                Some(4633 + (!state.west() as i32) + 2 * (!state.up() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32) + 32 * (!state.down() as i32))
            }
            Blocks::IronBars(state) => {
                Some(4697 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::Chain(state) => {
                Some(4729 + (!state.waterlogged() as i32))
            }
            Blocks::GlassPane(state) => {
                Some(4731 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::Melon => Some(4763),
            Blocks::AttachedPumpkinStem(state) => {
                Some(4764 + (state.facing as i32))
            }
            Blocks::AttachedMelonStem(state) => {
                Some(4768 + (state.facing as i32))
            }
            Blocks::PumpkinStem(state) => {
                Some(4772 + state.age)
            }
            Blocks::MelonStem(state) => {
                Some(4780 + state.age)
            }
            Blocks::Vine(state) => {
                Some(4788 + (!state.west() as i32) + 2 * (!state.up() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::GlowLichen(_) => None,
            Blocks::OakFenceGate(state) => {
                Some(4820 + (!state.powered() as i32) + 2 * (!state.open() as i32) + 4 * (!state.in_wall() as i32) + 8 * (state.facing as i32))
            }
            Blocks::BrickStairs(state) => {
                Some(4852 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::StoneBrickStairs(state) => {
                Some(4932 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::Mycelium(state) => {
                Some(5012 + (!state.snowy() as i32))
            }
            Blocks::LilyPad => Some(5014),
            Blocks::NetherBricks => Some(5015),
            Blocks::NetherBrickFence(state) => {
                Some(5016 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::NetherBrickStairs(state) => {
                Some(5048 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::NetherWart(state) => {
                Some(5128 + state.age)
            }
            Blocks::EnchantingTable => Some(5132),
            Blocks::BrewingStand(state) => {
                Some(5133 + (!state.has_bottle_2() as i32) + 2 * (!state.has_bottle_1() as i32) + 4 * (!state.has_bottle_0() as i32))
            }
            Blocks::Cauldron => Some(5141),
            Blocks::WaterCauldron(state) => {
                Some(5142 + state.level)
            }
            Blocks::LavaCauldron => None,
            Blocks::PowderSnowCauldron(_) => None,
            Blocks::EndPortal => Some(5145),
            Blocks::EndPortalFrame(state) => {
                Some(5146 + (state.facing as i32) + 4 * (!state.eye() as i32))
            }
            Blocks::EndStone => Some(5154),
            Blocks::DragonEgg => Some(5155),
            Blocks::RedstoneLamp(state) => {
                Some(5156 + (!state.lit() as i32))
            }
            Blocks::Cocoa(state) => {
                Some(5158 + (state.facing as i32) + 4 * state.age)
            }
            Blocks::SandstoneStairs(state) => {
                Some(5170 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::EmeraldOre => Some(5250),
            Blocks::DeepslateEmeraldOre => None,
            Blocks::EnderChest(state) => {
                Some(5251 + (!state.waterlogged() as i32) + 2 * (state.facing as i32))
            }
            Blocks::TripwireHook(state) => {
                Some(5259 + (!state.powered() as i32) + 2 * (state.facing as i32) + 8 * (!state.attached() as i32))
            }
            Blocks::Tripwire(state) => {
                Some(5275 + (!state.west() as i32) + 2 * (!state.south() as i32) + 4 * (!state.powered() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32) + 32 * (!state.disarmed() as i32) + 64 * (!state.attached() as i32))
            }
            Blocks::EmeraldBlock => Some(5403),
            Blocks::SpruceStairs(state) => {
                Some(5404 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::BirchStairs(state) => {
                Some(5484 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::JungleStairs(state) => {
                Some(5564 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::CommandBlock(state) => {
                Some(5644 + (state.facing as i32) + 6 * (!state.conditional() as i32))
            }
            Blocks::Beacon => Some(5656),
            Blocks::CobblestoneWall(state) => {
                Some(5657 + (state.west as i32) + 3 * (!state.waterlogged() as i32) + 6 * (!state.up() as i32) + 12 * (state.south as i32) + 36 * (state.north as i32) + 108 * (state.east as i32))
            }
            Blocks::MossyCobblestoneWall(state) => {
                Some(5981 + (state.west as i32) + 3 * (!state.waterlogged() as i32) + 6 * (!state.up() as i32) + 12 * (state.south as i32) + 36 * (state.north as i32) + 108 * (state.east as i32))
            }
            Blocks::FlowerPot => Some(6305),
            Blocks::PottedOakSapling => Some(6306),
            Blocks::PottedSpruceSapling => Some(6307),
            Blocks::PottedBirchSapling => Some(6308),
            Blocks::PottedJungleSapling => Some(6309),
            Blocks::PottedAcaciaSapling => Some(6310),
            Blocks::PottedDarkOakSapling => Some(6311),
            Blocks::PottedFern => Some(6312),
            Blocks::PottedDandelion => Some(6313),
            Blocks::PottedPoppy => Some(6314),
            Blocks::PottedBlueOrchid => Some(6315),
            Blocks::PottedAllium => Some(6316),
            Blocks::PottedAzureBluet => Some(6317),
            Blocks::PottedRedTulip => Some(6318),
            Blocks::PottedOrangeTulip => Some(6319),
            Blocks::PottedWhiteTulip => Some(6320),
            Blocks::PottedPinkTulip => Some(6321),
            Blocks::PottedOxeyeDaisy => Some(6322),
            Blocks::PottedCornflower => Some(6323),
            Blocks::PottedLilyOfTheValley => Some(6324),
            Blocks::PottedWitherRose => Some(6325),
            Blocks::PottedRedMushroom => Some(6326),
            Blocks::PottedBrownMushroom => Some(6327),
            Blocks::PottedDeadBush => Some(6328),
            Blocks::PottedCactus => Some(6329),
            Blocks::Carrots(state) => {
                Some(6330 + state.age)
            }
            Blocks::Potatoes(state) => {
                Some(6338 + state.age)
            }
            Blocks::OakButton(state) => {
                Some(6346 + (!state.powered() as i32) + 2 * (state.facing as i32) + 8 * (state.face as i32))
            }
            Blocks::SpruceButton(state) => {
                Some(6370 + (!state.powered() as i32) + 2 * (state.facing as i32) + 8 * (state.face as i32))
            }
            Blocks::BirchButton(state) => {
                Some(6394 + (!state.powered() as i32) + 2 * (state.facing as i32) + 8 * (state.face as i32))
            }
            Blocks::JungleButton(state) => {
                Some(6418 + (!state.powered() as i32) + 2 * (state.facing as i32) + 8 * (state.face as i32))
            }
            Blocks::AcaciaButton(state) => {
                Some(6442 + (!state.powered() as i32) + 2 * (state.facing as i32) + 8 * (state.face as i32))
            }
            Blocks::DarkOakButton(state) => {
                Some(6466 + (!state.powered() as i32) + 2 * (state.facing as i32) + 8 * (state.face as i32))
            }
            Blocks::SkeletonSkull(state) => {
                Some(6490 + state.rotation)
            }
            Blocks::SkeletonWallSkull(state) => {
                Some(6506 + (state.facing as i32))
            }
            Blocks::WitherSkeletonSkull(state) => {
                Some(6510 + state.rotation)
            }
            Blocks::WitherSkeletonWallSkull(state) => {
                Some(6526 + (state.facing as i32))
            }
            Blocks::ZombieHead(state) => {
                Some(6530 + state.rotation)
            }
            Blocks::ZombieWallHead(state) => {
                Some(6546 + (state.facing as i32))
            }
            Blocks::PlayerHead(state) => {
                Some(6550 + state.rotation)
            }
            Blocks::PlayerWallHead(state) => {
                Some(6566 + (state.facing as i32))
            }
            Blocks::CreeperHead(state) => {
                Some(6570 + state.rotation)
            }
            Blocks::CreeperWallHead(state) => {
                Some(6586 + (state.facing as i32))
            }
            Blocks::DragonHead(state) => {
                Some(6590 + state.rotation)
            }
            Blocks::DragonWallHead(state) => {
                Some(6606 + (state.facing as i32))
            }
            Blocks::Anvil(state) => {
                Some(6610 + (state.facing as i32))
            }
            Blocks::ChippedAnvil(state) => {
                Some(6614 + (state.facing as i32))
            }
            Blocks::DamagedAnvil(state) => {
                Some(6618 + (state.facing as i32))
            }
            Blocks::TrappedChest(state) => {
                Some(6622 + (!state.waterlogged() as i32) + 2 * (state.typed as i32) + 6 * (state.facing as i32))
            }
            Blocks::LightWeightedPressurePlate(state) => {
                Some(6646 + state.power)
            }
            Blocks::HeavyWeightedPressurePlate(state) => {
                Some(6662 + state.power)
            }
            Blocks::Comparator(state) => {
                Some(6678 + (!state.powered() as i32) + 2 * (state.mode as i32) + 4 * (state.facing as i32))
            }
            Blocks::DaylightDetector(state) => {
                Some(6694 + state.power + 16 * (!state.inverted() as i32))
            }
            Blocks::RedstoneBlock => Some(6726),
            Blocks::NetherQuartzOre => Some(6727),
            Blocks::Hopper(state) => {
                Some(6728 + (state.facing as i32) + 5 * (!state.enabled() as i32))
            }
            Blocks::QuartzBlock => Some(6738),
            Blocks::ChiseledQuartzBlock => Some(6739),
            Blocks::QuartzPillar(state) => {
                Some(6740 + (state.axis as i32))
            }
            Blocks::QuartzStairs(state) => {
                Some(6743 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::ActivatorRail(state) => {
                Some(6823 + (state.shape as i32) + 6 * (!state.powered() as i32))
            }
            Blocks::Dropper(state) => {
                Some(6835 + (!state.triggered() as i32) + 2 * (state.facing as i32))
            }
            Blocks::WhiteTerracotta => Some(6847),
            Blocks::OrangeTerracotta => Some(6848),
            Blocks::MagentaTerracotta => Some(6849),
            Blocks::LightBlueTerracotta => Some(6850),
            Blocks::YellowTerracotta => Some(6851),
            Blocks::LimeTerracotta => Some(6852),
            Blocks::PinkTerracotta => Some(6853),
            Blocks::GrayTerracotta => Some(6854),
            Blocks::LightGrayTerracotta => Some(6855),
            Blocks::CyanTerracotta => Some(6856),
            Blocks::PurpleTerracotta => Some(6857),
            Blocks::BlueTerracotta => Some(6858),
            Blocks::BrownTerracotta => Some(6859),
            Blocks::GreenTerracotta => Some(6860),
            Blocks::RedTerracotta => Some(6861),
            Blocks::BlackTerracotta => Some(6862),
            Blocks::WhiteStainedGlassPane(state) => {
                Some(6863 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::OrangeStainedGlassPane(state) => {
                Some(6895 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::MagentaStainedGlassPane(state) => {
                Some(6927 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::LightBlueStainedGlassPane(state) => {
                Some(6959 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::YellowStainedGlassPane(state) => {
                Some(6991 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::LimeStainedGlassPane(state) => {
                Some(7023 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::PinkStainedGlassPane(state) => {
                Some(7055 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::GrayStainedGlassPane(state) => {
                Some(7087 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::LightGrayStainedGlassPane(state) => {
                Some(7119 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::CyanStainedGlassPane(state) => {
                Some(7151 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::PurpleStainedGlassPane(state) => {
                Some(7183 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::BlueStainedGlassPane(state) => {
                Some(7215 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::BrownStainedGlassPane(state) => {
                Some(7247 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::GreenStainedGlassPane(state) => {
                Some(7279 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::RedStainedGlassPane(state) => {
                Some(7311 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::BlackStainedGlassPane(state) => {
                Some(7343 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::AcaciaStairs(state) => {
                Some(7375 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::DarkOakStairs(state) => {
                Some(7455 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::SlimeBlock => Some(7535),
            Blocks::Barrier => Some(7536),
            Blocks::Light(_) => None,
            Blocks::IronTrapdoor(state) => {
                Some(7537 + (!state.waterlogged() as i32) + 2 * (!state.powered() as i32) + 4 * (!state.open() as i32) + 8 * (state.half as i32) + 16 * (state.facing as i32))
            }
            Blocks::Prismarine => Some(7601),
            Blocks::PrismarineBricks => Some(7602),
            Blocks::DarkPrismarine => Some(7603),
            Blocks::PrismarineStairs(state) => {
                Some(7604 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::PrismarineBrickStairs(state) => {
                Some(7684 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::DarkPrismarineStairs(state) => {
                Some(7764 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::PrismarineSlab(state) => {
                Some(7844 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::PrismarineBrickSlab(state) => {
                Some(7850 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::DarkPrismarineSlab(state) => {
                Some(7856 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::SeaLantern => Some(7862),
            Blocks::HayBlock(state) => {
                Some(7863 + (state.axis as i32))
            }
            Blocks::WhiteCarpet => Some(7866),
            Blocks::OrangeCarpet => Some(7867),
            Blocks::MagentaCarpet => Some(7868),
            Blocks::LightBlueCarpet => Some(7869),
            Blocks::YellowCarpet => Some(7870),
            Blocks::LimeCarpet => Some(7871),
            Blocks::PinkCarpet => Some(7872),
            Blocks::GrayCarpet => Some(7873),
            Blocks::LightGrayCarpet => Some(7874),
            Blocks::CyanCarpet => Some(7875),
            Blocks::PurpleCarpet => Some(7876),
            Blocks::BlueCarpet => Some(7877),
            Blocks::BrownCarpet => Some(7878),
            Blocks::GreenCarpet => Some(7879),
            Blocks::RedCarpet => Some(7880),
            Blocks::BlackCarpet => Some(7881),
            Blocks::Terracotta => Some(7882),
            Blocks::CoalBlock => Some(7883),
            Blocks::PackedIce => Some(7884),
            Blocks::Sunflower(state) => {
                Some(7885 + (state.half as i32))
            }
            Blocks::Lilac(state) => {
                Some(7887 + (state.half as i32))
            }
            Blocks::RoseBush(state) => {
                Some(7889 + (state.half as i32))
            }
            Blocks::Peony(state) => {
                Some(7891 + (state.half as i32))
            }
            Blocks::TallGrass(state) => {
                Some(7893 + (state.half as i32))
            }
            Blocks::LargeFern(state) => {
                Some(7895 + (state.half as i32))
            }
            Blocks::WhiteBanner(state) => {
                Some(7897 + state.rotation)
            }
            Blocks::OrangeBanner(state) => {
                Some(7913 + state.rotation)
            }
            Blocks::MagentaBanner(state) => {
                Some(7929 + state.rotation)
            }
            Blocks::LightBlueBanner(state) => {
                Some(7945 + state.rotation)
            }
            Blocks::YellowBanner(state) => {
                Some(7961 + state.rotation)
            }
            Blocks::LimeBanner(state) => {
                Some(7977 + state.rotation)
            }
            Blocks::PinkBanner(state) => {
                Some(7993 + state.rotation)
            }
            Blocks::GrayBanner(state) => {
                Some(8009 + state.rotation)
            }
            Blocks::LightGrayBanner(state) => {
                Some(8025 + state.rotation)
            }
            Blocks::CyanBanner(state) => {
                Some(8041 + state.rotation)
            }
            Blocks::PurpleBanner(state) => {
                Some(8057 + state.rotation)
            }
            Blocks::BlueBanner(state) => {
                Some(8073 + state.rotation)
            }
            Blocks::BrownBanner(state) => {
                Some(8089 + state.rotation)
            }
            Blocks::GreenBanner(state) => {
                Some(8105 + state.rotation)
            }
            Blocks::RedBanner(state) => {
                Some(8121 + state.rotation)
            }
            Blocks::BlackBanner(state) => {
                Some(8137 + state.rotation)
            }
            Blocks::WhiteWallBanner(state) => {
                Some(8153 + (state.facing as i32))
            }
            Blocks::OrangeWallBanner(state) => {
                Some(8157 + (state.facing as i32))
            }
            Blocks::MagentaWallBanner(state) => {
                Some(8161 + (state.facing as i32))
            }
            Blocks::LightBlueWallBanner(state) => {
                Some(8165 + (state.facing as i32))
            }
            Blocks::YellowWallBanner(state) => {
                Some(8169 + (state.facing as i32))
            }
            Blocks::LimeWallBanner(state) => {
                Some(8173 + (state.facing as i32))
            }
            Blocks::PinkWallBanner(state) => {
                Some(8177 + (state.facing as i32))
            }
            Blocks::GrayWallBanner(state) => {
                Some(8181 + (state.facing as i32))
            }
            Blocks::LightGrayWallBanner(state) => {
                Some(8185 + (state.facing as i32))
            }
            Blocks::CyanWallBanner(state) => {
                Some(8189 + (state.facing as i32))
            }
            Blocks::PurpleWallBanner(state) => {
                Some(8193 + (state.facing as i32))
            }
            Blocks::BlueWallBanner(state) => {
                Some(8197 + (state.facing as i32))
            }
            Blocks::BrownWallBanner(state) => {
                Some(8201 + (state.facing as i32))
            }
            Blocks::GreenWallBanner(state) => {
                Some(8205 + (state.facing as i32))
            }
            Blocks::RedWallBanner(state) => {
                Some(8209 + (state.facing as i32))
            }
            Blocks::BlackWallBanner(state) => {
                Some(8213 + (state.facing as i32))
            }
            Blocks::RedSandstone => Some(8217),
            Blocks::ChiseledRedSandstone => Some(8218),
            Blocks::CutRedSandstone => Some(8219),
            Blocks::RedSandstoneStairs(state) => {
                Some(8220 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::OakSlab(state) => {
                Some(8300 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::SpruceSlab(state) => {
                Some(8306 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::BirchSlab(state) => {
                Some(8312 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::JungleSlab(state) => {
                Some(8318 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::AcaciaSlab(state) => {
                Some(8324 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::DarkOakSlab(state) => {
                Some(8330 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::StoneSlab(state) => {
                Some(8336 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::SmoothStoneSlab(state) => {
                Some(8342 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::SandstoneSlab(state) => {
                Some(8348 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::CutSandstoneSlab(state) => {
                Some(8354 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::PetrifiedOakSlab(state) => {
                Some(8360 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::CobblestoneSlab(state) => {
                Some(8366 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::BrickSlab(state) => {
                Some(8372 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::StoneBrickSlab(state) => {
                Some(8378 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::NetherBrickSlab(state) => {
                Some(8384 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::QuartzSlab(state) => {
                Some(8390 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::RedSandstoneSlab(state) => {
                Some(8396 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::CutRedSandstoneSlab(state) => {
                Some(8402 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::PurpurSlab(state) => {
                Some(8408 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::SmoothStone => Some(8414),
            Blocks::SmoothSandstone => Some(8415),
            Blocks::SmoothQuartz => Some(8416),
            Blocks::SmoothRedSandstone => Some(8417),
            Blocks::SpruceFenceGate(state) => {
                Some(8418 + (!state.powered() as i32) + 2 * (!state.open() as i32) + 4 * (!state.in_wall() as i32) + 8 * (state.facing as i32))
            }
            Blocks::BirchFenceGate(state) => {
                Some(8450 + (!state.powered() as i32) + 2 * (!state.open() as i32) + 4 * (!state.in_wall() as i32) + 8 * (state.facing as i32))
            }
            Blocks::JungleFenceGate(state) => {
                Some(8482 + (!state.powered() as i32) + 2 * (!state.open() as i32) + 4 * (!state.in_wall() as i32) + 8 * (state.facing as i32))
            }
            Blocks::AcaciaFenceGate(state) => {
                Some(8514 + (!state.powered() as i32) + 2 * (!state.open() as i32) + 4 * (!state.in_wall() as i32) + 8 * (state.facing as i32))
            }
            Blocks::DarkOakFenceGate(state) => {
                Some(8546 + (!state.powered() as i32) + 2 * (!state.open() as i32) + 4 * (!state.in_wall() as i32) + 8 * (state.facing as i32))
            }
            Blocks::SpruceFence(state) => {
                Some(8578 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::BirchFence(state) => {
                Some(8610 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::JungleFence(state) => {
                Some(8642 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::AcaciaFence(state) => {
                Some(8674 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::DarkOakFence(state) => {
                Some(8706 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::SpruceDoor(state) => {
                Some(8738 + (!state.powered() as i32) + 2 * (!state.open() as i32) + 4 * (state.hinge as i32) + 8 * (state.half as i32) + 16 * (state.facing as i32))
            }
            Blocks::BirchDoor(state) => {
                Some(8802 + (!state.powered() as i32) + 2 * (!state.open() as i32) + 4 * (state.hinge as i32) + 8 * (state.half as i32) + 16 * (state.facing as i32))
            }
            Blocks::JungleDoor(state) => {
                Some(8866 + (!state.powered() as i32) + 2 * (!state.open() as i32) + 4 * (state.hinge as i32) + 8 * (state.half as i32) + 16 * (state.facing as i32))
            }
            Blocks::AcaciaDoor(state) => {
                Some(8930 + (!state.powered() as i32) + 2 * (!state.open() as i32) + 4 * (state.hinge as i32) + 8 * (state.half as i32) + 16 * (state.facing as i32))
            }
            Blocks::DarkOakDoor(state) => {
                Some(8994 + (!state.powered() as i32) + 2 * (!state.open() as i32) + 4 * (state.hinge as i32) + 8 * (state.half as i32) + 16 * (state.facing as i32))
            }
            Blocks::EndRod(state) => {
                Some(9058 + (state.facing as i32))
            }
            Blocks::ChorusPlant(state) => {
                Some(9064 + (!state.west() as i32) + 2 * (!state.up() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32) + 32 * (!state.down() as i32))
            }
            Blocks::ChorusFlower(state) => {
                Some(9128 + state.age)
            }
            Blocks::PurpurBlock => Some(9134),
            Blocks::PurpurPillar(state) => {
                Some(9135 + (state.axis as i32))
            }
            Blocks::PurpurStairs(state) => {
                Some(9138 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::EndStoneBricks => Some(9218),
            Blocks::Beetroots(state) => {
                Some(9219 + state.age)
            }
            Blocks::DirtPath => Some(9223),
            Blocks::EndGateway => Some(9224),
            Blocks::RepeatingCommandBlock(state) => {
                Some(9225 + (state.facing as i32) + 6 * (!state.conditional() as i32))
            }
            Blocks::ChainCommandBlock(state) => {
                Some(9237 + (state.facing as i32) + 6 * (!state.conditional() as i32))
            }
            Blocks::FrostedIce(state) => {
                Some(9249 + state.age)
            }
            Blocks::MagmaBlock => Some(9253),
            Blocks::NetherWartBlock => Some(9254),
            Blocks::RedNetherBricks => Some(9255),
            Blocks::BoneBlock(state) => {
                Some(9256 + (state.axis as i32))
            }
            Blocks::StructureVoid => Some(9259),
            Blocks::Observer(state) => {
                Some(9260 + (!state.powered() as i32) + 2 * (state.facing as i32))
            }
            Blocks::ShulkerBox(state) => {
                Some(9272 + (state.facing as i32))
            }
            Blocks::WhiteShulkerBox(state) => {
                Some(9278 + (state.facing as i32))
            }
            Blocks::OrangeShulkerBox(state) => {
                Some(9284 + (state.facing as i32))
            }
            Blocks::MagentaShulkerBox(state) => {
                Some(9290 + (state.facing as i32))
            }
            Blocks::LightBlueShulkerBox(state) => {
                Some(9296 + (state.facing as i32))
            }
            Blocks::YellowShulkerBox(state) => {
                Some(9302 + (state.facing as i32))
            }
            Blocks::LimeShulkerBox(state) => {
                Some(9308 + (state.facing as i32))
            }
            Blocks::PinkShulkerBox(state) => {
                Some(9314 + (state.facing as i32))
            }
            Blocks::GrayShulkerBox(state) => {
                Some(9320 + (state.facing as i32))
            }
            Blocks::LightGrayShulkerBox(state) => {
                Some(9326 + (state.facing as i32))
            }
            Blocks::CyanShulkerBox(state) => {
                Some(9332 + (state.facing as i32))
            }
            Blocks::PurpleShulkerBox(state) => {
                Some(9338 + (state.facing as i32))
            }
            Blocks::BlueShulkerBox(state) => {
                Some(9344 + (state.facing as i32))
            }
            Blocks::BrownShulkerBox(state) => {
                Some(9350 + (state.facing as i32))
            }
            Blocks::GreenShulkerBox(state) => {
                Some(9356 + (state.facing as i32))
            }
            Blocks::RedShulkerBox(state) => {
                Some(9362 + (state.facing as i32))
            }
            Blocks::BlackShulkerBox(state) => {
                Some(9368 + (state.facing as i32))
            }
            Blocks::WhiteGlazedTerracotta(state) => {
                Some(9374 + (state.facing as i32))
            }
            Blocks::OrangeGlazedTerracotta(state) => {
                Some(9378 + (state.facing as i32))
            }
            Blocks::MagentaGlazedTerracotta(state) => {
                Some(9382 + (state.facing as i32))
            }
            Blocks::LightBlueGlazedTerracotta(state) => {
                Some(9386 + (state.facing as i32))
            }
            Blocks::YellowGlazedTerracotta(state) => {
                Some(9390 + (state.facing as i32))
            }
            Blocks::LimeGlazedTerracotta(state) => {
                Some(9394 + (state.facing as i32))
            }
            Blocks::PinkGlazedTerracotta(state) => {
                Some(9398 + (state.facing as i32))
            }
            Blocks::GrayGlazedTerracotta(state) => {
                Some(9402 + (state.facing as i32))
            }
            Blocks::LightGrayGlazedTerracotta(state) => {
                Some(9406 + (state.facing as i32))
            }
            Blocks::CyanGlazedTerracotta(state) => {
                Some(9410 + (state.facing as i32))
            }
            Blocks::PurpleGlazedTerracotta(state) => {
                Some(9414 + (state.facing as i32))
            }
            Blocks::BlueGlazedTerracotta(state) => {
                Some(9418 + (state.facing as i32))
            }
            Blocks::BrownGlazedTerracotta(state) => {
                Some(9422 + (state.facing as i32))
            }
            Blocks::GreenGlazedTerracotta(state) => {
                Some(9426 + (state.facing as i32))
            }
            Blocks::RedGlazedTerracotta(state) => {
                Some(9430 + (state.facing as i32))
            }
            Blocks::BlackGlazedTerracotta(state) => {
                Some(9434 + (state.facing as i32))
            }
            Blocks::WhiteConcrete => Some(9438),
            Blocks::OrangeConcrete => Some(9439),
            Blocks::MagentaConcrete => Some(9440),
            Blocks::LightBlueConcrete => Some(9441),
            Blocks::YellowConcrete => Some(9442),
            Blocks::LimeConcrete => Some(9443),
            Blocks::PinkConcrete => Some(9444),
            Blocks::GrayConcrete => Some(9445),
            Blocks::LightGrayConcrete => Some(9446),
            Blocks::CyanConcrete => Some(9447),
            Blocks::PurpleConcrete => Some(9448),
            Blocks::BlueConcrete => Some(9449),
            Blocks::BrownConcrete => Some(9450),
            Blocks::GreenConcrete => Some(9451),
            Blocks::RedConcrete => Some(9452),
            Blocks::BlackConcrete => Some(9453),
            Blocks::WhiteConcretePowder => Some(9454),
            Blocks::OrangeConcretePowder => Some(9455),
            Blocks::MagentaConcretePowder => Some(9456),
            Blocks::LightBlueConcretePowder => Some(9457),
            Blocks::YellowConcretePowder => Some(9458),
            Blocks::LimeConcretePowder => Some(9459),
            Blocks::PinkConcretePowder => Some(9460),
            Blocks::GrayConcretePowder => Some(9461),
            Blocks::LightGrayConcretePowder => Some(9462),
            Blocks::CyanConcretePowder => Some(9463),
            Blocks::PurpleConcretePowder => Some(9464),
            Blocks::BlueConcretePowder => Some(9465),
            Blocks::BrownConcretePowder => Some(9466),
            Blocks::GreenConcretePowder => Some(9467),
            Blocks::RedConcretePowder => Some(9468),
            Blocks::BlackConcretePowder => Some(9469),
            Blocks::Kelp(state) => {
                Some(9470 + state.age)
            }
            Blocks::KelpPlant => Some(9496),
            Blocks::DriedKelpBlock => Some(9497),
            Blocks::TurtleEgg(state) => {
                Some(9498 + state.hatch + 3 * state.eggs)
            }
            Blocks::DeadTubeCoralBlock => Some(9510),
            Blocks::DeadBrainCoralBlock => Some(9511),
            Blocks::DeadBubbleCoralBlock => Some(9512),
            Blocks::DeadFireCoralBlock => Some(9513),
            Blocks::DeadHornCoralBlock => Some(9514),
            Blocks::TubeCoralBlock => Some(9515),
            Blocks::BrainCoralBlock => Some(9516),
            Blocks::BubbleCoralBlock => Some(9517),
            Blocks::FireCoralBlock => Some(9518),
            Blocks::HornCoralBlock => Some(9519),
            Blocks::DeadTubeCoral(state) => {
                Some(9520 + (!state.waterlogged() as i32))
            }
            Blocks::DeadBrainCoral(state) => {
                Some(9522 + (!state.waterlogged() as i32))
            }
            Blocks::DeadBubbleCoral(state) => {
                Some(9524 + (!state.waterlogged() as i32))
            }
            Blocks::DeadFireCoral(state) => {
                Some(9526 + (!state.waterlogged() as i32))
            }
            Blocks::DeadHornCoral(state) => {
                Some(9528 + (!state.waterlogged() as i32))
            }
            Blocks::TubeCoral(state) => {
                Some(9530 + (!state.waterlogged() as i32))
            }
            Blocks::BrainCoral(state) => {
                Some(9532 + (!state.waterlogged() as i32))
            }
            Blocks::BubbleCoral(state) => {
                Some(9534 + (!state.waterlogged() as i32))
            }
            Blocks::FireCoral(state) => {
                Some(9536 + (!state.waterlogged() as i32))
            }
            Blocks::HornCoral(state) => {
                Some(9538 + (!state.waterlogged() as i32))
            }
            Blocks::DeadTubeCoralFan(state) => {
                Some(9540 + (!state.waterlogged() as i32))
            }
            Blocks::DeadBrainCoralFan(state) => {
                Some(9542 + (!state.waterlogged() as i32))
            }
            Blocks::DeadBubbleCoralFan(state) => {
                Some(9544 + (!state.waterlogged() as i32))
            }
            Blocks::DeadFireCoralFan(state) => {
                Some(9546 + (!state.waterlogged() as i32))
            }
            Blocks::DeadHornCoralFan(state) => {
                Some(9548 + (!state.waterlogged() as i32))
            }
            Blocks::TubeCoralFan(state) => {
                Some(9550 + (!state.waterlogged() as i32))
            }
            Blocks::BrainCoralFan(state) => {
                Some(9552 + (!state.waterlogged() as i32))
            }
            Blocks::BubbleCoralFan(state) => {
                Some(9554 + (!state.waterlogged() as i32))
            }
            Blocks::FireCoralFan(state) => {
                Some(9556 + (!state.waterlogged() as i32))
            }
            Blocks::HornCoralFan(state) => {
                Some(9558 + (!state.waterlogged() as i32))
            }
            Blocks::DeadTubeCoralWallFan(state) => {
                Some(9560 + (!state.waterlogged() as i32) + 2 * (state.facing as i32))
            }
            Blocks::DeadBrainCoralWallFan(state) => {
                Some(9568 + (!state.waterlogged() as i32) + 2 * (state.facing as i32))
            }
            Blocks::DeadBubbleCoralWallFan(state) => {
                Some(9576 + (!state.waterlogged() as i32) + 2 * (state.facing as i32))
            }
            Blocks::DeadFireCoralWallFan(state) => {
                Some(9584 + (!state.waterlogged() as i32) + 2 * (state.facing as i32))
            }
            Blocks::DeadHornCoralWallFan(state) => {
                Some(9592 + (!state.waterlogged() as i32) + 2 * (state.facing as i32))
            }
            Blocks::TubeCoralWallFan(state) => {
                Some(9600 + (!state.waterlogged() as i32) + 2 * (state.facing as i32))
            }
            Blocks::BrainCoralWallFan(state) => {
                Some(9608 + (!state.waterlogged() as i32) + 2 * (state.facing as i32))
            }
            Blocks::BubbleCoralWallFan(state) => {
                Some(9616 + (!state.waterlogged() as i32) + 2 * (state.facing as i32))
            }
            Blocks::FireCoralWallFan(state) => {
                Some(9624 + (!state.waterlogged() as i32) + 2 * (state.facing as i32))
            }
            Blocks::HornCoralWallFan(state) => {
                Some(9632 + (!state.waterlogged() as i32) + 2 * (state.facing as i32))
            }
            Blocks::SeaPickle(state) => {
                Some(9640 + (!state.waterlogged() as i32) + 2 * state.pickles)
            }
            Blocks::BlueIce => Some(9648),
            Blocks::Conduit(state) => {
                Some(9649 + (!state.waterlogged() as i32))
            }
            Blocks::BambooSapling => Some(9651),
            Blocks::Bamboo(state) => {
                Some(9652 + state.stage + 2 * (state.leaves as i32) + 6 * state.age)
            }
            Blocks::PottedBamboo => Some(9664),
            Blocks::VoidAir => Some(9665),
            Blocks::CaveAir => Some(9666),
            Blocks::BubbleColumn(state) => {
                Some(9667 + (!state.drag() as i32))
            }
            Blocks::PolishedGraniteStairs(state) => {
                Some(9669 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::SmoothRedSandstoneStairs(state) => {
                Some(9749 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::MossyStoneBrickStairs(state) => {
                Some(9829 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::PolishedDioriteStairs(state) => {
                Some(9909 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::MossyCobblestoneStairs(state) => {
                Some(9989 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::EndStoneBrickStairs(state) => {
                Some(10069 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::StoneStairs(state) => {
                Some(10149 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::SmoothSandstoneStairs(state) => {
                Some(10229 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::SmoothQuartzStairs(state) => {
                Some(10309 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::GraniteStairs(state) => {
                Some(10389 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::AndesiteStairs(state) => {
                Some(10469 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::RedNetherBrickStairs(state) => {
                Some(10549 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::PolishedAndesiteStairs(state) => {
                Some(10629 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::DioriteStairs(state) => {
                Some(10709 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::PolishedGraniteSlab(state) => {
                Some(10789 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::SmoothRedSandstoneSlab(state) => {
                Some(10795 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::MossyStoneBrickSlab(state) => {
                Some(10801 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::PolishedDioriteSlab(state) => {
                Some(10807 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::MossyCobblestoneSlab(state) => {
                Some(10813 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::EndStoneBrickSlab(state) => {
                Some(10819 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::SmoothSandstoneSlab(state) => {
                Some(10825 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::SmoothQuartzSlab(state) => {
                Some(10831 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::GraniteSlab(state) => {
                Some(10837 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::AndesiteSlab(state) => {
                Some(10843 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::RedNetherBrickSlab(state) => {
                Some(10849 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::PolishedAndesiteSlab(state) => {
                Some(10855 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::DioriteSlab(state) => {
                Some(10861 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::BrickWall(state) => {
                Some(10867 + (state.west as i32) + 3 * (!state.waterlogged() as i32) + 6 * (!state.up() as i32) + 12 * (state.south as i32) + 36 * (state.north as i32) + 108 * (state.east as i32))
            }
            Blocks::PrismarineWall(state) => {
                Some(11191 + (state.west as i32) + 3 * (!state.waterlogged() as i32) + 6 * (!state.up() as i32) + 12 * (state.south as i32) + 36 * (state.north as i32) + 108 * (state.east as i32))
            }
            Blocks::RedSandstoneWall(state) => {
                Some(11515 + (state.west as i32) + 3 * (!state.waterlogged() as i32) + 6 * (!state.up() as i32) + 12 * (state.south as i32) + 36 * (state.north as i32) + 108 * (state.east as i32))
            }
            Blocks::MossyStoneBrickWall(state) => {
                Some(11839 + (state.west as i32) + 3 * (!state.waterlogged() as i32) + 6 * (!state.up() as i32) + 12 * (state.south as i32) + 36 * (state.north as i32) + 108 * (state.east as i32))
            }
            Blocks::GraniteWall(state) => {
                Some(12163 + (state.west as i32) + 3 * (!state.waterlogged() as i32) + 6 * (!state.up() as i32) + 12 * (state.south as i32) + 36 * (state.north as i32) + 108 * (state.east as i32))
            }
            Blocks::StoneBrickWall(state) => {
                Some(12487 + (state.west as i32) + 3 * (!state.waterlogged() as i32) + 6 * (!state.up() as i32) + 12 * (state.south as i32) + 36 * (state.north as i32) + 108 * (state.east as i32))
            }
            Blocks::NetherBrickWall(state) => {
                Some(12811 + (state.west as i32) + 3 * (!state.waterlogged() as i32) + 6 * (!state.up() as i32) + 12 * (state.south as i32) + 36 * (state.north as i32) + 108 * (state.east as i32))
            }
            Blocks::AndesiteWall(state) => {
                Some(13135 + (state.west as i32) + 3 * (!state.waterlogged() as i32) + 6 * (!state.up() as i32) + 12 * (state.south as i32) + 36 * (state.north as i32) + 108 * (state.east as i32))
            }
            Blocks::RedNetherBrickWall(state) => {
                Some(13459 + (state.west as i32) + 3 * (!state.waterlogged() as i32) + 6 * (!state.up() as i32) + 12 * (state.south as i32) + 36 * (state.north as i32) + 108 * (state.east as i32))
            }
            Blocks::SandstoneWall(state) => {
                Some(13783 + (state.west as i32) + 3 * (!state.waterlogged() as i32) + 6 * (!state.up() as i32) + 12 * (state.south as i32) + 36 * (state.north as i32) + 108 * (state.east as i32))
            }
            Blocks::EndStoneBrickWall(state) => {
                Some(14107 + (state.west as i32) + 3 * (!state.waterlogged() as i32) + 6 * (!state.up() as i32) + 12 * (state.south as i32) + 36 * (state.north as i32) + 108 * (state.east as i32))
            }
            Blocks::DioriteWall(state) => {
                Some(14431 + (state.west as i32) + 3 * (!state.waterlogged() as i32) + 6 * (!state.up() as i32) + 12 * (state.south as i32) + 36 * (state.north as i32) + 108 * (state.east as i32))
            }
            Blocks::Scaffolding(state) => {
                Some(14755 + (!state.waterlogged() as i32) + 2 * state.distance + 16 * (!state.bottom() as i32))
            }
            Blocks::Loom(state) => {
                Some(14787 + (state.facing as i32))
            }
            Blocks::Barrel(state) => {
                Some(14791 + (!state.open() as i32) + 2 * (state.facing as i32))
            }
            Blocks::Smoker(state) => {
                Some(14803 + (!state.lit() as i32) + 2 * (state.facing as i32))
            }
            Blocks::BlastFurnace(state) => {
                Some(14811 + (!state.lit() as i32) + 2 * (state.facing as i32))
            }
            Blocks::CartographyTable => Some(14819),
            Blocks::FletchingTable => Some(14820),
            Blocks::Grindstone(state) => {
                Some(14821 + (state.facing as i32) + 4 * (state.face as i32))
            }
            Blocks::Lectern(state) => {
                Some(14833 + (!state.powered() as i32) + 2 * (!state.has_book() as i32) + 4 * (state.facing as i32))
            }
            Blocks::SmithingTable => Some(14849),
            Blocks::Stonecutter(state) => {
                Some(14850 + (state.facing as i32))
            }
            Blocks::Bell(state) => {
                Some(14854 + (!state.powered() as i32) + 2 * (state.facing as i32) + 8 * (state.attachment as i32))
            }
            Blocks::Lantern(state) => {
                Some(14886 + (!state.hanging() as i32))
            }
            Blocks::SoulLantern(state) => {
                Some(14888 + (!state.hanging() as i32))
            }
            Blocks::Campfire(state) => {
                Some(14890 + (!state.waterlogged() as i32) + 2 * (!state.signal_fire() as i32) + 4 * (!state.lit() as i32) + 8 * (state.facing as i32))
            }
            Blocks::SoulCampfire(state) => {
                Some(14922 + (!state.waterlogged() as i32) + 2 * (!state.signal_fire() as i32) + 4 * (!state.lit() as i32) + 8 * (state.facing as i32))
            }
            Blocks::SweetBerryBush(state) => {
                Some(14954 + state.age)
            }
            Blocks::WarpedStem(state) => {
                Some(14958 + (state.axis as i32))
            }
            Blocks::StrippedWarpedStem(state) => {
                Some(14961 + (state.axis as i32))
            }
            Blocks::WarpedHyphae(state) => {
                Some(14964 + (state.axis as i32))
            }
            Blocks::StrippedWarpedHyphae(state) => {
                Some(14967 + (state.axis as i32))
            }
            Blocks::WarpedNylium => Some(14970),
            Blocks::WarpedFungus => Some(14971),
            Blocks::WarpedWartBlock => Some(14972),
            Blocks::WarpedRoots => Some(14973),
            Blocks::NetherSprouts => Some(14974),
            Blocks::CrimsonStem(state) => {
                Some(14975 + (state.axis as i32))
            }
            Blocks::StrippedCrimsonStem(state) => {
                Some(14978 + (state.axis as i32))
            }
            Blocks::CrimsonHyphae(state) => {
                Some(14981 + (state.axis as i32))
            }
            Blocks::StrippedCrimsonHyphae(state) => {
                Some(14984 + (state.axis as i32))
            }
            Blocks::CrimsonNylium => Some(14987),
            Blocks::CrimsonFungus => Some(14988),
            Blocks::Shroomlight => Some(14989),
            Blocks::WeepingVines(state) => {
                Some(14990 + state.age)
            }
            Blocks::WeepingVinesPlant => Some(15016),
            Blocks::TwistingVines(state) => {
                Some(15017 + state.age)
            }
            Blocks::TwistingVinesPlant => Some(15043),
            Blocks::CrimsonRoots => Some(15044),
            Blocks::CrimsonPlanks => Some(15045),
            Blocks::WarpedPlanks => Some(15046),
            Blocks::CrimsonSlab(state) => {
                Some(15047 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::WarpedSlab(state) => {
                Some(15053 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::CrimsonPressurePlate(state) => {
                Some(15059 + (!state.powered() as i32))
            }
            Blocks::WarpedPressurePlate(state) => {
                Some(15061 + (!state.powered() as i32))
            }
            Blocks::CrimsonFence(state) => {
                Some(15063 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::WarpedFence(state) => {
                Some(15095 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::CrimsonTrapdoor(state) => {
                Some(15127 + (!state.waterlogged() as i32) + 2 * (!state.powered() as i32) + 4 * (!state.open() as i32) + 8 * (state.half as i32) + 16 * (state.facing as i32))
            }
            Blocks::WarpedTrapdoor(state) => {
                Some(15191 + (!state.waterlogged() as i32) + 2 * (!state.powered() as i32) + 4 * (!state.open() as i32) + 8 * (state.half as i32) + 16 * (state.facing as i32))
            }
            Blocks::CrimsonFenceGate(state) => {
                Some(15255 + (!state.powered() as i32) + 2 * (!state.open() as i32) + 4 * (!state.in_wall() as i32) + 8 * (state.facing as i32))
            }
            Blocks::WarpedFenceGate(state) => {
                Some(15287 + (!state.powered() as i32) + 2 * (!state.open() as i32) + 4 * (!state.in_wall() as i32) + 8 * (state.facing as i32))
            }
            Blocks::CrimsonStairs(state) => {
                Some(15319 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::WarpedStairs(state) => {
                Some(15399 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::CrimsonButton(state) => {
                Some(15479 + (!state.powered() as i32) + 2 * (state.facing as i32) + 8 * (state.face as i32))
            }
            Blocks::WarpedButton(state) => {
                Some(15503 + (!state.powered() as i32) + 2 * (state.facing as i32) + 8 * (state.face as i32))
            }
            Blocks::CrimsonDoor(state) => {
                Some(15527 + (!state.powered() as i32) + 2 * (!state.open() as i32) + 4 * (state.hinge as i32) + 8 * (state.half as i32) + 16 * (state.facing as i32))
            }
            Blocks::WarpedDoor(state) => {
                Some(15591 + (!state.powered() as i32) + 2 * (!state.open() as i32) + 4 * (state.hinge as i32) + 8 * (state.half as i32) + 16 * (state.facing as i32))
            }
            Blocks::CrimsonSign(state) => {
                Some(15655 + (!state.waterlogged() as i32) + 2 * state.rotation)
            }
            Blocks::WarpedSign(state) => {
                Some(15687 + (!state.waterlogged() as i32) + 2 * state.rotation)
            }
            Blocks::CrimsonWallSign(state) => {
                Some(15719 + (!state.waterlogged() as i32) + 2 * (state.facing as i32))
            }
            Blocks::WarpedWallSign(state) => {
                Some(15727 + (!state.waterlogged() as i32) + 2 * (state.facing as i32))
            }
            Blocks::StructureBlock(state) => {
                Some(15735 + (state.mode as i32))
            }
            Blocks::Jigsaw(state) => {
                Some(15739 + (state.orientation as i32))
            }
            Blocks::Composter(state) => {
                Some(15751 + state.level)
            }
            Blocks::Target(state) => {
                Some(15760 + state.power)
            }
            Blocks::BeeNest(state) => {
                Some(15776 + state.honey_level + 6 * (state.facing as i32))
            }
            Blocks::Beehive(state) => {
                Some(15800 + state.honey_level + 6 * (state.facing as i32))
            }
            Blocks::HoneyBlock => Some(15824),
            Blocks::HoneycombBlock => Some(15825),
            Blocks::NetheriteBlock => Some(15826),
            Blocks::AncientDebris => Some(15827),
            Blocks::CryingObsidian => Some(15828),
            Blocks::RespawnAnchor(state) => {
                Some(15829 + state.charges)
            }
            Blocks::PottedCrimsonFungus => Some(15834),
            Blocks::PottedWarpedFungus => Some(15835),
            Blocks::PottedCrimsonRoots => Some(15836),
            Blocks::PottedWarpedRoots => Some(15837),
            Blocks::Lodestone => Some(15838),
            Blocks::Blackstone => Some(15839),
            Blocks::BlackstoneStairs(state) => {
                Some(15840 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::BlackstoneWall(state) => {
                Some(15920 + (state.west as i32) + 3 * (!state.waterlogged() as i32) + 6 * (!state.up() as i32) + 12 * (state.south as i32) + 36 * (state.north as i32) + 108 * (state.east as i32))
            }
            Blocks::BlackstoneSlab(state) => {
                Some(16244 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::PolishedBlackstone => Some(16250),
            Blocks::PolishedBlackstoneBricks => Some(16251),
            Blocks::CrackedPolishedBlackstoneBricks => Some(16252),
            Blocks::ChiseledPolishedBlackstone => Some(16253),
            Blocks::PolishedBlackstoneBrickSlab(state) => {
                Some(16254 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::PolishedBlackstoneBrickStairs(state) => {
                Some(16260 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::PolishedBlackstoneBrickWall(state) => {
                Some(16340 + (state.west as i32) + 3 * (!state.waterlogged() as i32) + 6 * (!state.up() as i32) + 12 * (state.south as i32) + 36 * (state.north as i32) + 108 * (state.east as i32))
            }
            Blocks::GildedBlackstone => Some(16664),
            Blocks::PolishedBlackstoneStairs(state) => {
                Some(16665 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::PolishedBlackstoneSlab(state) => {
                Some(16745 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::PolishedBlackstonePressurePlate(state) => {
                Some(16751 + (!state.powered() as i32))
            }
            Blocks::PolishedBlackstoneButton(state) => {
                Some(16753 + (!state.powered() as i32) + 2 * (state.facing as i32) + 8 * (state.face as i32))
            }
            Blocks::PolishedBlackstoneWall(state) => {
                Some(16777 + (state.west as i32) + 3 * (!state.waterlogged() as i32) + 6 * (!state.up() as i32) + 12 * (state.south as i32) + 36 * (state.north as i32) + 108 * (state.east as i32))
            }
            Blocks::ChiseledNetherBricks => Some(17101),
            Blocks::CrackedNetherBricks => Some(17102),
            Blocks::QuartzBricks => Some(17103),
            Blocks::Candle(_) => None,
            Blocks::WhiteCandle(_) => None,
            Blocks::OrangeCandle(_) => None,
            Blocks::MagentaCandle(_) => None,
            Blocks::LightBlueCandle(_) => None,
            Blocks::YellowCandle(_) => None,
            Blocks::LimeCandle(_) => None,
            Blocks::PinkCandle(_) => None,
            Blocks::GrayCandle(_) => None,
            Blocks::LightGrayCandle(_) => None,
            Blocks::CyanCandle(_) => None,
            Blocks::PurpleCandle(_) => None,
            Blocks::BlueCandle(_) => None,
            Blocks::BrownCandle(_) => None,
            Blocks::GreenCandle(_) => None,
            Blocks::RedCandle(_) => None,
            Blocks::BlackCandle(_) => None,
            Blocks::CandleCake(_) => None,
            Blocks::WhiteCandleCake(_) => None,
            Blocks::OrangeCandleCake(_) => None,
            Blocks::MagentaCandleCake(_) => None,
            Blocks::LightBlueCandleCake(_) => None,
            Blocks::YellowCandleCake(_) => None,
            Blocks::LimeCandleCake(_) => None,
            Blocks::PinkCandleCake(_) => None,
            Blocks::GrayCandleCake(_) => None,
            Blocks::LightGrayCandleCake(_) => None,
            Blocks::CyanCandleCake(_) => None,
            Blocks::PurpleCandleCake(_) => None,
            Blocks::BlueCandleCake(_) => None,
            Blocks::BrownCandleCake(_) => None,
            Blocks::GreenCandleCake(_) => None,
            Blocks::RedCandleCake(_) => None,
            Blocks::BlackCandleCake(_) => None,
            Blocks::AmethystBlock => None,
            Blocks::BuddingAmethyst => None,
            Blocks::AmethystCluster(_) => None,
            Blocks::LargeAmethystBud(_) => None,
            Blocks::MediumAmethystBud(_) => None,
            Blocks::SmallAmethystBud(_) => None,
            Blocks::Tuff => None,
            Blocks::Calcite => None,
            Blocks::TintedGlass => None,
            Blocks::PowderSnow => None,
            Blocks::SculkSensor(_) => None,
            Blocks::OxidizedCopper => None,
            Blocks::WeatheredCopper => None,
            Blocks::ExposedCopper => None,
            Blocks::CopperBlock => None,
            Blocks::CopperOre => None,
            Blocks::DeepslateCopperOre => None,
            Blocks::OxidizedCutCopper => None,
            Blocks::WeatheredCutCopper => None,
            Blocks::ExposedCutCopper => None,
            Blocks::CutCopper => None,
            Blocks::OxidizedCutCopperStairs(_) => None,
            Blocks::WeatheredCutCopperStairs(_) => None,
            Blocks::ExposedCutCopperStairs(_) => None,
            Blocks::CutCopperStairs(_) => None,
            Blocks::OxidizedCutCopperSlab(_) => None,
            Blocks::WeatheredCutCopperSlab(_) => None,
            Blocks::ExposedCutCopperSlab(_) => None,
            Blocks::CutCopperSlab(_) => None,
            Blocks::WaxedCopperBlock => None,
            Blocks::WaxedWeatheredCopper => None,
            Blocks::WaxedExposedCopper => None,
            Blocks::WaxedOxidizedCopper => None,
            Blocks::WaxedOxidizedCutCopper => None,
            Blocks::WaxedWeatheredCutCopper => None,
            Blocks::WaxedExposedCutCopper => None,
            Blocks::WaxedCutCopper => None,
            Blocks::WaxedOxidizedCutCopperStairs(_) => None,
            Blocks::WaxedWeatheredCutCopperStairs(_) => None,
            Blocks::WaxedExposedCutCopperStairs(_) => None,
            Blocks::WaxedCutCopperStairs(_) => None,
            Blocks::WaxedOxidizedCutCopperSlab(_) => None,
            Blocks::WaxedWeatheredCutCopperSlab(_) => None,
            Blocks::WaxedExposedCutCopperSlab(_) => None,
            Blocks::WaxedCutCopperSlab(_) => None,
            Blocks::LightningRod(_) => None,
            Blocks::PointedDripstone(_) => None,
            Blocks::DripstoneBlock => None,
            Blocks::CaveVines(_) => None,
            Blocks::CaveVinesPlant(_) => None,
            Blocks::SporeBlossom => None,
            Blocks::Azalea => None,
            Blocks::FloweringAzalea => None,
            Blocks::MossCarpet => None,
            Blocks::MossBlock => None,
            Blocks::BigDripleaf(_) => None,
            Blocks::BigDripleafStem(_) => None,
            Blocks::SmallDripleaf(_) => None,
            Blocks::HangingRoots(_) => None,
            Blocks::RootedDirt => None,
            Blocks::Deepslate(_) => None,
            Blocks::CobbledDeepslate => None,
            Blocks::CobbledDeepslateStairs(_) => None,
            Blocks::CobbledDeepslateSlab(_) => None,
            Blocks::CobbledDeepslateWall(_) => None,
            Blocks::PolishedDeepslate => None,
            Blocks::PolishedDeepslateStairs(_) => None,
            Blocks::PolishedDeepslateSlab(_) => None,
            Blocks::PolishedDeepslateWall(_) => None,
            Blocks::DeepslateTiles => None,
            Blocks::DeepslateTileStairs(_) => None,
            Blocks::DeepslateTileSlab(_) => None,
            Blocks::DeepslateTileWall(_) => None,
            Blocks::DeepslateBricks => None,
            Blocks::DeepslateBrickStairs(_) => None,
            Blocks::DeepslateBrickSlab(_) => None,
            Blocks::DeepslateBrickWall(_) => None,
            Blocks::ChiseledDeepslate => None,
            Blocks::CrackedDeepslateBricks => None,
            Blocks::CrackedDeepslateTiles => None,
            Blocks::InfestedDeepslate(_) => None,
            Blocks::SmoothBasalt => None,
            Blocks::RawIronBlock => None,
            Blocks::RawCopperBlock => None,
            Blocks::RawGoldBlock => None,
            Blocks::PottedAzaleaBush => None,
            Blocks::PottedFloweringAzaleaBush => None,
        }
    }
    pub fn get_global_id_2230(&self) -> Option<i32> {
        match self {
            Blocks::Air => Some(0),
            Blocks::Stone => Some(1),
            Blocks::Granite => Some(2),
            Blocks::PolishedGranite => Some(3),
            Blocks::Diorite => Some(4),
            Blocks::PolishedDiorite => Some(5),
            Blocks::Andesite => Some(6),
            Blocks::PolishedAndesite => Some(7),
            Blocks::GrassBlock(state) => {
                Some(8 + (!state.snowy() as i32))
            }
            Blocks::Dirt => Some(10),
            Blocks::CoarseDirt => Some(11),
            Blocks::Podzol(state) => {
                Some(12 + (!state.snowy() as i32))
            }
            Blocks::Cobblestone => Some(14),
            Blocks::OakPlanks => Some(15),
            Blocks::SprucePlanks => Some(16),
            Blocks::BirchPlanks => Some(17),
            Blocks::JunglePlanks => Some(18),
            Blocks::AcaciaPlanks => Some(19),
            Blocks::DarkOakPlanks => Some(20),
            Blocks::OakSapling(state) => {
                Some(21 + state.stage)
            }
            Blocks::SpruceSapling(state) => {
                Some(23 + state.stage)
            }
            Blocks::BirchSapling(state) => {
                Some(25 + state.stage)
            }
            Blocks::JungleSapling(state) => {
                Some(27 + state.stage)
            }
            Blocks::AcaciaSapling(state) => {
                Some(29 + state.stage)
            }
            Blocks::DarkOakSapling(state) => {
                Some(31 + state.stage)
            }
            Blocks::Bedrock => Some(33),
            Blocks::Water(state) => {
                Some(34 + state.level)
            }
            Blocks::Lava(state) => {
                Some(50 + state.level)
            }
            Blocks::Sand => Some(66),
            Blocks::RedSand => Some(67),
            Blocks::Gravel => Some(68),
            Blocks::GoldOre => Some(69),
            Blocks::DeepslateGoldOre => None,
            Blocks::IronOre => Some(70),
            Blocks::DeepslateIronOre => None,
            Blocks::CoalOre => Some(71),
            Blocks::DeepslateCoalOre => None,
            Blocks::NetherGoldOre => None,
            Blocks::OakLog(state) => {
                Some(72 + (state.axis as i32))
            }
            Blocks::SpruceLog(state) => {
                Some(75 + (state.axis as i32))
            }
            Blocks::BirchLog(state) => {
                Some(78 + (state.axis as i32))
            }
            Blocks::JungleLog(state) => {
                Some(81 + (state.axis as i32))
            }
            Blocks::AcaciaLog(state) => {
                Some(84 + (state.axis as i32))
            }
            Blocks::DarkOakLog(state) => {
                Some(87 + (state.axis as i32))
            }
            Blocks::StrippedSpruceLog(state) => {
                Some(90 + (state.axis as i32))
            }
            Blocks::StrippedBirchLog(state) => {
                Some(93 + (state.axis as i32))
            }
            Blocks::StrippedJungleLog(state) => {
                Some(96 + (state.axis as i32))
            }
            Blocks::StrippedAcaciaLog(state) => {
                Some(99 + (state.axis as i32))
            }
            Blocks::StrippedDarkOakLog(state) => {
                Some(102 + (state.axis as i32))
            }
            Blocks::StrippedOakLog(state) => {
                Some(105 + (state.axis as i32))
            }
            Blocks::OakWood(state) => {
                Some(108 + (state.axis as i32))
            }
            Blocks::SpruceWood(state) => {
                Some(111 + (state.axis as i32))
            }
            Blocks::BirchWood(state) => {
                Some(114 + (state.axis as i32))
            }
            Blocks::JungleWood(state) => {
                Some(117 + (state.axis as i32))
            }
            Blocks::AcaciaWood(state) => {
                Some(120 + (state.axis as i32))
            }
            Blocks::DarkOakWood(state) => {
                Some(123 + (state.axis as i32))
            }
            Blocks::StrippedOakWood(state) => {
                Some(126 + (state.axis as i32))
            }
            Blocks::StrippedSpruceWood(state) => {
                Some(129 + (state.axis as i32))
            }
            Blocks::StrippedBirchWood(state) => {
                Some(132 + (state.axis as i32))
            }
            Blocks::StrippedJungleWood(state) => {
                Some(135 + (state.axis as i32))
            }
            Blocks::StrippedAcaciaWood(state) => {
                Some(138 + (state.axis as i32))
            }
            Blocks::StrippedDarkOakWood(state) => {
                Some(141 + (state.axis as i32))
            }
            Blocks::OakLeaves(state) => {
                Some(144 + (!state.persistent() as i32) + 2 * state.distance)
            }
            Blocks::SpruceLeaves(state) => {
                Some(158 + (!state.persistent() as i32) + 2 * state.distance)
            }
            Blocks::BirchLeaves(state) => {
                Some(172 + (!state.persistent() as i32) + 2 * state.distance)
            }
            Blocks::JungleLeaves(state) => {
                Some(186 + (!state.persistent() as i32) + 2 * state.distance)
            }
            Blocks::AcaciaLeaves(state) => {
                Some(200 + (!state.persistent() as i32) + 2 * state.distance)
            }
            Blocks::DarkOakLeaves(state) => {
                Some(214 + (!state.persistent() as i32) + 2 * state.distance)
            }
            Blocks::AzaleaLeaves(_) => None,
            Blocks::FloweringAzaleaLeaves(_) => None,
            Blocks::Sponge => Some(228),
            Blocks::WetSponge => Some(229),
            Blocks::Glass => Some(230),
            Blocks::LapisOre => Some(231),
            Blocks::DeepslateLapisOre => None,
            Blocks::LapisBlock => Some(232),
            Blocks::Dispenser(state) => {
                Some(233 + (!state.triggered() as i32) + 2 * (state.facing as i32))
            }
            Blocks::Sandstone => Some(245),
            Blocks::ChiseledSandstone => Some(246),
            Blocks::CutSandstone => Some(247),
            Blocks::NoteBlock(state) => {
                Some(248 + (!state.powered() as i32) + 2 * state.note + 50 * (state.instrument as i32))
            }
            Blocks::WhiteBed(state) => {
                Some(1048 + (state.part as i32) + 2 * (!state.occupied() as i32) + 4 * (state.facing as i32))
            }
            Blocks::OrangeBed(state) => {
                Some(1064 + (state.part as i32) + 2 * (!state.occupied() as i32) + 4 * (state.facing as i32))
            }
            Blocks::MagentaBed(state) => {
                Some(1080 + (state.part as i32) + 2 * (!state.occupied() as i32) + 4 * (state.facing as i32))
            }
            Blocks::LightBlueBed(state) => {
                Some(1096 + (state.part as i32) + 2 * (!state.occupied() as i32) + 4 * (state.facing as i32))
            }
            Blocks::YellowBed(state) => {
                Some(1112 + (state.part as i32) + 2 * (!state.occupied() as i32) + 4 * (state.facing as i32))
            }
            Blocks::LimeBed(state) => {
                Some(1128 + (state.part as i32) + 2 * (!state.occupied() as i32) + 4 * (state.facing as i32))
            }
            Blocks::PinkBed(state) => {
                Some(1144 + (state.part as i32) + 2 * (!state.occupied() as i32) + 4 * (state.facing as i32))
            }
            Blocks::GrayBed(state) => {
                Some(1160 + (state.part as i32) + 2 * (!state.occupied() as i32) + 4 * (state.facing as i32))
            }
            Blocks::LightGrayBed(state) => {
                Some(1176 + (state.part as i32) + 2 * (!state.occupied() as i32) + 4 * (state.facing as i32))
            }
            Blocks::CyanBed(state) => {
                Some(1192 + (state.part as i32) + 2 * (!state.occupied() as i32) + 4 * (state.facing as i32))
            }
            Blocks::PurpleBed(state) => {
                Some(1208 + (state.part as i32) + 2 * (!state.occupied() as i32) + 4 * (state.facing as i32))
            }
            Blocks::BlueBed(state) => {
                Some(1224 + (state.part as i32) + 2 * (!state.occupied() as i32) + 4 * (state.facing as i32))
            }
            Blocks::BrownBed(state) => {
                Some(1240 + (state.part as i32) + 2 * (!state.occupied() as i32) + 4 * (state.facing as i32))
            }
            Blocks::GreenBed(state) => {
                Some(1256 + (state.part as i32) + 2 * (!state.occupied() as i32) + 4 * (state.facing as i32))
            }
            Blocks::RedBed(state) => {
                Some(1272 + (state.part as i32) + 2 * (!state.occupied() as i32) + 4 * (state.facing as i32))
            }
            Blocks::BlackBed(state) => {
                Some(1288 + (state.part as i32) + 2 * (!state.occupied() as i32) + 4 * (state.facing as i32))
            }
            Blocks::PoweredRail(state) => {
                Some(1304 + (state.shape as i32) + 6 * (!state.powered() as i32))
            }
            Blocks::DetectorRail(state) => {
                Some(1316 + (state.shape as i32) + 6 * (!state.powered() as i32))
            }
            Blocks::StickyPiston(state) => {
                Some(1328 + (state.facing as i32) + 6 * (!state.extended() as i32))
            }
            Blocks::Cobweb => Some(1340),
            Blocks::Grass => Some(1341),
            Blocks::Fern => Some(1342),
            Blocks::DeadBush => Some(1343),
            Blocks::Seagrass => Some(1344),
            Blocks::TallSeagrass(state) => {
                Some(1345 + (state.half as i32))
            }
            Blocks::Piston(state) => {
                Some(1347 + (state.facing as i32) + 6 * (!state.extended() as i32))
            }
            Blocks::PistonHead(state) => {
                Some(1359 + (state.typed as i32) + 2 * (!state.short() as i32) + 4 * (state.facing as i32))
            }
            Blocks::WhiteWool => Some(1383),
            Blocks::OrangeWool => Some(1384),
            Blocks::MagentaWool => Some(1385),
            Blocks::LightBlueWool => Some(1386),
            Blocks::YellowWool => Some(1387),
            Blocks::LimeWool => Some(1388),
            Blocks::PinkWool => Some(1389),
            Blocks::GrayWool => Some(1390),
            Blocks::LightGrayWool => Some(1391),
            Blocks::CyanWool => Some(1392),
            Blocks::PurpleWool => Some(1393),
            Blocks::BlueWool => Some(1394),
            Blocks::BrownWool => Some(1395),
            Blocks::GreenWool => Some(1396),
            Blocks::RedWool => Some(1397),
            Blocks::BlackWool => Some(1398),
            Blocks::MovingPiston(state) => {
                Some(1399 + (state.typed as i32) + 2 * (state.facing as i32))
            }
            Blocks::Dandelion => Some(1411),
            Blocks::Poppy => Some(1412),
            Blocks::BlueOrchid => Some(1413),
            Blocks::Allium => Some(1414),
            Blocks::AzureBluet => Some(1415),
            Blocks::RedTulip => Some(1416),
            Blocks::OrangeTulip => Some(1417),
            Blocks::WhiteTulip => Some(1418),
            Blocks::PinkTulip => Some(1419),
            Blocks::OxeyeDaisy => Some(1420),
            Blocks::Cornflower => Some(1421),
            Blocks::WitherRose => Some(1422),
            Blocks::LilyOfTheValley => Some(1423),
            Blocks::BrownMushroom => Some(1424),
            Blocks::RedMushroom => Some(1425),
            Blocks::GoldBlock => Some(1426),
            Blocks::IronBlock => Some(1427),
            Blocks::Bricks => Some(1428),
            Blocks::Tnt(state) => {
                Some(1429 + (!state.unstable() as i32))
            }
            Blocks::Bookshelf => Some(1431),
            Blocks::MossyCobblestone => Some(1432),
            Blocks::Obsidian => Some(1433),
            Blocks::Torch => Some(1434),
            Blocks::WallTorch(state) => {
                Some(1435 + (state.facing as i32))
            }
            Blocks::Fire(state) => {
                Some(1439 + (!state.west() as i32) + 2 * (!state.up() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32) + 32 * state.age)
            }
            Blocks::SoulFire => None,
            Blocks::Spawner => Some(1951),
            Blocks::OakStairs(state) => {
                Some(1952 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::Chest(state) => {
                Some(2032 + (!state.waterlogged() as i32) + 2 * (state.typed as i32) + 6 * (state.facing as i32))
            }
            Blocks::RedstoneWire(state) => {
                Some(2056 + (state.west as i32) + 3 * (state.south as i32) + 9 * state.power + 144 * (state.north as i32) + 432 * (state.east as i32))
            }
            Blocks::DiamondOre => Some(3352),
            Blocks::DeepslateDiamondOre => None,
            Blocks::DiamondBlock => Some(3353),
            Blocks::CraftingTable => Some(3354),
            Blocks::Wheat(state) => {
                Some(3355 + state.age)
            }
            Blocks::Farmland(state) => {
                Some(3363 + state.moisture)
            }
            Blocks::Furnace(state) => {
                Some(3371 + (!state.lit() as i32) + 2 * (state.facing as i32))
            }
            Blocks::OakSign(state) => {
                Some(3379 + (!state.waterlogged() as i32) + 2 * state.rotation)
            }
            Blocks::SpruceSign(state) => {
                Some(3411 + (!state.waterlogged() as i32) + 2 * state.rotation)
            }
            Blocks::BirchSign(state) => {
                Some(3443 + (!state.waterlogged() as i32) + 2 * state.rotation)
            }
            Blocks::AcaciaSign(state) => {
                Some(3475 + (!state.waterlogged() as i32) + 2 * state.rotation)
            }
            Blocks::JungleSign(state) => {
                Some(3507 + (!state.waterlogged() as i32) + 2 * state.rotation)
            }
            Blocks::DarkOakSign(state) => {
                Some(3539 + (!state.waterlogged() as i32) + 2 * state.rotation)
            }
            Blocks::OakDoor(state) => {
                Some(3571 + (!state.powered() as i32) + 2 * (!state.open() as i32) + 4 * (state.hinge as i32) + 8 * (state.half as i32) + 16 * (state.facing as i32))
            }
            Blocks::Ladder(state) => {
                Some(3635 + (!state.waterlogged() as i32) + 2 * (state.facing as i32))
            }
            Blocks::Rail(state) => {
                Some(3643 + (state.shape as i32))
            }
            Blocks::CobblestoneStairs(state) => {
                Some(3653 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::OakWallSign(state) => {
                Some(3733 + (!state.waterlogged() as i32) + 2 * (state.facing as i32))
            }
            Blocks::SpruceWallSign(state) => {
                Some(3741 + (!state.waterlogged() as i32) + 2 * (state.facing as i32))
            }
            Blocks::BirchWallSign(state) => {
                Some(3749 + (!state.waterlogged() as i32) + 2 * (state.facing as i32))
            }
            Blocks::AcaciaWallSign(state) => {
                Some(3757 + (!state.waterlogged() as i32) + 2 * (state.facing as i32))
            }
            Blocks::JungleWallSign(state) => {
                Some(3765 + (!state.waterlogged() as i32) + 2 * (state.facing as i32))
            }
            Blocks::DarkOakWallSign(state) => {
                Some(3773 + (!state.waterlogged() as i32) + 2 * (state.facing as i32))
            }
            Blocks::Lever(state) => {
                Some(3781 + (!state.powered() as i32) + 2 * (state.facing as i32) + 8 * (state.face as i32))
            }
            Blocks::StonePressurePlate(state) => {
                Some(3805 + (!state.powered() as i32))
            }
            Blocks::IronDoor(state) => {
                Some(3807 + (!state.powered() as i32) + 2 * (!state.open() as i32) + 4 * (state.hinge as i32) + 8 * (state.half as i32) + 16 * (state.facing as i32))
            }
            Blocks::OakPressurePlate(state) => {
                Some(3871 + (!state.powered() as i32))
            }
            Blocks::SprucePressurePlate(state) => {
                Some(3873 + (!state.powered() as i32))
            }
            Blocks::BirchPressurePlate(state) => {
                Some(3875 + (!state.powered() as i32))
            }
            Blocks::JunglePressurePlate(state) => {
                Some(3877 + (!state.powered() as i32))
            }
            Blocks::AcaciaPressurePlate(state) => {
                Some(3879 + (!state.powered() as i32))
            }
            Blocks::DarkOakPressurePlate(state) => {
                Some(3881 + (!state.powered() as i32))
            }
            Blocks::RedstoneOre(state) => {
                Some(3883 + (!state.lit() as i32))
            }
            Blocks::DeepslateRedstoneOre(_) => None,
            Blocks::RedstoneTorch(state) => {
                Some(3885 + (!state.lit() as i32))
            }
            Blocks::RedstoneWallTorch(state) => {
                Some(3887 + (!state.lit() as i32) + 2 * (state.facing as i32))
            }
            Blocks::StoneButton(state) => {
                Some(3895 + (!state.powered() as i32) + 2 * (state.facing as i32) + 8 * (state.face as i32))
            }
            Blocks::Snow(state) => {
                Some(3919 + state.layers)
            }
            Blocks::Ice => Some(3927),
            Blocks::SnowBlock => Some(3928),
            Blocks::Cactus(state) => {
                Some(3929 + state.age)
            }
            Blocks::Clay => Some(3945),
            Blocks::SugarCane(state) => {
                Some(3946 + state.age)
            }
            Blocks::Jukebox(state) => {
                Some(3962 + (!state.has_record() as i32))
            }
            Blocks::OakFence(state) => {
                Some(3964 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::Pumpkin => Some(3996),
            Blocks::Netherrack => Some(3997),
            Blocks::SoulSand => Some(3998),
            Blocks::SoulSoil => None,
            Blocks::Basalt(_) => None,
            Blocks::PolishedBasalt(_) => None,
            Blocks::SoulTorch => None,
            Blocks::SoulWallTorch(_) => None,
            Blocks::Glowstone => Some(3999),
            Blocks::NetherPortal(state) => {
                Some(4000 + (state.axis as i32))
            }
            Blocks::CarvedPumpkin(state) => {
                Some(4002 + (state.facing as i32))
            }
            Blocks::JackOLantern(state) => {
                Some(4006 + (state.facing as i32))
            }
            Blocks::Cake(state) => {
                Some(4010 + state.bites)
            }
            Blocks::Repeater(state) => {
                Some(4017 + (!state.powered() as i32) + 2 * (!state.locked() as i32) + 4 * (state.facing as i32) + 16 * state.delay)
            }
            Blocks::WhiteStainedGlass => Some(4081),
            Blocks::OrangeStainedGlass => Some(4082),
            Blocks::MagentaStainedGlass => Some(4083),
            Blocks::LightBlueStainedGlass => Some(4084),
            Blocks::YellowStainedGlass => Some(4085),
            Blocks::LimeStainedGlass => Some(4086),
            Blocks::PinkStainedGlass => Some(4087),
            Blocks::GrayStainedGlass => Some(4088),
            Blocks::LightGrayStainedGlass => Some(4089),
            Blocks::CyanStainedGlass => Some(4090),
            Blocks::PurpleStainedGlass => Some(4091),
            Blocks::BlueStainedGlass => Some(4092),
            Blocks::BrownStainedGlass => Some(4093),
            Blocks::GreenStainedGlass => Some(4094),
            Blocks::RedStainedGlass => Some(4095),
            Blocks::BlackStainedGlass => Some(4096),
            Blocks::OakTrapdoor(state) => {
                Some(4097 + (!state.waterlogged() as i32) + 2 * (!state.powered() as i32) + 4 * (!state.open() as i32) + 8 * (state.half as i32) + 16 * (state.facing as i32))
            }
            Blocks::SpruceTrapdoor(state) => {
                Some(4161 + (!state.waterlogged() as i32) + 2 * (!state.powered() as i32) + 4 * (!state.open() as i32) + 8 * (state.half as i32) + 16 * (state.facing as i32))
            }
            Blocks::BirchTrapdoor(state) => {
                Some(4225 + (!state.waterlogged() as i32) + 2 * (!state.powered() as i32) + 4 * (!state.open() as i32) + 8 * (state.half as i32) + 16 * (state.facing as i32))
            }
            Blocks::JungleTrapdoor(state) => {
                Some(4289 + (!state.waterlogged() as i32) + 2 * (!state.powered() as i32) + 4 * (!state.open() as i32) + 8 * (state.half as i32) + 16 * (state.facing as i32))
            }
            Blocks::AcaciaTrapdoor(state) => {
                Some(4353 + (!state.waterlogged() as i32) + 2 * (!state.powered() as i32) + 4 * (!state.open() as i32) + 8 * (state.half as i32) + 16 * (state.facing as i32))
            }
            Blocks::DarkOakTrapdoor(state) => {
                Some(4417 + (!state.waterlogged() as i32) + 2 * (!state.powered() as i32) + 4 * (!state.open() as i32) + 8 * (state.half as i32) + 16 * (state.facing as i32))
            }
            Blocks::StoneBricks => Some(4481),
            Blocks::MossyStoneBricks => Some(4482),
            Blocks::CrackedStoneBricks => Some(4483),
            Blocks::ChiseledStoneBricks => Some(4484),
            Blocks::InfestedStone => Some(4485),
            Blocks::InfestedCobblestone => Some(4486),
            Blocks::InfestedStoneBricks => Some(4487),
            Blocks::InfestedMossyStoneBricks => Some(4488),
            Blocks::InfestedCrackedStoneBricks => Some(4489),
            Blocks::InfestedChiseledStoneBricks => Some(4490),
            Blocks::BrownMushroomBlock(state) => {
                Some(4491 + (!state.west() as i32) + 2 * (!state.up() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32) + 32 * (!state.down() as i32))
            }
            Blocks::RedMushroomBlock(state) => {
                Some(4555 + (!state.west() as i32) + 2 * (!state.up() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32) + 32 * (!state.down() as i32))
            }
            Blocks::MushroomStem(state) => {
                Some(4619 + (!state.west() as i32) + 2 * (!state.up() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32) + 32 * (!state.down() as i32))
            }
            Blocks::IronBars(state) => {
                Some(4683 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::Chain(_) => None,
            Blocks::GlassPane(state) => {
                Some(4715 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::Melon => Some(4747),
            Blocks::AttachedPumpkinStem(state) => {
                Some(4748 + (state.facing as i32))
            }
            Blocks::AttachedMelonStem(state) => {
                Some(4752 + (state.facing as i32))
            }
            Blocks::PumpkinStem(state) => {
                Some(4756 + state.age)
            }
            Blocks::MelonStem(state) => {
                Some(4764 + state.age)
            }
            Blocks::Vine(state) => {
                Some(4772 + (!state.west() as i32) + 2 * (!state.up() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::GlowLichen(_) => None,
            Blocks::OakFenceGate(state) => {
                Some(4804 + (!state.powered() as i32) + 2 * (!state.open() as i32) + 4 * (!state.in_wall() as i32) + 8 * (state.facing as i32))
            }
            Blocks::BrickStairs(state) => {
                Some(4836 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::StoneBrickStairs(state) => {
                Some(4916 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::Mycelium(state) => {
                Some(4996 + (!state.snowy() as i32))
            }
            Blocks::LilyPad => Some(4998),
            Blocks::NetherBricks => Some(4999),
            Blocks::NetherBrickFence(state) => {
                Some(5000 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::NetherBrickStairs(state) => {
                Some(5032 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::NetherWart(state) => {
                Some(5112 + state.age)
            }
            Blocks::EnchantingTable => Some(5116),
            Blocks::BrewingStand(state) => {
                Some(5117 + (!state.has_bottle_2() as i32) + 2 * (!state.has_bottle_1() as i32) + 4 * (!state.has_bottle_0() as i32))
            }
            Blocks::Cauldron => Some(5125),
            Blocks::WaterCauldron(state) => {
                Some(5126 + state.level)
            }
            Blocks::LavaCauldron => None,
            Blocks::PowderSnowCauldron(_) => None,
            Blocks::EndPortal => Some(5129),
            Blocks::EndPortalFrame(state) => {
                Some(5130 + (state.facing as i32) + 4 * (!state.eye() as i32))
            }
            Blocks::EndStone => Some(5138),
            Blocks::DragonEgg => Some(5139),
            Blocks::RedstoneLamp(state) => {
                Some(5140 + (!state.lit() as i32))
            }
            Blocks::Cocoa(state) => {
                Some(5142 + (state.facing as i32) + 4 * state.age)
            }
            Blocks::SandstoneStairs(state) => {
                Some(5154 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::EmeraldOre => Some(5234),
            Blocks::DeepslateEmeraldOre => None,
            Blocks::EnderChest(state) => {
                Some(5235 + (!state.waterlogged() as i32) + 2 * (state.facing as i32))
            }
            Blocks::TripwireHook(state) => {
                Some(5243 + (!state.powered() as i32) + 2 * (state.facing as i32) + 8 * (!state.attached() as i32))
            }
            Blocks::Tripwire(state) => {
                Some(5259 + (!state.west() as i32) + 2 * (!state.south() as i32) + 4 * (!state.powered() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32) + 32 * (!state.disarmed() as i32) + 64 * (!state.attached() as i32))
            }
            Blocks::EmeraldBlock => Some(5387),
            Blocks::SpruceStairs(state) => {
                Some(5388 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::BirchStairs(state) => {
                Some(5468 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::JungleStairs(state) => {
                Some(5548 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::CommandBlock(state) => {
                Some(5628 + (state.facing as i32) + 6 * (!state.conditional() as i32))
            }
            Blocks::Beacon => Some(5640),
            Blocks::CobblestoneWall(state) => {
                let value0 = match state.west {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                let value1 = match state.south {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                let value2 = match state.north {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                let value3 = match state.east {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                Some(5641 + value0 + 2 * (!state.waterlogged() as i32) + 4 * (!state.up() as i32) + 8 * value1 + 16 * value2 + 32 * value3)
            }
            Blocks::MossyCobblestoneWall(state) => {
                let value0 = match state.west {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                let value1 = match state.south {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                let value2 = match state.north {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                let value3 = match state.east {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                Some(5705 + value0 + 2 * (!state.waterlogged() as i32) + 4 * (!state.up() as i32) + 8 * value1 + 16 * value2 + 32 * value3)
            }
            Blocks::FlowerPot => Some(5769),
            Blocks::PottedOakSapling => Some(5770),
            Blocks::PottedSpruceSapling => Some(5771),
            Blocks::PottedBirchSapling => Some(5772),
            Blocks::PottedJungleSapling => Some(5773),
            Blocks::PottedAcaciaSapling => Some(5774),
            Blocks::PottedDarkOakSapling => Some(5775),
            Blocks::PottedFern => Some(5776),
            Blocks::PottedDandelion => Some(5777),
            Blocks::PottedPoppy => Some(5778),
            Blocks::PottedBlueOrchid => Some(5779),
            Blocks::PottedAllium => Some(5780),
            Blocks::PottedAzureBluet => Some(5781),
            Blocks::PottedRedTulip => Some(5782),
            Blocks::PottedOrangeTulip => Some(5783),
            Blocks::PottedWhiteTulip => Some(5784),
            Blocks::PottedPinkTulip => Some(5785),
            Blocks::PottedOxeyeDaisy => Some(5786),
            Blocks::PottedCornflower => Some(5787),
            Blocks::PottedLilyOfTheValley => Some(5788),
            Blocks::PottedWitherRose => Some(5789),
            Blocks::PottedRedMushroom => Some(5790),
            Blocks::PottedBrownMushroom => Some(5791),
            Blocks::PottedDeadBush => Some(5792),
            Blocks::PottedCactus => Some(5793),
            Blocks::Carrots(state) => {
                Some(5794 + state.age)
            }
            Blocks::Potatoes(state) => {
                Some(5802 + state.age)
            }
            Blocks::OakButton(state) => {
                Some(5810 + (!state.powered() as i32) + 2 * (state.facing as i32) + 8 * (state.face as i32))
            }
            Blocks::SpruceButton(state) => {
                Some(5834 + (!state.powered() as i32) + 2 * (state.facing as i32) + 8 * (state.face as i32))
            }
            Blocks::BirchButton(state) => {
                Some(5858 + (!state.powered() as i32) + 2 * (state.facing as i32) + 8 * (state.face as i32))
            }
            Blocks::JungleButton(state) => {
                Some(5882 + (!state.powered() as i32) + 2 * (state.facing as i32) + 8 * (state.face as i32))
            }
            Blocks::AcaciaButton(state) => {
                Some(5906 + (!state.powered() as i32) + 2 * (state.facing as i32) + 8 * (state.face as i32))
            }
            Blocks::DarkOakButton(state) => {
                Some(5930 + (!state.powered() as i32) + 2 * (state.facing as i32) + 8 * (state.face as i32))
            }
            Blocks::SkeletonSkull(state) => {
                Some(5954 + state.rotation)
            }
            Blocks::SkeletonWallSkull(state) => {
                Some(5970 + (state.facing as i32))
            }
            Blocks::WitherSkeletonSkull(state) => {
                Some(5974 + state.rotation)
            }
            Blocks::WitherSkeletonWallSkull(state) => {
                Some(5990 + (state.facing as i32))
            }
            Blocks::ZombieHead(state) => {
                Some(5994 + state.rotation)
            }
            Blocks::ZombieWallHead(state) => {
                Some(6010 + (state.facing as i32))
            }
            Blocks::PlayerHead(state) => {
                Some(6014 + state.rotation)
            }
            Blocks::PlayerWallHead(state) => {
                Some(6030 + (state.facing as i32))
            }
            Blocks::CreeperHead(state) => {
                Some(6034 + state.rotation)
            }
            Blocks::CreeperWallHead(state) => {
                Some(6050 + (state.facing as i32))
            }
            Blocks::DragonHead(state) => {
                Some(6054 + state.rotation)
            }
            Blocks::DragonWallHead(state) => {
                Some(6070 + (state.facing as i32))
            }
            Blocks::Anvil(state) => {
                Some(6074 + (state.facing as i32))
            }
            Blocks::ChippedAnvil(state) => {
                Some(6078 + (state.facing as i32))
            }
            Blocks::DamagedAnvil(state) => {
                Some(6082 + (state.facing as i32))
            }
            Blocks::TrappedChest(state) => {
                Some(6086 + (!state.waterlogged() as i32) + 2 * (state.typed as i32) + 6 * (state.facing as i32))
            }
            Blocks::LightWeightedPressurePlate(state) => {
                Some(6110 + state.power)
            }
            Blocks::HeavyWeightedPressurePlate(state) => {
                Some(6126 + state.power)
            }
            Blocks::Comparator(state) => {
                Some(6142 + (!state.powered() as i32) + 2 * (state.mode as i32) + 4 * (state.facing as i32))
            }
            Blocks::DaylightDetector(state) => {
                Some(6158 + state.power + 16 * (!state.inverted() as i32))
            }
            Blocks::RedstoneBlock => Some(6190),
            Blocks::NetherQuartzOre => Some(6191),
            Blocks::Hopper(state) => {
                Some(6192 + (state.facing as i32) + 5 * (!state.enabled() as i32))
            }
            Blocks::QuartzBlock => Some(6202),
            Blocks::ChiseledQuartzBlock => Some(6203),
            Blocks::QuartzPillar(state) => {
                Some(6204 + (state.axis as i32))
            }
            Blocks::QuartzStairs(state) => {
                Some(6207 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::ActivatorRail(state) => {
                Some(6287 + (state.shape as i32) + 6 * (!state.powered() as i32))
            }
            Blocks::Dropper(state) => {
                Some(6299 + (!state.triggered() as i32) + 2 * (state.facing as i32))
            }
            Blocks::WhiteTerracotta => Some(6311),
            Blocks::OrangeTerracotta => Some(6312),
            Blocks::MagentaTerracotta => Some(6313),
            Blocks::LightBlueTerracotta => Some(6314),
            Blocks::YellowTerracotta => Some(6315),
            Blocks::LimeTerracotta => Some(6316),
            Blocks::PinkTerracotta => Some(6317),
            Blocks::GrayTerracotta => Some(6318),
            Blocks::LightGrayTerracotta => Some(6319),
            Blocks::CyanTerracotta => Some(6320),
            Blocks::PurpleTerracotta => Some(6321),
            Blocks::BlueTerracotta => Some(6322),
            Blocks::BrownTerracotta => Some(6323),
            Blocks::GreenTerracotta => Some(6324),
            Blocks::RedTerracotta => Some(6325),
            Blocks::BlackTerracotta => Some(6326),
            Blocks::WhiteStainedGlassPane(state) => {
                Some(6327 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::OrangeStainedGlassPane(state) => {
                Some(6359 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::MagentaStainedGlassPane(state) => {
                Some(6391 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::LightBlueStainedGlassPane(state) => {
                Some(6423 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::YellowStainedGlassPane(state) => {
                Some(6455 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::LimeStainedGlassPane(state) => {
                Some(6487 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::PinkStainedGlassPane(state) => {
                Some(6519 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::GrayStainedGlassPane(state) => {
                Some(6551 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::LightGrayStainedGlassPane(state) => {
                Some(6583 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::CyanStainedGlassPane(state) => {
                Some(6615 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::PurpleStainedGlassPane(state) => {
                Some(6647 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::BlueStainedGlassPane(state) => {
                Some(6679 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::BrownStainedGlassPane(state) => {
                Some(6711 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::GreenStainedGlassPane(state) => {
                Some(6743 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::RedStainedGlassPane(state) => {
                Some(6775 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::BlackStainedGlassPane(state) => {
                Some(6807 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::AcaciaStairs(state) => {
                Some(6839 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::DarkOakStairs(state) => {
                Some(6919 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::SlimeBlock => Some(6999),
            Blocks::Barrier => Some(7000),
            Blocks::Light(_) => None,
            Blocks::IronTrapdoor(state) => {
                Some(7001 + (!state.waterlogged() as i32) + 2 * (!state.powered() as i32) + 4 * (!state.open() as i32) + 8 * (state.half as i32) + 16 * (state.facing as i32))
            }
            Blocks::Prismarine => Some(7065),
            Blocks::PrismarineBricks => Some(7066),
            Blocks::DarkPrismarine => Some(7067),
            Blocks::PrismarineStairs(state) => {
                Some(7068 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::PrismarineBrickStairs(state) => {
                Some(7148 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::DarkPrismarineStairs(state) => {
                Some(7228 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::PrismarineSlab(state) => {
                Some(7308 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::PrismarineBrickSlab(state) => {
                Some(7314 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::DarkPrismarineSlab(state) => {
                Some(7320 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::SeaLantern => Some(7326),
            Blocks::HayBlock(state) => {
                Some(7327 + (state.axis as i32))
            }
            Blocks::WhiteCarpet => Some(7330),
            Blocks::OrangeCarpet => Some(7331),
            Blocks::MagentaCarpet => Some(7332),
            Blocks::LightBlueCarpet => Some(7333),
            Blocks::YellowCarpet => Some(7334),
            Blocks::LimeCarpet => Some(7335),
            Blocks::PinkCarpet => Some(7336),
            Blocks::GrayCarpet => Some(7337),
            Blocks::LightGrayCarpet => Some(7338),
            Blocks::CyanCarpet => Some(7339),
            Blocks::PurpleCarpet => Some(7340),
            Blocks::BlueCarpet => Some(7341),
            Blocks::BrownCarpet => Some(7342),
            Blocks::GreenCarpet => Some(7343),
            Blocks::RedCarpet => Some(7344),
            Blocks::BlackCarpet => Some(7345),
            Blocks::Terracotta => Some(7346),
            Blocks::CoalBlock => Some(7347),
            Blocks::PackedIce => Some(7348),
            Blocks::Sunflower(state) => {
                Some(7349 + (state.half as i32))
            }
            Blocks::Lilac(state) => {
                Some(7351 + (state.half as i32))
            }
            Blocks::RoseBush(state) => {
                Some(7353 + (state.half as i32))
            }
            Blocks::Peony(state) => {
                Some(7355 + (state.half as i32))
            }
            Blocks::TallGrass(state) => {
                Some(7357 + (state.half as i32))
            }
            Blocks::LargeFern(state) => {
                Some(7359 + (state.half as i32))
            }
            Blocks::WhiteBanner(state) => {
                Some(7361 + state.rotation)
            }
            Blocks::OrangeBanner(state) => {
                Some(7377 + state.rotation)
            }
            Blocks::MagentaBanner(state) => {
                Some(7393 + state.rotation)
            }
            Blocks::LightBlueBanner(state) => {
                Some(7409 + state.rotation)
            }
            Blocks::YellowBanner(state) => {
                Some(7425 + state.rotation)
            }
            Blocks::LimeBanner(state) => {
                Some(7441 + state.rotation)
            }
            Blocks::PinkBanner(state) => {
                Some(7457 + state.rotation)
            }
            Blocks::GrayBanner(state) => {
                Some(7473 + state.rotation)
            }
            Blocks::LightGrayBanner(state) => {
                Some(7489 + state.rotation)
            }
            Blocks::CyanBanner(state) => {
                Some(7505 + state.rotation)
            }
            Blocks::PurpleBanner(state) => {
                Some(7521 + state.rotation)
            }
            Blocks::BlueBanner(state) => {
                Some(7537 + state.rotation)
            }
            Blocks::BrownBanner(state) => {
                Some(7553 + state.rotation)
            }
            Blocks::GreenBanner(state) => {
                Some(7569 + state.rotation)
            }
            Blocks::RedBanner(state) => {
                Some(7585 + state.rotation)
            }
            Blocks::BlackBanner(state) => {
                Some(7601 + state.rotation)
            }
            Blocks::WhiteWallBanner(state) => {
                Some(7617 + (state.facing as i32))
            }
            Blocks::OrangeWallBanner(state) => {
                Some(7621 + (state.facing as i32))
            }
            Blocks::MagentaWallBanner(state) => {
                Some(7625 + (state.facing as i32))
            }
            Blocks::LightBlueWallBanner(state) => {
                Some(7629 + (state.facing as i32))
            }
            Blocks::YellowWallBanner(state) => {
                Some(7633 + (state.facing as i32))
            }
            Blocks::LimeWallBanner(state) => {
                Some(7637 + (state.facing as i32))
            }
            Blocks::PinkWallBanner(state) => {
                Some(7641 + (state.facing as i32))
            }
            Blocks::GrayWallBanner(state) => {
                Some(7645 + (state.facing as i32))
            }
            Blocks::LightGrayWallBanner(state) => {
                Some(7649 + (state.facing as i32))
            }
            Blocks::CyanWallBanner(state) => {
                Some(7653 + (state.facing as i32))
            }
            Blocks::PurpleWallBanner(state) => {
                Some(7657 + (state.facing as i32))
            }
            Blocks::BlueWallBanner(state) => {
                Some(7661 + (state.facing as i32))
            }
            Blocks::BrownWallBanner(state) => {
                Some(7665 + (state.facing as i32))
            }
            Blocks::GreenWallBanner(state) => {
                Some(7669 + (state.facing as i32))
            }
            Blocks::RedWallBanner(state) => {
                Some(7673 + (state.facing as i32))
            }
            Blocks::BlackWallBanner(state) => {
                Some(7677 + (state.facing as i32))
            }
            Blocks::RedSandstone => Some(7681),
            Blocks::ChiseledRedSandstone => Some(7682),
            Blocks::CutRedSandstone => Some(7683),
            Blocks::RedSandstoneStairs(state) => {
                Some(7684 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::OakSlab(state) => {
                Some(7764 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::SpruceSlab(state) => {
                Some(7770 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::BirchSlab(state) => {
                Some(7776 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::JungleSlab(state) => {
                Some(7782 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::AcaciaSlab(state) => {
                Some(7788 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::DarkOakSlab(state) => {
                Some(7794 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::StoneSlab(state) => {
                Some(7800 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::SmoothStoneSlab(state) => {
                Some(7806 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::SandstoneSlab(state) => {
                Some(7812 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::CutSandstoneSlab(state) => {
                Some(7818 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::PetrifiedOakSlab(state) => {
                Some(7824 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::CobblestoneSlab(state) => {
                Some(7830 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::BrickSlab(state) => {
                Some(7836 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::StoneBrickSlab(state) => {
                Some(7842 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::NetherBrickSlab(state) => {
                Some(7848 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::QuartzSlab(state) => {
                Some(7854 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::RedSandstoneSlab(state) => {
                Some(7860 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::CutRedSandstoneSlab(state) => {
                Some(7866 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::PurpurSlab(state) => {
                Some(7872 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::SmoothStone => Some(7878),
            Blocks::SmoothSandstone => Some(7879),
            Blocks::SmoothQuartz => Some(7880),
            Blocks::SmoothRedSandstone => Some(7881),
            Blocks::SpruceFenceGate(state) => {
                Some(7882 + (!state.powered() as i32) + 2 * (!state.open() as i32) + 4 * (!state.in_wall() as i32) + 8 * (state.facing as i32))
            }
            Blocks::BirchFenceGate(state) => {
                Some(7914 + (!state.powered() as i32) + 2 * (!state.open() as i32) + 4 * (!state.in_wall() as i32) + 8 * (state.facing as i32))
            }
            Blocks::JungleFenceGate(state) => {
                Some(7946 + (!state.powered() as i32) + 2 * (!state.open() as i32) + 4 * (!state.in_wall() as i32) + 8 * (state.facing as i32))
            }
            Blocks::AcaciaFenceGate(state) => {
                Some(7978 + (!state.powered() as i32) + 2 * (!state.open() as i32) + 4 * (!state.in_wall() as i32) + 8 * (state.facing as i32))
            }
            Blocks::DarkOakFenceGate(state) => {
                Some(8010 + (!state.powered() as i32) + 2 * (!state.open() as i32) + 4 * (!state.in_wall() as i32) + 8 * (state.facing as i32))
            }
            Blocks::SpruceFence(state) => {
                Some(8042 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::BirchFence(state) => {
                Some(8074 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::JungleFence(state) => {
                Some(8106 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::AcaciaFence(state) => {
                Some(8138 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::DarkOakFence(state) => {
                Some(8170 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::SpruceDoor(state) => {
                Some(8202 + (!state.powered() as i32) + 2 * (!state.open() as i32) + 4 * (state.hinge as i32) + 8 * (state.half as i32) + 16 * (state.facing as i32))
            }
            Blocks::BirchDoor(state) => {
                Some(8266 + (!state.powered() as i32) + 2 * (!state.open() as i32) + 4 * (state.hinge as i32) + 8 * (state.half as i32) + 16 * (state.facing as i32))
            }
            Blocks::JungleDoor(state) => {
                Some(8330 + (!state.powered() as i32) + 2 * (!state.open() as i32) + 4 * (state.hinge as i32) + 8 * (state.half as i32) + 16 * (state.facing as i32))
            }
            Blocks::AcaciaDoor(state) => {
                Some(8394 + (!state.powered() as i32) + 2 * (!state.open() as i32) + 4 * (state.hinge as i32) + 8 * (state.half as i32) + 16 * (state.facing as i32))
            }
            Blocks::DarkOakDoor(state) => {
                Some(8458 + (!state.powered() as i32) + 2 * (!state.open() as i32) + 4 * (state.hinge as i32) + 8 * (state.half as i32) + 16 * (state.facing as i32))
            }
            Blocks::EndRod(state) => {
                Some(8522 + (state.facing as i32))
            }
            Blocks::ChorusPlant(state) => {
                Some(8528 + (!state.west() as i32) + 2 * (!state.up() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32) + 32 * (!state.down() as i32))
            }
            Blocks::ChorusFlower(state) => {
                Some(8592 + state.age)
            }
            Blocks::PurpurBlock => Some(8598),
            Blocks::PurpurPillar(state) => {
                Some(8599 + (state.axis as i32))
            }
            Blocks::PurpurStairs(state) => {
                Some(8602 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::EndStoneBricks => Some(8682),
            Blocks::Beetroots(state) => {
                Some(8683 + state.age)
            }
            Blocks::DirtPath => Some(8687),
            Blocks::EndGateway => Some(8688),
            Blocks::RepeatingCommandBlock(state) => {
                Some(8689 + (state.facing as i32) + 6 * (!state.conditional() as i32))
            }
            Blocks::ChainCommandBlock(state) => {
                Some(8701 + (state.facing as i32) + 6 * (!state.conditional() as i32))
            }
            Blocks::FrostedIce(state) => {
                Some(8713 + state.age)
            }
            Blocks::MagmaBlock => Some(8717),
            Blocks::NetherWartBlock => Some(8718),
            Blocks::RedNetherBricks => Some(8719),
            Blocks::BoneBlock(state) => {
                Some(8720 + (state.axis as i32))
            }
            Blocks::StructureVoid => Some(8723),
            Blocks::Observer(state) => {
                Some(8724 + (!state.powered() as i32) + 2 * (state.facing as i32))
            }
            Blocks::ShulkerBox(state) => {
                Some(8736 + (state.facing as i32))
            }
            Blocks::WhiteShulkerBox(state) => {
                Some(8742 + (state.facing as i32))
            }
            Blocks::OrangeShulkerBox(state) => {
                Some(8748 + (state.facing as i32))
            }
            Blocks::MagentaShulkerBox(state) => {
                Some(8754 + (state.facing as i32))
            }
            Blocks::LightBlueShulkerBox(state) => {
                Some(8760 + (state.facing as i32))
            }
            Blocks::YellowShulkerBox(state) => {
                Some(8766 + (state.facing as i32))
            }
            Blocks::LimeShulkerBox(state) => {
                Some(8772 + (state.facing as i32))
            }
            Blocks::PinkShulkerBox(state) => {
                Some(8778 + (state.facing as i32))
            }
            Blocks::GrayShulkerBox(state) => {
                Some(8784 + (state.facing as i32))
            }
            Blocks::LightGrayShulkerBox(state) => {
                Some(8790 + (state.facing as i32))
            }
            Blocks::CyanShulkerBox(state) => {
                Some(8796 + (state.facing as i32))
            }
            Blocks::PurpleShulkerBox(state) => {
                Some(8802 + (state.facing as i32))
            }
            Blocks::BlueShulkerBox(state) => {
                Some(8808 + (state.facing as i32))
            }
            Blocks::BrownShulkerBox(state) => {
                Some(8814 + (state.facing as i32))
            }
            Blocks::GreenShulkerBox(state) => {
                Some(8820 + (state.facing as i32))
            }
            Blocks::RedShulkerBox(state) => {
                Some(8826 + (state.facing as i32))
            }
            Blocks::BlackShulkerBox(state) => {
                Some(8832 + (state.facing as i32))
            }
            Blocks::WhiteGlazedTerracotta(state) => {
                Some(8838 + (state.facing as i32))
            }
            Blocks::OrangeGlazedTerracotta(state) => {
                Some(8842 + (state.facing as i32))
            }
            Blocks::MagentaGlazedTerracotta(state) => {
                Some(8846 + (state.facing as i32))
            }
            Blocks::LightBlueGlazedTerracotta(state) => {
                Some(8850 + (state.facing as i32))
            }
            Blocks::YellowGlazedTerracotta(state) => {
                Some(8854 + (state.facing as i32))
            }
            Blocks::LimeGlazedTerracotta(state) => {
                Some(8858 + (state.facing as i32))
            }
            Blocks::PinkGlazedTerracotta(state) => {
                Some(8862 + (state.facing as i32))
            }
            Blocks::GrayGlazedTerracotta(state) => {
                Some(8866 + (state.facing as i32))
            }
            Blocks::LightGrayGlazedTerracotta(state) => {
                Some(8870 + (state.facing as i32))
            }
            Blocks::CyanGlazedTerracotta(state) => {
                Some(8874 + (state.facing as i32))
            }
            Blocks::PurpleGlazedTerracotta(state) => {
                Some(8878 + (state.facing as i32))
            }
            Blocks::BlueGlazedTerracotta(state) => {
                Some(8882 + (state.facing as i32))
            }
            Blocks::BrownGlazedTerracotta(state) => {
                Some(8886 + (state.facing as i32))
            }
            Blocks::GreenGlazedTerracotta(state) => {
                Some(8890 + (state.facing as i32))
            }
            Blocks::RedGlazedTerracotta(state) => {
                Some(8894 + (state.facing as i32))
            }
            Blocks::BlackGlazedTerracotta(state) => {
                Some(8898 + (state.facing as i32))
            }
            Blocks::WhiteConcrete => Some(8902),
            Blocks::OrangeConcrete => Some(8903),
            Blocks::MagentaConcrete => Some(8904),
            Blocks::LightBlueConcrete => Some(8905),
            Blocks::YellowConcrete => Some(8906),
            Blocks::LimeConcrete => Some(8907),
            Blocks::PinkConcrete => Some(8908),
            Blocks::GrayConcrete => Some(8909),
            Blocks::LightGrayConcrete => Some(8910),
            Blocks::CyanConcrete => Some(8911),
            Blocks::PurpleConcrete => Some(8912),
            Blocks::BlueConcrete => Some(8913),
            Blocks::BrownConcrete => Some(8914),
            Blocks::GreenConcrete => Some(8915),
            Blocks::RedConcrete => Some(8916),
            Blocks::BlackConcrete => Some(8917),
            Blocks::WhiteConcretePowder => Some(8918),
            Blocks::OrangeConcretePowder => Some(8919),
            Blocks::MagentaConcretePowder => Some(8920),
            Blocks::LightBlueConcretePowder => Some(8921),
            Blocks::YellowConcretePowder => Some(8922),
            Blocks::LimeConcretePowder => Some(8923),
            Blocks::PinkConcretePowder => Some(8924),
            Blocks::GrayConcretePowder => Some(8925),
            Blocks::LightGrayConcretePowder => Some(8926),
            Blocks::CyanConcretePowder => Some(8927),
            Blocks::PurpleConcretePowder => Some(8928),
            Blocks::BlueConcretePowder => Some(8929),
            Blocks::BrownConcretePowder => Some(8930),
            Blocks::GreenConcretePowder => Some(8931),
            Blocks::RedConcretePowder => Some(8932),
            Blocks::BlackConcretePowder => Some(8933),
            Blocks::Kelp(state) => {
                Some(8934 + state.age)
            }
            Blocks::KelpPlant => Some(8960),
            Blocks::DriedKelpBlock => Some(8961),
            Blocks::TurtleEgg(state) => {
                Some(8962 + state.hatch + 3 * state.eggs)
            }
            Blocks::DeadTubeCoralBlock => Some(8974),
            Blocks::DeadBrainCoralBlock => Some(8975),
            Blocks::DeadBubbleCoralBlock => Some(8976),
            Blocks::DeadFireCoralBlock => Some(8977),
            Blocks::DeadHornCoralBlock => Some(8978),
            Blocks::TubeCoralBlock => Some(8979),
            Blocks::BrainCoralBlock => Some(8980),
            Blocks::BubbleCoralBlock => Some(8981),
            Blocks::FireCoralBlock => Some(8982),
            Blocks::HornCoralBlock => Some(8983),
            Blocks::DeadTubeCoral(state) => {
                Some(8984 + (!state.waterlogged() as i32))
            }
            Blocks::DeadBrainCoral(state) => {
                Some(8986 + (!state.waterlogged() as i32))
            }
            Blocks::DeadBubbleCoral(state) => {
                Some(8988 + (!state.waterlogged() as i32))
            }
            Blocks::DeadFireCoral(state) => {
                Some(8990 + (!state.waterlogged() as i32))
            }
            Blocks::DeadHornCoral(state) => {
                Some(8992 + (!state.waterlogged() as i32))
            }
            Blocks::TubeCoral(state) => {
                Some(8994 + (!state.waterlogged() as i32))
            }
            Blocks::BrainCoral(state) => {
                Some(8996 + (!state.waterlogged() as i32))
            }
            Blocks::BubbleCoral(state) => {
                Some(8998 + (!state.waterlogged() as i32))
            }
            Blocks::FireCoral(state) => {
                Some(9000 + (!state.waterlogged() as i32))
            }
            Blocks::HornCoral(state) => {
                Some(9002 + (!state.waterlogged() as i32))
            }
            Blocks::DeadTubeCoralFan(state) => {
                Some(9004 + (!state.waterlogged() as i32))
            }
            Blocks::DeadBrainCoralFan(state) => {
                Some(9006 + (!state.waterlogged() as i32))
            }
            Blocks::DeadBubbleCoralFan(state) => {
                Some(9008 + (!state.waterlogged() as i32))
            }
            Blocks::DeadFireCoralFan(state) => {
                Some(9010 + (!state.waterlogged() as i32))
            }
            Blocks::DeadHornCoralFan(state) => {
                Some(9012 + (!state.waterlogged() as i32))
            }
            Blocks::TubeCoralFan(state) => {
                Some(9014 + (!state.waterlogged() as i32))
            }
            Blocks::BrainCoralFan(state) => {
                Some(9016 + (!state.waterlogged() as i32))
            }
            Blocks::BubbleCoralFan(state) => {
                Some(9018 + (!state.waterlogged() as i32))
            }
            Blocks::FireCoralFan(state) => {
                Some(9020 + (!state.waterlogged() as i32))
            }
            Blocks::HornCoralFan(state) => {
                Some(9022 + (!state.waterlogged() as i32))
            }
            Blocks::DeadTubeCoralWallFan(state) => {
                Some(9024 + (!state.waterlogged() as i32) + 2 * (state.facing as i32))
            }
            Blocks::DeadBrainCoralWallFan(state) => {
                Some(9032 + (!state.waterlogged() as i32) + 2 * (state.facing as i32))
            }
            Blocks::DeadBubbleCoralWallFan(state) => {
                Some(9040 + (!state.waterlogged() as i32) + 2 * (state.facing as i32))
            }
            Blocks::DeadFireCoralWallFan(state) => {
                Some(9048 + (!state.waterlogged() as i32) + 2 * (state.facing as i32))
            }
            Blocks::DeadHornCoralWallFan(state) => {
                Some(9056 + (!state.waterlogged() as i32) + 2 * (state.facing as i32))
            }
            Blocks::TubeCoralWallFan(state) => {
                Some(9064 + (!state.waterlogged() as i32) + 2 * (state.facing as i32))
            }
            Blocks::BrainCoralWallFan(state) => {
                Some(9072 + (!state.waterlogged() as i32) + 2 * (state.facing as i32))
            }
            Blocks::BubbleCoralWallFan(state) => {
                Some(9080 + (!state.waterlogged() as i32) + 2 * (state.facing as i32))
            }
            Blocks::FireCoralWallFan(state) => {
                Some(9088 + (!state.waterlogged() as i32) + 2 * (state.facing as i32))
            }
            Blocks::HornCoralWallFan(state) => {
                Some(9096 + (!state.waterlogged() as i32) + 2 * (state.facing as i32))
            }
            Blocks::SeaPickle(state) => {
                Some(9104 + (!state.waterlogged() as i32) + 2 * state.pickles)
            }
            Blocks::BlueIce => Some(9112),
            Blocks::Conduit(state) => {
                Some(9113 + (!state.waterlogged() as i32))
            }
            Blocks::BambooSapling => Some(9115),
            Blocks::Bamboo(state) => {
                Some(9116 + state.stage + 2 * (state.leaves as i32) + 6 * state.age)
            }
            Blocks::PottedBamboo => Some(9128),
            Blocks::VoidAir => Some(9129),
            Blocks::CaveAir => Some(9130),
            Blocks::BubbleColumn(state) => {
                Some(9131 + (!state.drag() as i32))
            }
            Blocks::PolishedGraniteStairs(state) => {
                Some(9133 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::SmoothRedSandstoneStairs(state) => {
                Some(9213 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::MossyStoneBrickStairs(state) => {
                Some(9293 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::PolishedDioriteStairs(state) => {
                Some(9373 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::MossyCobblestoneStairs(state) => {
                Some(9453 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::EndStoneBrickStairs(state) => {
                Some(9533 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::StoneStairs(state) => {
                Some(9613 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::SmoothSandstoneStairs(state) => {
                Some(9693 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::SmoothQuartzStairs(state) => {
                Some(9773 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::GraniteStairs(state) => {
                Some(9853 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::AndesiteStairs(state) => {
                Some(9933 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::RedNetherBrickStairs(state) => {
                Some(10013 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::PolishedAndesiteStairs(state) => {
                Some(10093 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::DioriteStairs(state) => {
                Some(10173 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::PolishedGraniteSlab(state) => {
                Some(10253 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::SmoothRedSandstoneSlab(state) => {
                Some(10259 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::MossyStoneBrickSlab(state) => {
                Some(10265 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::PolishedDioriteSlab(state) => {
                Some(10271 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::MossyCobblestoneSlab(state) => {
                Some(10277 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::EndStoneBrickSlab(state) => {
                Some(10283 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::SmoothSandstoneSlab(state) => {
                Some(10289 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::SmoothQuartzSlab(state) => {
                Some(10295 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::GraniteSlab(state) => {
                Some(10301 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::AndesiteSlab(state) => {
                Some(10307 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::RedNetherBrickSlab(state) => {
                Some(10313 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::PolishedAndesiteSlab(state) => {
                Some(10319 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::DioriteSlab(state) => {
                Some(10325 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::BrickWall(state) => {
                let value0 = match state.west {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                let value1 = match state.south {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                let value2 = match state.north {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                let value3 = match state.east {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                Some(10331 + value0 + 2 * (!state.waterlogged() as i32) + 4 * (!state.up() as i32) + 8 * value1 + 16 * value2 + 32 * value3)
            }
            Blocks::PrismarineWall(state) => {
                let value0 = match state.west {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                let value1 = match state.south {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                let value2 = match state.north {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                let value3 = match state.east {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                Some(10395 + value0 + 2 * (!state.waterlogged() as i32) + 4 * (!state.up() as i32) + 8 * value1 + 16 * value2 + 32 * value3)
            }
            Blocks::RedSandstoneWall(state) => {
                let value0 = match state.west {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                let value1 = match state.south {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                let value2 = match state.north {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                let value3 = match state.east {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                Some(10459 + value0 + 2 * (!state.waterlogged() as i32) + 4 * (!state.up() as i32) + 8 * value1 + 16 * value2 + 32 * value3)
            }
            Blocks::MossyStoneBrickWall(state) => {
                let value0 = match state.west {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                let value1 = match state.south {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                let value2 = match state.north {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                let value3 = match state.east {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                Some(10523 + value0 + 2 * (!state.waterlogged() as i32) + 4 * (!state.up() as i32) + 8 * value1 + 16 * value2 + 32 * value3)
            }
            Blocks::GraniteWall(state) => {
                let value0 = match state.west {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                let value1 = match state.south {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                let value2 = match state.north {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                let value3 = match state.east {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                Some(10587 + value0 + 2 * (!state.waterlogged() as i32) + 4 * (!state.up() as i32) + 8 * value1 + 16 * value2 + 32 * value3)
            }
            Blocks::StoneBrickWall(state) => {
                let value0 = match state.west {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                let value1 = match state.south {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                let value2 = match state.north {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                let value3 = match state.east {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                Some(10651 + value0 + 2 * (!state.waterlogged() as i32) + 4 * (!state.up() as i32) + 8 * value1 + 16 * value2 + 32 * value3)
            }
            Blocks::NetherBrickWall(state) => {
                let value0 = match state.west {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                let value1 = match state.south {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                let value2 = match state.north {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                let value3 = match state.east {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                Some(10715 + value0 + 2 * (!state.waterlogged() as i32) + 4 * (!state.up() as i32) + 8 * value1 + 16 * value2 + 32 * value3)
            }
            Blocks::AndesiteWall(state) => {
                let value0 = match state.west {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                let value1 = match state.south {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                let value2 = match state.north {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                let value3 = match state.east {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                Some(10779 + value0 + 2 * (!state.waterlogged() as i32) + 4 * (!state.up() as i32) + 8 * value1 + 16 * value2 + 32 * value3)
            }
            Blocks::RedNetherBrickWall(state) => {
                let value0 = match state.west {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                let value1 = match state.south {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                let value2 = match state.north {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                let value3 = match state.east {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                Some(10843 + value0 + 2 * (!state.waterlogged() as i32) + 4 * (!state.up() as i32) + 8 * value1 + 16 * value2 + 32 * value3)
            }
            Blocks::SandstoneWall(state) => {
                let value0 = match state.west {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                let value1 = match state.south {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                let value2 = match state.north {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                let value3 = match state.east {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                Some(10907 + value0 + 2 * (!state.waterlogged() as i32) + 4 * (!state.up() as i32) + 8 * value1 + 16 * value2 + 32 * value3)
            }
            Blocks::EndStoneBrickWall(state) => {
                let value0 = match state.west {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                let value1 = match state.south {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                let value2 = match state.north {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                let value3 = match state.east {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                Some(10971 + value0 + 2 * (!state.waterlogged() as i32) + 4 * (!state.up() as i32) + 8 * value1 + 16 * value2 + 32 * value3)
            }
            Blocks::DioriteWall(state) => {
                let value0 = match state.west {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                let value1 = match state.south {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                let value2 = match state.north {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                let value3 = match state.east {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                Some(11035 + value0 + 2 * (!state.waterlogged() as i32) + 4 * (!state.up() as i32) + 8 * value1 + 16 * value2 + 32 * value3)
            }
            Blocks::Scaffolding(state) => {
                Some(11099 + (!state.waterlogged() as i32) + 2 * state.distance + 16 * (!state.bottom() as i32))
            }
            Blocks::Loom(state) => {
                Some(11131 + (state.facing as i32))
            }
            Blocks::Barrel(state) => {
                Some(11135 + (!state.open() as i32) + 2 * (state.facing as i32))
            }
            Blocks::Smoker(state) => {
                Some(11147 + (!state.lit() as i32) + 2 * (state.facing as i32))
            }
            Blocks::BlastFurnace(state) => {
                Some(11155 + (!state.lit() as i32) + 2 * (state.facing as i32))
            }
            Blocks::CartographyTable => Some(11163),
            Blocks::FletchingTable => Some(11164),
            Blocks::Grindstone(state) => {
                Some(11165 + (state.facing as i32) + 4 * (state.face as i32))
            }
            Blocks::Lectern(state) => {
                Some(11177 + (!state.powered() as i32) + 2 * (!state.has_book() as i32) + 4 * (state.facing as i32))
            }
            Blocks::SmithingTable => Some(11193),
            Blocks::Stonecutter(state) => {
                Some(11194 + (state.facing as i32))
            }
            Blocks::Bell(state) => {
                Some(11198 + (!state.powered() as i32) + 2 * (state.facing as i32) + 8 * (state.attachment as i32))
            }
            Blocks::Lantern(state) => {
                Some(11230 + (!state.hanging() as i32))
            }
            Blocks::SoulLantern(_) => None,
            Blocks::Campfire(state) => {
                Some(11232 + (!state.waterlogged() as i32) + 2 * (!state.signal_fire() as i32) + 4 * (!state.lit() as i32) + 8 * (state.facing as i32))
            }
            Blocks::SoulCampfire(_) => None,
            Blocks::SweetBerryBush(state) => {
                Some(11264 + state.age)
            }
            Blocks::WarpedStem(_) => None,
            Blocks::StrippedWarpedStem(_) => None,
            Blocks::WarpedHyphae(_) => None,
            Blocks::StrippedWarpedHyphae(_) => None,
            Blocks::WarpedNylium => None,
            Blocks::WarpedFungus => None,
            Blocks::WarpedWartBlock => None,
            Blocks::WarpedRoots => None,
            Blocks::NetherSprouts => None,
            Blocks::CrimsonStem(_) => None,
            Blocks::StrippedCrimsonStem(_) => None,
            Blocks::CrimsonHyphae(_) => None,
            Blocks::StrippedCrimsonHyphae(_) => None,
            Blocks::CrimsonNylium => None,
            Blocks::CrimsonFungus => None,
            Blocks::Shroomlight => None,
            Blocks::WeepingVines(_) => None,
            Blocks::WeepingVinesPlant => None,
            Blocks::TwistingVines(_) => None,
            Blocks::TwistingVinesPlant => None,
            Blocks::CrimsonRoots => None,
            Blocks::CrimsonPlanks => None,
            Blocks::WarpedPlanks => None,
            Blocks::CrimsonSlab(_) => None,
            Blocks::WarpedSlab(_) => None,
            Blocks::CrimsonPressurePlate(_) => None,
            Blocks::WarpedPressurePlate(_) => None,
            Blocks::CrimsonFence(_) => None,
            Blocks::WarpedFence(_) => None,
            Blocks::CrimsonTrapdoor(_) => None,
            Blocks::WarpedTrapdoor(_) => None,
            Blocks::CrimsonFenceGate(_) => None,
            Blocks::WarpedFenceGate(_) => None,
            Blocks::CrimsonStairs(_) => None,
            Blocks::WarpedStairs(_) => None,
            Blocks::CrimsonButton(_) => None,
            Blocks::WarpedButton(_) => None,
            Blocks::CrimsonDoor(_) => None,
            Blocks::WarpedDoor(_) => None,
            Blocks::CrimsonSign(_) => None,
            Blocks::WarpedSign(_) => None,
            Blocks::CrimsonWallSign(_) => None,
            Blocks::WarpedWallSign(_) => None,
            Blocks::StructureBlock(state) => {
                Some(11268 + (state.mode as i32))
            }
            Blocks::Jigsaw(_) => None,
            Blocks::Composter(state) => {
                Some(11278 + state.level)
            }
            Blocks::Target(_) => None,
            Blocks::BeeNest(state) => {
                Some(11287 + state.honey_level + 6 * (state.facing as i32))
            }
            Blocks::Beehive(state) => {
                Some(11311 + state.honey_level + 6 * (state.facing as i32))
            }
            Blocks::HoneyBlock => Some(11335),
            Blocks::HoneycombBlock => Some(11336),
            Blocks::NetheriteBlock => None,
            Blocks::AncientDebris => None,
            Blocks::CryingObsidian => None,
            Blocks::RespawnAnchor(_) => None,
            Blocks::PottedCrimsonFungus => None,
            Blocks::PottedWarpedFungus => None,
            Blocks::PottedCrimsonRoots => None,
            Blocks::PottedWarpedRoots => None,
            Blocks::Lodestone => None,
            Blocks::Blackstone => None,
            Blocks::BlackstoneStairs(_) => None,
            Blocks::BlackstoneWall(_) => None,
            Blocks::BlackstoneSlab(_) => None,
            Blocks::PolishedBlackstone => None,
            Blocks::PolishedBlackstoneBricks => None,
            Blocks::CrackedPolishedBlackstoneBricks => None,
            Blocks::ChiseledPolishedBlackstone => None,
            Blocks::PolishedBlackstoneBrickSlab(_) => None,
            Blocks::PolishedBlackstoneBrickStairs(_) => None,
            Blocks::PolishedBlackstoneBrickWall(_) => None,
            Blocks::GildedBlackstone => None,
            Blocks::PolishedBlackstoneStairs(_) => None,
            Blocks::PolishedBlackstoneSlab(_) => None,
            Blocks::PolishedBlackstonePressurePlate(_) => None,
            Blocks::PolishedBlackstoneButton(_) => None,
            Blocks::PolishedBlackstoneWall(_) => None,
            Blocks::ChiseledNetherBricks => None,
            Blocks::CrackedNetherBricks => None,
            Blocks::QuartzBricks => None,
            Blocks::Candle(_) => None,
            Blocks::WhiteCandle(_) => None,
            Blocks::OrangeCandle(_) => None,
            Blocks::MagentaCandle(_) => None,
            Blocks::LightBlueCandle(_) => None,
            Blocks::YellowCandle(_) => None,
            Blocks::LimeCandle(_) => None,
            Blocks::PinkCandle(_) => None,
            Blocks::GrayCandle(_) => None,
            Blocks::LightGrayCandle(_) => None,
            Blocks::CyanCandle(_) => None,
            Blocks::PurpleCandle(_) => None,
            Blocks::BlueCandle(_) => None,
            Blocks::BrownCandle(_) => None,
            Blocks::GreenCandle(_) => None,
            Blocks::RedCandle(_) => None,
            Blocks::BlackCandle(_) => None,
            Blocks::CandleCake(_) => None,
            Blocks::WhiteCandleCake(_) => None,
            Blocks::OrangeCandleCake(_) => None,
            Blocks::MagentaCandleCake(_) => None,
            Blocks::LightBlueCandleCake(_) => None,
            Blocks::YellowCandleCake(_) => None,
            Blocks::LimeCandleCake(_) => None,
            Blocks::PinkCandleCake(_) => None,
            Blocks::GrayCandleCake(_) => None,
            Blocks::LightGrayCandleCake(_) => None,
            Blocks::CyanCandleCake(_) => None,
            Blocks::PurpleCandleCake(_) => None,
            Blocks::BlueCandleCake(_) => None,
            Blocks::BrownCandleCake(_) => None,
            Blocks::GreenCandleCake(_) => None,
            Blocks::RedCandleCake(_) => None,
            Blocks::BlackCandleCake(_) => None,
            Blocks::AmethystBlock => None,
            Blocks::BuddingAmethyst => None,
            Blocks::AmethystCluster(_) => None,
            Blocks::LargeAmethystBud(_) => None,
            Blocks::MediumAmethystBud(_) => None,
            Blocks::SmallAmethystBud(_) => None,
            Blocks::Tuff => None,
            Blocks::Calcite => None,
            Blocks::TintedGlass => None,
            Blocks::PowderSnow => None,
            Blocks::SculkSensor(_) => None,
            Blocks::OxidizedCopper => None,
            Blocks::WeatheredCopper => None,
            Blocks::ExposedCopper => None,
            Blocks::CopperBlock => None,
            Blocks::CopperOre => None,
            Blocks::DeepslateCopperOre => None,
            Blocks::OxidizedCutCopper => None,
            Blocks::WeatheredCutCopper => None,
            Blocks::ExposedCutCopper => None,
            Blocks::CutCopper => None,
            Blocks::OxidizedCutCopperStairs(_) => None,
            Blocks::WeatheredCutCopperStairs(_) => None,
            Blocks::ExposedCutCopperStairs(_) => None,
            Blocks::CutCopperStairs(_) => None,
            Blocks::OxidizedCutCopperSlab(_) => None,
            Blocks::WeatheredCutCopperSlab(_) => None,
            Blocks::ExposedCutCopperSlab(_) => None,
            Blocks::CutCopperSlab(_) => None,
            Blocks::WaxedCopperBlock => None,
            Blocks::WaxedWeatheredCopper => None,
            Blocks::WaxedExposedCopper => None,
            Blocks::WaxedOxidizedCopper => None,
            Blocks::WaxedOxidizedCutCopper => None,
            Blocks::WaxedWeatheredCutCopper => None,
            Blocks::WaxedExposedCutCopper => None,
            Blocks::WaxedCutCopper => None,
            Blocks::WaxedOxidizedCutCopperStairs(_) => None,
            Blocks::WaxedWeatheredCutCopperStairs(_) => None,
            Blocks::WaxedExposedCutCopperStairs(_) => None,
            Blocks::WaxedCutCopperStairs(_) => None,
            Blocks::WaxedOxidizedCutCopperSlab(_) => None,
            Blocks::WaxedWeatheredCutCopperSlab(_) => None,
            Blocks::WaxedExposedCutCopperSlab(_) => None,
            Blocks::WaxedCutCopperSlab(_) => None,
            Blocks::LightningRod(_) => None,
            Blocks::PointedDripstone(_) => None,
            Blocks::DripstoneBlock => None,
            Blocks::CaveVines(_) => None,
            Blocks::CaveVinesPlant(_) => None,
            Blocks::SporeBlossom => None,
            Blocks::Azalea => None,
            Blocks::FloweringAzalea => None,
            Blocks::MossCarpet => None,
            Blocks::MossBlock => None,
            Blocks::BigDripleaf(_) => None,
            Blocks::BigDripleafStem(_) => None,
            Blocks::SmallDripleaf(_) => None,
            Blocks::HangingRoots(_) => None,
            Blocks::RootedDirt => None,
            Blocks::Deepslate(_) => None,
            Blocks::CobbledDeepslate => None,
            Blocks::CobbledDeepslateStairs(_) => None,
            Blocks::CobbledDeepslateSlab(_) => None,
            Blocks::CobbledDeepslateWall(_) => None,
            Blocks::PolishedDeepslate => None,
            Blocks::PolishedDeepslateStairs(_) => None,
            Blocks::PolishedDeepslateSlab(_) => None,
            Blocks::PolishedDeepslateWall(_) => None,
            Blocks::DeepslateTiles => None,
            Blocks::DeepslateTileStairs(_) => None,
            Blocks::DeepslateTileSlab(_) => None,
            Blocks::DeepslateTileWall(_) => None,
            Blocks::DeepslateBricks => None,
            Blocks::DeepslateBrickStairs(_) => None,
            Blocks::DeepslateBrickSlab(_) => None,
            Blocks::DeepslateBrickWall(_) => None,
            Blocks::ChiseledDeepslate => None,
            Blocks::CrackedDeepslateBricks => None,
            Blocks::CrackedDeepslateTiles => None,
            Blocks::InfestedDeepslate(_) => None,
            Blocks::SmoothBasalt => None,
            Blocks::RawIronBlock => None,
            Blocks::RawCopperBlock => None,
            Blocks::RawGoldBlock => None,
            Blocks::PottedAzaleaBush => None,
            Blocks::PottedFloweringAzaleaBush => None,
        }
    }
    pub fn get_global_id_1976(&self) -> Option<i32> {
        match self {
            Blocks::Air => Some(0),
            Blocks::Stone => Some(1),
            Blocks::Granite => Some(2),
            Blocks::PolishedGranite => Some(3),
            Blocks::Diorite => Some(4),
            Blocks::PolishedDiorite => Some(5),
            Blocks::Andesite => Some(6),
            Blocks::PolishedAndesite => Some(7),
            Blocks::GrassBlock(state) => {
                Some(8 + (!state.snowy() as i32))
            }
            Blocks::Dirt => Some(10),
            Blocks::CoarseDirt => Some(11),
            Blocks::Podzol(state) => {
                Some(12 + (!state.snowy() as i32))
            }
            Blocks::Cobblestone => Some(14),
            Blocks::OakPlanks => Some(15),
            Blocks::SprucePlanks => Some(16),
            Blocks::BirchPlanks => Some(17),
            Blocks::JunglePlanks => Some(18),
            Blocks::AcaciaPlanks => Some(19),
            Blocks::DarkOakPlanks => Some(20),
            Blocks::OakSapling(state) => {
                Some(21 + state.stage)
            }
            Blocks::SpruceSapling(state) => {
                Some(23 + state.stage)
            }
            Blocks::BirchSapling(state) => {
                Some(25 + state.stage)
            }
            Blocks::JungleSapling(state) => {
                Some(27 + state.stage)
            }
            Blocks::AcaciaSapling(state) => {
                Some(29 + state.stage)
            }
            Blocks::DarkOakSapling(state) => {
                Some(31 + state.stage)
            }
            Blocks::Bedrock => Some(33),
            Blocks::Water(state) => {
                Some(34 + state.level)
            }
            Blocks::Lava(state) => {
                Some(50 + state.level)
            }
            Blocks::Sand => Some(66),
            Blocks::RedSand => Some(67),
            Blocks::Gravel => Some(68),
            Blocks::GoldOre => Some(69),
            Blocks::DeepslateGoldOre => None,
            Blocks::IronOre => Some(70),
            Blocks::DeepslateIronOre => None,
            Blocks::CoalOre => Some(71),
            Blocks::DeepslateCoalOre => None,
            Blocks::NetherGoldOre => None,
            Blocks::OakLog(state) => {
                Some(72 + (state.axis as i32))
            }
            Blocks::SpruceLog(state) => {
                Some(75 + (state.axis as i32))
            }
            Blocks::BirchLog(state) => {
                Some(78 + (state.axis as i32))
            }
            Blocks::JungleLog(state) => {
                Some(81 + (state.axis as i32))
            }
            Blocks::AcaciaLog(state) => {
                Some(84 + (state.axis as i32))
            }
            Blocks::DarkOakLog(state) => {
                Some(87 + (state.axis as i32))
            }
            Blocks::StrippedSpruceLog(state) => {
                Some(90 + (state.axis as i32))
            }
            Blocks::StrippedBirchLog(state) => {
                Some(93 + (state.axis as i32))
            }
            Blocks::StrippedJungleLog(state) => {
                Some(96 + (state.axis as i32))
            }
            Blocks::StrippedAcaciaLog(state) => {
                Some(99 + (state.axis as i32))
            }
            Blocks::StrippedDarkOakLog(state) => {
                Some(102 + (state.axis as i32))
            }
            Blocks::StrippedOakLog(state) => {
                Some(105 + (state.axis as i32))
            }
            Blocks::OakWood(state) => {
                Some(108 + (state.axis as i32))
            }
            Blocks::SpruceWood(state) => {
                Some(111 + (state.axis as i32))
            }
            Blocks::BirchWood(state) => {
                Some(114 + (state.axis as i32))
            }
            Blocks::JungleWood(state) => {
                Some(117 + (state.axis as i32))
            }
            Blocks::AcaciaWood(state) => {
                Some(120 + (state.axis as i32))
            }
            Blocks::DarkOakWood(state) => {
                Some(123 + (state.axis as i32))
            }
            Blocks::StrippedOakWood(state) => {
                Some(126 + (state.axis as i32))
            }
            Blocks::StrippedSpruceWood(state) => {
                Some(129 + (state.axis as i32))
            }
            Blocks::StrippedBirchWood(state) => {
                Some(132 + (state.axis as i32))
            }
            Blocks::StrippedJungleWood(state) => {
                Some(135 + (state.axis as i32))
            }
            Blocks::StrippedAcaciaWood(state) => {
                Some(138 + (state.axis as i32))
            }
            Blocks::StrippedDarkOakWood(state) => {
                Some(141 + (state.axis as i32))
            }
            Blocks::OakLeaves(state) => {
                Some(144 + (!state.persistent() as i32) + 2 * state.distance)
            }
            Blocks::SpruceLeaves(state) => {
                Some(158 + (!state.persistent() as i32) + 2 * state.distance)
            }
            Blocks::BirchLeaves(state) => {
                Some(172 + (!state.persistent() as i32) + 2 * state.distance)
            }
            Blocks::JungleLeaves(state) => {
                Some(186 + (!state.persistent() as i32) + 2 * state.distance)
            }
            Blocks::AcaciaLeaves(state) => {
                Some(200 + (!state.persistent() as i32) + 2 * state.distance)
            }
            Blocks::DarkOakLeaves(state) => {
                Some(214 + (!state.persistent() as i32) + 2 * state.distance)
            }
            Blocks::AzaleaLeaves(_) => None,
            Blocks::FloweringAzaleaLeaves(_) => None,
            Blocks::Sponge => Some(228),
            Blocks::WetSponge => Some(229),
            Blocks::Glass => Some(230),
            Blocks::LapisOre => Some(231),
            Blocks::DeepslateLapisOre => None,
            Blocks::LapisBlock => Some(232),
            Blocks::Dispenser(state) => {
                Some(233 + (!state.triggered() as i32) + 2 * (state.facing as i32))
            }
            Blocks::Sandstone => Some(245),
            Blocks::ChiseledSandstone => Some(246),
            Blocks::CutSandstone => Some(247),
            Blocks::NoteBlock(state) => {
                Some(248 + (!state.powered() as i32) + 2 * state.note + 50 * (state.instrument as i32))
            }
            Blocks::WhiteBed(state) => {
                Some(1048 + (state.part as i32) + 2 * (!state.occupied() as i32) + 4 * (state.facing as i32))
            }
            Blocks::OrangeBed(state) => {
                Some(1064 + (state.part as i32) + 2 * (!state.occupied() as i32) + 4 * (state.facing as i32))
            }
            Blocks::MagentaBed(state) => {
                Some(1080 + (state.part as i32) + 2 * (!state.occupied() as i32) + 4 * (state.facing as i32))
            }
            Blocks::LightBlueBed(state) => {
                Some(1096 + (state.part as i32) + 2 * (!state.occupied() as i32) + 4 * (state.facing as i32))
            }
            Blocks::YellowBed(state) => {
                Some(1112 + (state.part as i32) + 2 * (!state.occupied() as i32) + 4 * (state.facing as i32))
            }
            Blocks::LimeBed(state) => {
                Some(1128 + (state.part as i32) + 2 * (!state.occupied() as i32) + 4 * (state.facing as i32))
            }
            Blocks::PinkBed(state) => {
                Some(1144 + (state.part as i32) + 2 * (!state.occupied() as i32) + 4 * (state.facing as i32))
            }
            Blocks::GrayBed(state) => {
                Some(1160 + (state.part as i32) + 2 * (!state.occupied() as i32) + 4 * (state.facing as i32))
            }
            Blocks::LightGrayBed(state) => {
                Some(1176 + (state.part as i32) + 2 * (!state.occupied() as i32) + 4 * (state.facing as i32))
            }
            Blocks::CyanBed(state) => {
                Some(1192 + (state.part as i32) + 2 * (!state.occupied() as i32) + 4 * (state.facing as i32))
            }
            Blocks::PurpleBed(state) => {
                Some(1208 + (state.part as i32) + 2 * (!state.occupied() as i32) + 4 * (state.facing as i32))
            }
            Blocks::BlueBed(state) => {
                Some(1224 + (state.part as i32) + 2 * (!state.occupied() as i32) + 4 * (state.facing as i32))
            }
            Blocks::BrownBed(state) => {
                Some(1240 + (state.part as i32) + 2 * (!state.occupied() as i32) + 4 * (state.facing as i32))
            }
            Blocks::GreenBed(state) => {
                Some(1256 + (state.part as i32) + 2 * (!state.occupied() as i32) + 4 * (state.facing as i32))
            }
            Blocks::RedBed(state) => {
                Some(1272 + (state.part as i32) + 2 * (!state.occupied() as i32) + 4 * (state.facing as i32))
            }
            Blocks::BlackBed(state) => {
                Some(1288 + (state.part as i32) + 2 * (!state.occupied() as i32) + 4 * (state.facing as i32))
            }
            Blocks::PoweredRail(state) => {
                Some(1304 + (state.shape as i32) + 6 * (!state.powered() as i32))
            }
            Blocks::DetectorRail(state) => {
                Some(1316 + (state.shape as i32) + 6 * (!state.powered() as i32))
            }
            Blocks::StickyPiston(state) => {
                Some(1328 + (state.facing as i32) + 6 * (!state.extended() as i32))
            }
            Blocks::Cobweb => Some(1340),
            Blocks::Grass => Some(1341),
            Blocks::Fern => Some(1342),
            Blocks::DeadBush => Some(1343),
            Blocks::Seagrass => Some(1344),
            Blocks::TallSeagrass(state) => {
                Some(1345 + (state.half as i32))
            }
            Blocks::Piston(state) => {
                Some(1347 + (state.facing as i32) + 6 * (!state.extended() as i32))
            }
            Blocks::PistonHead(state) => {
                Some(1359 + (state.typed as i32) + 2 * (!state.short() as i32) + 4 * (state.facing as i32))
            }
            Blocks::WhiteWool => Some(1383),
            Blocks::OrangeWool => Some(1384),
            Blocks::MagentaWool => Some(1385),
            Blocks::LightBlueWool => Some(1386),
            Blocks::YellowWool => Some(1387),
            Blocks::LimeWool => Some(1388),
            Blocks::PinkWool => Some(1389),
            Blocks::GrayWool => Some(1390),
            Blocks::LightGrayWool => Some(1391),
            Blocks::CyanWool => Some(1392),
            Blocks::PurpleWool => Some(1393),
            Blocks::BlueWool => Some(1394),
            Blocks::BrownWool => Some(1395),
            Blocks::GreenWool => Some(1396),
            Blocks::RedWool => Some(1397),
            Blocks::BlackWool => Some(1398),
            Blocks::MovingPiston(state) => {
                Some(1399 + (state.typed as i32) + 2 * (state.facing as i32))
            }
            Blocks::Dandelion => Some(1411),
            Blocks::Poppy => Some(1412),
            Blocks::BlueOrchid => Some(1413),
            Blocks::Allium => Some(1414),
            Blocks::AzureBluet => Some(1415),
            Blocks::RedTulip => Some(1416),
            Blocks::OrangeTulip => Some(1417),
            Blocks::WhiteTulip => Some(1418),
            Blocks::PinkTulip => Some(1419),
            Blocks::OxeyeDaisy => Some(1420),
            Blocks::Cornflower => Some(1421),
            Blocks::WitherRose => Some(1422),
            Blocks::LilyOfTheValley => Some(1423),
            Blocks::BrownMushroom => Some(1424),
            Blocks::RedMushroom => Some(1425),
            Blocks::GoldBlock => Some(1426),
            Blocks::IronBlock => Some(1427),
            Blocks::Bricks => Some(1428),
            Blocks::Tnt(state) => {
                Some(1429 + (!state.unstable() as i32))
            }
            Blocks::Bookshelf => Some(1431),
            Blocks::MossyCobblestone => Some(1432),
            Blocks::Obsidian => Some(1433),
            Blocks::Torch => Some(1434),
            Blocks::WallTorch(state) => {
                Some(1435 + (state.facing as i32))
            }
            Blocks::Fire(state) => {
                Some(1439 + (!state.west() as i32) + 2 * (!state.up() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32) + 32 * state.age)
            }
            Blocks::SoulFire => None,
            Blocks::Spawner => Some(1951),
            Blocks::OakStairs(state) => {
                Some(1952 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::Chest(state) => {
                Some(2032 + (!state.waterlogged() as i32) + 2 * (state.typed as i32) + 6 * (state.facing as i32))
            }
            Blocks::RedstoneWire(state) => {
                Some(2056 + (state.west as i32) + 3 * (state.south as i32) + 9 * state.power + 144 * (state.north as i32) + 432 * (state.east as i32))
            }
            Blocks::DiamondOre => Some(3352),
            Blocks::DeepslateDiamondOre => None,
            Blocks::DiamondBlock => Some(3353),
            Blocks::CraftingTable => Some(3354),
            Blocks::Wheat(state) => {
                Some(3355 + state.age)
            }
            Blocks::Farmland(state) => {
                Some(3363 + state.moisture)
            }
            Blocks::Furnace(state) => {
                Some(3371 + (!state.lit() as i32) + 2 * (state.facing as i32))
            }
            Blocks::OakSign(state) => {
                Some(3379 + (!state.waterlogged() as i32) + 2 * state.rotation)
            }
            Blocks::SpruceSign(state) => {
                Some(3411 + (!state.waterlogged() as i32) + 2 * state.rotation)
            }
            Blocks::BirchSign(state) => {
                Some(3443 + (!state.waterlogged() as i32) + 2 * state.rotation)
            }
            Blocks::AcaciaSign(state) => {
                Some(3475 + (!state.waterlogged() as i32) + 2 * state.rotation)
            }
            Blocks::JungleSign(state) => {
                Some(3507 + (!state.waterlogged() as i32) + 2 * state.rotation)
            }
            Blocks::DarkOakSign(state) => {
                Some(3539 + (!state.waterlogged() as i32) + 2 * state.rotation)
            }
            Blocks::OakDoor(state) => {
                Some(3571 + (!state.powered() as i32) + 2 * (!state.open() as i32) + 4 * (state.hinge as i32) + 8 * (state.half as i32) + 16 * (state.facing as i32))
            }
            Blocks::Ladder(state) => {
                Some(3635 + (!state.waterlogged() as i32) + 2 * (state.facing as i32))
            }
            Blocks::Rail(state) => {
                Some(3643 + (state.shape as i32))
            }
            Blocks::CobblestoneStairs(state) => {
                Some(3653 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::OakWallSign(state) => {
                Some(3733 + (!state.waterlogged() as i32) + 2 * (state.facing as i32))
            }
            Blocks::SpruceWallSign(state) => {
                Some(3741 + (!state.waterlogged() as i32) + 2 * (state.facing as i32))
            }
            Blocks::BirchWallSign(state) => {
                Some(3749 + (!state.waterlogged() as i32) + 2 * (state.facing as i32))
            }
            Blocks::AcaciaWallSign(state) => {
                Some(3757 + (!state.waterlogged() as i32) + 2 * (state.facing as i32))
            }
            Blocks::JungleWallSign(state) => {
                Some(3765 + (!state.waterlogged() as i32) + 2 * (state.facing as i32))
            }
            Blocks::DarkOakWallSign(state) => {
                Some(3773 + (!state.waterlogged() as i32) + 2 * (state.facing as i32))
            }
            Blocks::Lever(state) => {
                Some(3781 + (!state.powered() as i32) + 2 * (state.facing as i32) + 8 * (state.face as i32))
            }
            Blocks::StonePressurePlate(state) => {
                Some(3805 + (!state.powered() as i32))
            }
            Blocks::IronDoor(state) => {
                Some(3807 + (!state.powered() as i32) + 2 * (!state.open() as i32) + 4 * (state.hinge as i32) + 8 * (state.half as i32) + 16 * (state.facing as i32))
            }
            Blocks::OakPressurePlate(state) => {
                Some(3871 + (!state.powered() as i32))
            }
            Blocks::SprucePressurePlate(state) => {
                Some(3873 + (!state.powered() as i32))
            }
            Blocks::BirchPressurePlate(state) => {
                Some(3875 + (!state.powered() as i32))
            }
            Blocks::JunglePressurePlate(state) => {
                Some(3877 + (!state.powered() as i32))
            }
            Blocks::AcaciaPressurePlate(state) => {
                Some(3879 + (!state.powered() as i32))
            }
            Blocks::DarkOakPressurePlate(state) => {
                Some(3881 + (!state.powered() as i32))
            }
            Blocks::RedstoneOre(state) => {
                Some(3883 + (!state.lit() as i32))
            }
            Blocks::DeepslateRedstoneOre(_) => None,
            Blocks::RedstoneTorch(state) => {
                Some(3885 + (!state.lit() as i32))
            }
            Blocks::RedstoneWallTorch(state) => {
                Some(3887 + (!state.lit() as i32) + 2 * (state.facing as i32))
            }
            Blocks::StoneButton(state) => {
                Some(3895 + (!state.powered() as i32) + 2 * (state.facing as i32) + 8 * (state.face as i32))
            }
            Blocks::Snow(state) => {
                Some(3919 + state.layers)
            }
            Blocks::Ice => Some(3927),
            Blocks::SnowBlock => Some(3928),
            Blocks::Cactus(state) => {
                Some(3929 + state.age)
            }
            Blocks::Clay => Some(3945),
            Blocks::SugarCane(state) => {
                Some(3946 + state.age)
            }
            Blocks::Jukebox(state) => {
                Some(3962 + (!state.has_record() as i32))
            }
            Blocks::OakFence(state) => {
                Some(3964 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::Pumpkin => Some(3996),
            Blocks::Netherrack => Some(3997),
            Blocks::SoulSand => Some(3998),
            Blocks::SoulSoil => None,
            Blocks::Basalt(_) => None,
            Blocks::PolishedBasalt(_) => None,
            Blocks::SoulTorch => None,
            Blocks::SoulWallTorch(_) => None,
            Blocks::Glowstone => Some(3999),
            Blocks::NetherPortal(state) => {
                Some(4000 + (state.axis as i32))
            }
            Blocks::CarvedPumpkin(state) => {
                Some(4002 + (state.facing as i32))
            }
            Blocks::JackOLantern(state) => {
                Some(4006 + (state.facing as i32))
            }
            Blocks::Cake(state) => {
                Some(4010 + state.bites)
            }
            Blocks::Repeater(state) => {
                Some(4017 + (!state.powered() as i32) + 2 * (!state.locked() as i32) + 4 * (state.facing as i32) + 16 * state.delay)
            }
            Blocks::WhiteStainedGlass => Some(4081),
            Blocks::OrangeStainedGlass => Some(4082),
            Blocks::MagentaStainedGlass => Some(4083),
            Blocks::LightBlueStainedGlass => Some(4084),
            Blocks::YellowStainedGlass => Some(4085),
            Blocks::LimeStainedGlass => Some(4086),
            Blocks::PinkStainedGlass => Some(4087),
            Blocks::GrayStainedGlass => Some(4088),
            Blocks::LightGrayStainedGlass => Some(4089),
            Blocks::CyanStainedGlass => Some(4090),
            Blocks::PurpleStainedGlass => Some(4091),
            Blocks::BlueStainedGlass => Some(4092),
            Blocks::BrownStainedGlass => Some(4093),
            Blocks::GreenStainedGlass => Some(4094),
            Blocks::RedStainedGlass => Some(4095),
            Blocks::BlackStainedGlass => Some(4096),
            Blocks::OakTrapdoor(state) => {
                Some(4097 + (!state.waterlogged() as i32) + 2 * (!state.powered() as i32) + 4 * (!state.open() as i32) + 8 * (state.half as i32) + 16 * (state.facing as i32))
            }
            Blocks::SpruceTrapdoor(state) => {
                Some(4161 + (!state.waterlogged() as i32) + 2 * (!state.powered() as i32) + 4 * (!state.open() as i32) + 8 * (state.half as i32) + 16 * (state.facing as i32))
            }
            Blocks::BirchTrapdoor(state) => {
                Some(4225 + (!state.waterlogged() as i32) + 2 * (!state.powered() as i32) + 4 * (!state.open() as i32) + 8 * (state.half as i32) + 16 * (state.facing as i32))
            }
            Blocks::JungleTrapdoor(state) => {
                Some(4289 + (!state.waterlogged() as i32) + 2 * (!state.powered() as i32) + 4 * (!state.open() as i32) + 8 * (state.half as i32) + 16 * (state.facing as i32))
            }
            Blocks::AcaciaTrapdoor(state) => {
                Some(4353 + (!state.waterlogged() as i32) + 2 * (!state.powered() as i32) + 4 * (!state.open() as i32) + 8 * (state.half as i32) + 16 * (state.facing as i32))
            }
            Blocks::DarkOakTrapdoor(state) => {
                Some(4417 + (!state.waterlogged() as i32) + 2 * (!state.powered() as i32) + 4 * (!state.open() as i32) + 8 * (state.half as i32) + 16 * (state.facing as i32))
            }
            Blocks::StoneBricks => Some(4481),
            Blocks::MossyStoneBricks => Some(4482),
            Blocks::CrackedStoneBricks => Some(4483),
            Blocks::ChiseledStoneBricks => Some(4484),
            Blocks::InfestedStone => Some(4485),
            Blocks::InfestedCobblestone => Some(4486),
            Blocks::InfestedStoneBricks => Some(4487),
            Blocks::InfestedMossyStoneBricks => Some(4488),
            Blocks::InfestedCrackedStoneBricks => Some(4489),
            Blocks::InfestedChiseledStoneBricks => Some(4490),
            Blocks::BrownMushroomBlock(state) => {
                Some(4491 + (!state.west() as i32) + 2 * (!state.up() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32) + 32 * (!state.down() as i32))
            }
            Blocks::RedMushroomBlock(state) => {
                Some(4555 + (!state.west() as i32) + 2 * (!state.up() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32) + 32 * (!state.down() as i32))
            }
            Blocks::MushroomStem(state) => {
                Some(4619 + (!state.west() as i32) + 2 * (!state.up() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32) + 32 * (!state.down() as i32))
            }
            Blocks::IronBars(state) => {
                Some(4683 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::Chain(_) => None,
            Blocks::GlassPane(state) => {
                Some(4715 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::Melon => Some(4747),
            Blocks::AttachedPumpkinStem(state) => {
                Some(4748 + (state.facing as i32))
            }
            Blocks::AttachedMelonStem(state) => {
                Some(4752 + (state.facing as i32))
            }
            Blocks::PumpkinStem(state) => {
                Some(4756 + state.age)
            }
            Blocks::MelonStem(state) => {
                Some(4764 + state.age)
            }
            Blocks::Vine(state) => {
                Some(4772 + (!state.west() as i32) + 2 * (!state.up() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::GlowLichen(_) => None,
            Blocks::OakFenceGate(state) => {
                Some(4804 + (!state.powered() as i32) + 2 * (!state.open() as i32) + 4 * (!state.in_wall() as i32) + 8 * (state.facing as i32))
            }
            Blocks::BrickStairs(state) => {
                Some(4836 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::StoneBrickStairs(state) => {
                Some(4916 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::Mycelium(state) => {
                Some(4996 + (!state.snowy() as i32))
            }
            Blocks::LilyPad => Some(4998),
            Blocks::NetherBricks => Some(4999),
            Blocks::NetherBrickFence(state) => {
                Some(5000 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::NetherBrickStairs(state) => {
                Some(5032 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::NetherWart(state) => {
                Some(5112 + state.age)
            }
            Blocks::EnchantingTable => Some(5116),
            Blocks::BrewingStand(state) => {
                Some(5117 + (!state.has_bottle_2() as i32) + 2 * (!state.has_bottle_1() as i32) + 4 * (!state.has_bottle_0() as i32))
            }
            Blocks::Cauldron => Some(5125),
            Blocks::WaterCauldron(state) => {
                Some(5126 + state.level)
            }
            Blocks::LavaCauldron => None,
            Blocks::PowderSnowCauldron(_) => None,
            Blocks::EndPortal => Some(5129),
            Blocks::EndPortalFrame(state) => {
                Some(5130 + (state.facing as i32) + 4 * (!state.eye() as i32))
            }
            Blocks::EndStone => Some(5138),
            Blocks::DragonEgg => Some(5139),
            Blocks::RedstoneLamp(state) => {
                Some(5140 + (!state.lit() as i32))
            }
            Blocks::Cocoa(state) => {
                Some(5142 + (state.facing as i32) + 4 * state.age)
            }
            Blocks::SandstoneStairs(state) => {
                Some(5154 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::EmeraldOre => Some(5234),
            Blocks::DeepslateEmeraldOre => None,
            Blocks::EnderChest(state) => {
                Some(5235 + (!state.waterlogged() as i32) + 2 * (state.facing as i32))
            }
            Blocks::TripwireHook(state) => {
                Some(5243 + (!state.powered() as i32) + 2 * (state.facing as i32) + 8 * (!state.attached() as i32))
            }
            Blocks::Tripwire(state) => {
                Some(5259 + (!state.west() as i32) + 2 * (!state.south() as i32) + 4 * (!state.powered() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32) + 32 * (!state.disarmed() as i32) + 64 * (!state.attached() as i32))
            }
            Blocks::EmeraldBlock => Some(5387),
            Blocks::SpruceStairs(state) => {
                Some(5388 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::BirchStairs(state) => {
                Some(5468 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::JungleStairs(state) => {
                Some(5548 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::CommandBlock(state) => {
                Some(5628 + (state.facing as i32) + 6 * (!state.conditional() as i32))
            }
            Blocks::Beacon => Some(5640),
            Blocks::CobblestoneWall(state) => {
                let value0 = match state.west {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                let value1 = match state.south {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                let value2 = match state.north {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                let value3 = match state.east {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                Some(5641 + value0 + 2 * (!state.waterlogged() as i32) + 4 * (!state.up() as i32) + 8 * value1 + 16 * value2 + 32 * value3)
            }
            Blocks::MossyCobblestoneWall(state) => {
                let value0 = match state.west {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                let value1 = match state.south {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                let value2 = match state.north {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                let value3 = match state.east {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                Some(5705 + value0 + 2 * (!state.waterlogged() as i32) + 4 * (!state.up() as i32) + 8 * value1 + 16 * value2 + 32 * value3)
            }
            Blocks::FlowerPot => Some(5769),
            Blocks::PottedOakSapling => Some(5770),
            Blocks::PottedSpruceSapling => Some(5771),
            Blocks::PottedBirchSapling => Some(5772),
            Blocks::PottedJungleSapling => Some(5773),
            Blocks::PottedAcaciaSapling => Some(5774),
            Blocks::PottedDarkOakSapling => Some(5775),
            Blocks::PottedFern => Some(5776),
            Blocks::PottedDandelion => Some(5777),
            Blocks::PottedPoppy => Some(5778),
            Blocks::PottedBlueOrchid => Some(5779),
            Blocks::PottedAllium => Some(5780),
            Blocks::PottedAzureBluet => Some(5781),
            Blocks::PottedRedTulip => Some(5782),
            Blocks::PottedOrangeTulip => Some(5783),
            Blocks::PottedWhiteTulip => Some(5784),
            Blocks::PottedPinkTulip => Some(5785),
            Blocks::PottedOxeyeDaisy => Some(5786),
            Blocks::PottedCornflower => Some(5787),
            Blocks::PottedLilyOfTheValley => Some(5788),
            Blocks::PottedWitherRose => Some(5789),
            Blocks::PottedRedMushroom => Some(5790),
            Blocks::PottedBrownMushroom => Some(5791),
            Blocks::PottedDeadBush => Some(5792),
            Blocks::PottedCactus => Some(5793),
            Blocks::Carrots(state) => {
                Some(5794 + state.age)
            }
            Blocks::Potatoes(state) => {
                Some(5802 + state.age)
            }
            Blocks::OakButton(state) => {
                Some(5810 + (!state.powered() as i32) + 2 * (state.facing as i32) + 8 * (state.face as i32))
            }
            Blocks::SpruceButton(state) => {
                Some(5834 + (!state.powered() as i32) + 2 * (state.facing as i32) + 8 * (state.face as i32))
            }
            Blocks::BirchButton(state) => {
                Some(5858 + (!state.powered() as i32) + 2 * (state.facing as i32) + 8 * (state.face as i32))
            }
            Blocks::JungleButton(state) => {
                Some(5882 + (!state.powered() as i32) + 2 * (state.facing as i32) + 8 * (state.face as i32))
            }
            Blocks::AcaciaButton(state) => {
                Some(5906 + (!state.powered() as i32) + 2 * (state.facing as i32) + 8 * (state.face as i32))
            }
            Blocks::DarkOakButton(state) => {
                Some(5930 + (!state.powered() as i32) + 2 * (state.facing as i32) + 8 * (state.face as i32))
            }
            Blocks::SkeletonSkull(state) => {
                Some(5954 + state.rotation)
            }
            Blocks::SkeletonWallSkull(state) => {
                Some(5970 + (state.facing as i32))
            }
            Blocks::WitherSkeletonSkull(state) => {
                Some(5974 + state.rotation)
            }
            Blocks::WitherSkeletonWallSkull(state) => {
                Some(5990 + (state.facing as i32))
            }
            Blocks::ZombieHead(state) => {
                Some(5994 + state.rotation)
            }
            Blocks::ZombieWallHead(state) => {
                Some(6010 + (state.facing as i32))
            }
            Blocks::PlayerHead(state) => {
                Some(6014 + state.rotation)
            }
            Blocks::PlayerWallHead(state) => {
                Some(6030 + (state.facing as i32))
            }
            Blocks::CreeperHead(state) => {
                Some(6034 + state.rotation)
            }
            Blocks::CreeperWallHead(state) => {
                Some(6050 + (state.facing as i32))
            }
            Blocks::DragonHead(state) => {
                Some(6054 + state.rotation)
            }
            Blocks::DragonWallHead(state) => {
                Some(6070 + (state.facing as i32))
            }
            Blocks::Anvil(state) => {
                Some(6074 + (state.facing as i32))
            }
            Blocks::ChippedAnvil(state) => {
                Some(6078 + (state.facing as i32))
            }
            Blocks::DamagedAnvil(state) => {
                Some(6082 + (state.facing as i32))
            }
            Blocks::TrappedChest(state) => {
                Some(6086 + (!state.waterlogged() as i32) + 2 * (state.typed as i32) + 6 * (state.facing as i32))
            }
            Blocks::LightWeightedPressurePlate(state) => {
                Some(6110 + state.power)
            }
            Blocks::HeavyWeightedPressurePlate(state) => {
                Some(6126 + state.power)
            }
            Blocks::Comparator(state) => {
                Some(6142 + (!state.powered() as i32) + 2 * (state.mode as i32) + 4 * (state.facing as i32))
            }
            Blocks::DaylightDetector(state) => {
                Some(6158 + state.power + 16 * (!state.inverted() as i32))
            }
            Blocks::RedstoneBlock => Some(6190),
            Blocks::NetherQuartzOre => Some(6191),
            Blocks::Hopper(state) => {
                Some(6192 + (state.facing as i32) + 5 * (!state.enabled() as i32))
            }
            Blocks::QuartzBlock => Some(6202),
            Blocks::ChiseledQuartzBlock => Some(6203),
            Blocks::QuartzPillar(state) => {
                Some(6204 + (state.axis as i32))
            }
            Blocks::QuartzStairs(state) => {
                Some(6207 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::ActivatorRail(state) => {
                Some(6287 + (state.shape as i32) + 6 * (!state.powered() as i32))
            }
            Blocks::Dropper(state) => {
                Some(6299 + (!state.triggered() as i32) + 2 * (state.facing as i32))
            }
            Blocks::WhiteTerracotta => Some(6311),
            Blocks::OrangeTerracotta => Some(6312),
            Blocks::MagentaTerracotta => Some(6313),
            Blocks::LightBlueTerracotta => Some(6314),
            Blocks::YellowTerracotta => Some(6315),
            Blocks::LimeTerracotta => Some(6316),
            Blocks::PinkTerracotta => Some(6317),
            Blocks::GrayTerracotta => Some(6318),
            Blocks::LightGrayTerracotta => Some(6319),
            Blocks::CyanTerracotta => Some(6320),
            Blocks::PurpleTerracotta => Some(6321),
            Blocks::BlueTerracotta => Some(6322),
            Blocks::BrownTerracotta => Some(6323),
            Blocks::GreenTerracotta => Some(6324),
            Blocks::RedTerracotta => Some(6325),
            Blocks::BlackTerracotta => Some(6326),
            Blocks::WhiteStainedGlassPane(state) => {
                Some(6327 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::OrangeStainedGlassPane(state) => {
                Some(6359 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::MagentaStainedGlassPane(state) => {
                Some(6391 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::LightBlueStainedGlassPane(state) => {
                Some(6423 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::YellowStainedGlassPane(state) => {
                Some(6455 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::LimeStainedGlassPane(state) => {
                Some(6487 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::PinkStainedGlassPane(state) => {
                Some(6519 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::GrayStainedGlassPane(state) => {
                Some(6551 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::LightGrayStainedGlassPane(state) => {
                Some(6583 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::CyanStainedGlassPane(state) => {
                Some(6615 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::PurpleStainedGlassPane(state) => {
                Some(6647 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::BlueStainedGlassPane(state) => {
                Some(6679 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::BrownStainedGlassPane(state) => {
                Some(6711 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::GreenStainedGlassPane(state) => {
                Some(6743 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::RedStainedGlassPane(state) => {
                Some(6775 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::BlackStainedGlassPane(state) => {
                Some(6807 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::AcaciaStairs(state) => {
                Some(6839 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::DarkOakStairs(state) => {
                Some(6919 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::SlimeBlock => Some(6999),
            Blocks::Barrier => Some(7000),
            Blocks::Light(_) => None,
            Blocks::IronTrapdoor(state) => {
                Some(7001 + (!state.waterlogged() as i32) + 2 * (!state.powered() as i32) + 4 * (!state.open() as i32) + 8 * (state.half as i32) + 16 * (state.facing as i32))
            }
            Blocks::Prismarine => Some(7065),
            Blocks::PrismarineBricks => Some(7066),
            Blocks::DarkPrismarine => Some(7067),
            Blocks::PrismarineStairs(state) => {
                Some(7068 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::PrismarineBrickStairs(state) => {
                Some(7148 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::DarkPrismarineStairs(state) => {
                Some(7228 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::PrismarineSlab(state) => {
                Some(7308 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::PrismarineBrickSlab(state) => {
                Some(7314 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::DarkPrismarineSlab(state) => {
                Some(7320 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::SeaLantern => Some(7326),
            Blocks::HayBlock(state) => {
                Some(7327 + (state.axis as i32))
            }
            Blocks::WhiteCarpet => Some(7330),
            Blocks::OrangeCarpet => Some(7331),
            Blocks::MagentaCarpet => Some(7332),
            Blocks::LightBlueCarpet => Some(7333),
            Blocks::YellowCarpet => Some(7334),
            Blocks::LimeCarpet => Some(7335),
            Blocks::PinkCarpet => Some(7336),
            Blocks::GrayCarpet => Some(7337),
            Blocks::LightGrayCarpet => Some(7338),
            Blocks::CyanCarpet => Some(7339),
            Blocks::PurpleCarpet => Some(7340),
            Blocks::BlueCarpet => Some(7341),
            Blocks::BrownCarpet => Some(7342),
            Blocks::GreenCarpet => Some(7343),
            Blocks::RedCarpet => Some(7344),
            Blocks::BlackCarpet => Some(7345),
            Blocks::Terracotta => Some(7346),
            Blocks::CoalBlock => Some(7347),
            Blocks::PackedIce => Some(7348),
            Blocks::Sunflower(state) => {
                Some(7349 + (state.half as i32))
            }
            Blocks::Lilac(state) => {
                Some(7351 + (state.half as i32))
            }
            Blocks::RoseBush(state) => {
                Some(7353 + (state.half as i32))
            }
            Blocks::Peony(state) => {
                Some(7355 + (state.half as i32))
            }
            Blocks::TallGrass(state) => {
                Some(7357 + (state.half as i32))
            }
            Blocks::LargeFern(state) => {
                Some(7359 + (state.half as i32))
            }
            Blocks::WhiteBanner(state) => {
                Some(7361 + state.rotation)
            }
            Blocks::OrangeBanner(state) => {
                Some(7377 + state.rotation)
            }
            Blocks::MagentaBanner(state) => {
                Some(7393 + state.rotation)
            }
            Blocks::LightBlueBanner(state) => {
                Some(7409 + state.rotation)
            }
            Blocks::YellowBanner(state) => {
                Some(7425 + state.rotation)
            }
            Blocks::LimeBanner(state) => {
                Some(7441 + state.rotation)
            }
            Blocks::PinkBanner(state) => {
                Some(7457 + state.rotation)
            }
            Blocks::GrayBanner(state) => {
                Some(7473 + state.rotation)
            }
            Blocks::LightGrayBanner(state) => {
                Some(7489 + state.rotation)
            }
            Blocks::CyanBanner(state) => {
                Some(7505 + state.rotation)
            }
            Blocks::PurpleBanner(state) => {
                Some(7521 + state.rotation)
            }
            Blocks::BlueBanner(state) => {
                Some(7537 + state.rotation)
            }
            Blocks::BrownBanner(state) => {
                Some(7553 + state.rotation)
            }
            Blocks::GreenBanner(state) => {
                Some(7569 + state.rotation)
            }
            Blocks::RedBanner(state) => {
                Some(7585 + state.rotation)
            }
            Blocks::BlackBanner(state) => {
                Some(7601 + state.rotation)
            }
            Blocks::WhiteWallBanner(state) => {
                Some(7617 + (state.facing as i32))
            }
            Blocks::OrangeWallBanner(state) => {
                Some(7621 + (state.facing as i32))
            }
            Blocks::MagentaWallBanner(state) => {
                Some(7625 + (state.facing as i32))
            }
            Blocks::LightBlueWallBanner(state) => {
                Some(7629 + (state.facing as i32))
            }
            Blocks::YellowWallBanner(state) => {
                Some(7633 + (state.facing as i32))
            }
            Blocks::LimeWallBanner(state) => {
                Some(7637 + (state.facing as i32))
            }
            Blocks::PinkWallBanner(state) => {
                Some(7641 + (state.facing as i32))
            }
            Blocks::GrayWallBanner(state) => {
                Some(7645 + (state.facing as i32))
            }
            Blocks::LightGrayWallBanner(state) => {
                Some(7649 + (state.facing as i32))
            }
            Blocks::CyanWallBanner(state) => {
                Some(7653 + (state.facing as i32))
            }
            Blocks::PurpleWallBanner(state) => {
                Some(7657 + (state.facing as i32))
            }
            Blocks::BlueWallBanner(state) => {
                Some(7661 + (state.facing as i32))
            }
            Blocks::BrownWallBanner(state) => {
                Some(7665 + (state.facing as i32))
            }
            Blocks::GreenWallBanner(state) => {
                Some(7669 + (state.facing as i32))
            }
            Blocks::RedWallBanner(state) => {
                Some(7673 + (state.facing as i32))
            }
            Blocks::BlackWallBanner(state) => {
                Some(7677 + (state.facing as i32))
            }
            Blocks::RedSandstone => Some(7681),
            Blocks::ChiseledRedSandstone => Some(7682),
            Blocks::CutRedSandstone => Some(7683),
            Blocks::RedSandstoneStairs(state) => {
                Some(7684 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::OakSlab(state) => {
                Some(7764 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::SpruceSlab(state) => {
                Some(7770 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::BirchSlab(state) => {
                Some(7776 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::JungleSlab(state) => {
                Some(7782 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::AcaciaSlab(state) => {
                Some(7788 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::DarkOakSlab(state) => {
                Some(7794 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::StoneSlab(state) => {
                Some(7800 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::SmoothStoneSlab(state) => {
                Some(7806 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::SandstoneSlab(state) => {
                Some(7812 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::CutSandstoneSlab(state) => {
                Some(7818 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::PetrifiedOakSlab(state) => {
                Some(7824 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::CobblestoneSlab(state) => {
                Some(7830 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::BrickSlab(state) => {
                Some(7836 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::StoneBrickSlab(state) => {
                Some(7842 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::NetherBrickSlab(state) => {
                Some(7848 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::QuartzSlab(state) => {
                Some(7854 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::RedSandstoneSlab(state) => {
                Some(7860 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::CutRedSandstoneSlab(state) => {
                Some(7866 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::PurpurSlab(state) => {
                Some(7872 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::SmoothStone => Some(7878),
            Blocks::SmoothSandstone => Some(7879),
            Blocks::SmoothQuartz => Some(7880),
            Blocks::SmoothRedSandstone => Some(7881),
            Blocks::SpruceFenceGate(state) => {
                Some(7882 + (!state.powered() as i32) + 2 * (!state.open() as i32) + 4 * (!state.in_wall() as i32) + 8 * (state.facing as i32))
            }
            Blocks::BirchFenceGate(state) => {
                Some(7914 + (!state.powered() as i32) + 2 * (!state.open() as i32) + 4 * (!state.in_wall() as i32) + 8 * (state.facing as i32))
            }
            Blocks::JungleFenceGate(state) => {
                Some(7946 + (!state.powered() as i32) + 2 * (!state.open() as i32) + 4 * (!state.in_wall() as i32) + 8 * (state.facing as i32))
            }
            Blocks::AcaciaFenceGate(state) => {
                Some(7978 + (!state.powered() as i32) + 2 * (!state.open() as i32) + 4 * (!state.in_wall() as i32) + 8 * (state.facing as i32))
            }
            Blocks::DarkOakFenceGate(state) => {
                Some(8010 + (!state.powered() as i32) + 2 * (!state.open() as i32) + 4 * (!state.in_wall() as i32) + 8 * (state.facing as i32))
            }
            Blocks::SpruceFence(state) => {
                Some(8042 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::BirchFence(state) => {
                Some(8074 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::JungleFence(state) => {
                Some(8106 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::AcaciaFence(state) => {
                Some(8138 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::DarkOakFence(state) => {
                Some(8170 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::SpruceDoor(state) => {
                Some(8202 + (!state.powered() as i32) + 2 * (!state.open() as i32) + 4 * (state.hinge as i32) + 8 * (state.half as i32) + 16 * (state.facing as i32))
            }
            Blocks::BirchDoor(state) => {
                Some(8266 + (!state.powered() as i32) + 2 * (!state.open() as i32) + 4 * (state.hinge as i32) + 8 * (state.half as i32) + 16 * (state.facing as i32))
            }
            Blocks::JungleDoor(state) => {
                Some(8330 + (!state.powered() as i32) + 2 * (!state.open() as i32) + 4 * (state.hinge as i32) + 8 * (state.half as i32) + 16 * (state.facing as i32))
            }
            Blocks::AcaciaDoor(state) => {
                Some(8394 + (!state.powered() as i32) + 2 * (!state.open() as i32) + 4 * (state.hinge as i32) + 8 * (state.half as i32) + 16 * (state.facing as i32))
            }
            Blocks::DarkOakDoor(state) => {
                Some(8458 + (!state.powered() as i32) + 2 * (!state.open() as i32) + 4 * (state.hinge as i32) + 8 * (state.half as i32) + 16 * (state.facing as i32))
            }
            Blocks::EndRod(state) => {
                Some(8522 + (state.facing as i32))
            }
            Blocks::ChorusPlant(state) => {
                Some(8528 + (!state.west() as i32) + 2 * (!state.up() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32) + 32 * (!state.down() as i32))
            }
            Blocks::ChorusFlower(state) => {
                Some(8592 + state.age)
            }
            Blocks::PurpurBlock => Some(8598),
            Blocks::PurpurPillar(state) => {
                Some(8599 + (state.axis as i32))
            }
            Blocks::PurpurStairs(state) => {
                Some(8602 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::EndStoneBricks => Some(8682),
            Blocks::Beetroots(state) => {
                Some(8683 + state.age)
            }
            Blocks::DirtPath => Some(8687),
            Blocks::EndGateway => Some(8688),
            Blocks::RepeatingCommandBlock(state) => {
                Some(8689 + (state.facing as i32) + 6 * (!state.conditional() as i32))
            }
            Blocks::ChainCommandBlock(state) => {
                Some(8701 + (state.facing as i32) + 6 * (!state.conditional() as i32))
            }
            Blocks::FrostedIce(state) => {
                Some(8713 + state.age)
            }
            Blocks::MagmaBlock => Some(8717),
            Blocks::NetherWartBlock => Some(8718),
            Blocks::RedNetherBricks => Some(8719),
            Blocks::BoneBlock(state) => {
                Some(8720 + (state.axis as i32))
            }
            Blocks::StructureVoid => Some(8723),
            Blocks::Observer(state) => {
                Some(8724 + (!state.powered() as i32) + 2 * (state.facing as i32))
            }
            Blocks::ShulkerBox(state) => {
                Some(8736 + (state.facing as i32))
            }
            Blocks::WhiteShulkerBox(state) => {
                Some(8742 + (state.facing as i32))
            }
            Blocks::OrangeShulkerBox(state) => {
                Some(8748 + (state.facing as i32))
            }
            Blocks::MagentaShulkerBox(state) => {
                Some(8754 + (state.facing as i32))
            }
            Blocks::LightBlueShulkerBox(state) => {
                Some(8760 + (state.facing as i32))
            }
            Blocks::YellowShulkerBox(state) => {
                Some(8766 + (state.facing as i32))
            }
            Blocks::LimeShulkerBox(state) => {
                Some(8772 + (state.facing as i32))
            }
            Blocks::PinkShulkerBox(state) => {
                Some(8778 + (state.facing as i32))
            }
            Blocks::GrayShulkerBox(state) => {
                Some(8784 + (state.facing as i32))
            }
            Blocks::LightGrayShulkerBox(state) => {
                Some(8790 + (state.facing as i32))
            }
            Blocks::CyanShulkerBox(state) => {
                Some(8796 + (state.facing as i32))
            }
            Blocks::PurpleShulkerBox(state) => {
                Some(8802 + (state.facing as i32))
            }
            Blocks::BlueShulkerBox(state) => {
                Some(8808 + (state.facing as i32))
            }
            Blocks::BrownShulkerBox(state) => {
                Some(8814 + (state.facing as i32))
            }
            Blocks::GreenShulkerBox(state) => {
                Some(8820 + (state.facing as i32))
            }
            Blocks::RedShulkerBox(state) => {
                Some(8826 + (state.facing as i32))
            }
            Blocks::BlackShulkerBox(state) => {
                Some(8832 + (state.facing as i32))
            }
            Blocks::WhiteGlazedTerracotta(state) => {
                Some(8838 + (state.facing as i32))
            }
            Blocks::OrangeGlazedTerracotta(state) => {
                Some(8842 + (state.facing as i32))
            }
            Blocks::MagentaGlazedTerracotta(state) => {
                Some(8846 + (state.facing as i32))
            }
            Blocks::LightBlueGlazedTerracotta(state) => {
                Some(8850 + (state.facing as i32))
            }
            Blocks::YellowGlazedTerracotta(state) => {
                Some(8854 + (state.facing as i32))
            }
            Blocks::LimeGlazedTerracotta(state) => {
                Some(8858 + (state.facing as i32))
            }
            Blocks::PinkGlazedTerracotta(state) => {
                Some(8862 + (state.facing as i32))
            }
            Blocks::GrayGlazedTerracotta(state) => {
                Some(8866 + (state.facing as i32))
            }
            Blocks::LightGrayGlazedTerracotta(state) => {
                Some(8870 + (state.facing as i32))
            }
            Blocks::CyanGlazedTerracotta(state) => {
                Some(8874 + (state.facing as i32))
            }
            Blocks::PurpleGlazedTerracotta(state) => {
                Some(8878 + (state.facing as i32))
            }
            Blocks::BlueGlazedTerracotta(state) => {
                Some(8882 + (state.facing as i32))
            }
            Blocks::BrownGlazedTerracotta(state) => {
                Some(8886 + (state.facing as i32))
            }
            Blocks::GreenGlazedTerracotta(state) => {
                Some(8890 + (state.facing as i32))
            }
            Blocks::RedGlazedTerracotta(state) => {
                Some(8894 + (state.facing as i32))
            }
            Blocks::BlackGlazedTerracotta(state) => {
                Some(8898 + (state.facing as i32))
            }
            Blocks::WhiteConcrete => Some(8902),
            Blocks::OrangeConcrete => Some(8903),
            Blocks::MagentaConcrete => Some(8904),
            Blocks::LightBlueConcrete => Some(8905),
            Blocks::YellowConcrete => Some(8906),
            Blocks::LimeConcrete => Some(8907),
            Blocks::PinkConcrete => Some(8908),
            Blocks::GrayConcrete => Some(8909),
            Blocks::LightGrayConcrete => Some(8910),
            Blocks::CyanConcrete => Some(8911),
            Blocks::PurpleConcrete => Some(8912),
            Blocks::BlueConcrete => Some(8913),
            Blocks::BrownConcrete => Some(8914),
            Blocks::GreenConcrete => Some(8915),
            Blocks::RedConcrete => Some(8916),
            Blocks::BlackConcrete => Some(8917),
            Blocks::WhiteConcretePowder => Some(8918),
            Blocks::OrangeConcretePowder => Some(8919),
            Blocks::MagentaConcretePowder => Some(8920),
            Blocks::LightBlueConcretePowder => Some(8921),
            Blocks::YellowConcretePowder => Some(8922),
            Blocks::LimeConcretePowder => Some(8923),
            Blocks::PinkConcretePowder => Some(8924),
            Blocks::GrayConcretePowder => Some(8925),
            Blocks::LightGrayConcretePowder => Some(8926),
            Blocks::CyanConcretePowder => Some(8927),
            Blocks::PurpleConcretePowder => Some(8928),
            Blocks::BlueConcretePowder => Some(8929),
            Blocks::BrownConcretePowder => Some(8930),
            Blocks::GreenConcretePowder => Some(8931),
            Blocks::RedConcretePowder => Some(8932),
            Blocks::BlackConcretePowder => Some(8933),
            Blocks::Kelp(state) => {
                Some(8934 + state.age)
            }
            Blocks::KelpPlant => Some(8960),
            Blocks::DriedKelpBlock => Some(8961),
            Blocks::TurtleEgg(state) => {
                Some(8962 + state.hatch + 3 * state.eggs)
            }
            Blocks::DeadTubeCoralBlock => Some(8974),
            Blocks::DeadBrainCoralBlock => Some(8975),
            Blocks::DeadBubbleCoralBlock => Some(8976),
            Blocks::DeadFireCoralBlock => Some(8977),
            Blocks::DeadHornCoralBlock => Some(8978),
            Blocks::TubeCoralBlock => Some(8979),
            Blocks::BrainCoralBlock => Some(8980),
            Blocks::BubbleCoralBlock => Some(8981),
            Blocks::FireCoralBlock => Some(8982),
            Blocks::HornCoralBlock => Some(8983),
            Blocks::DeadTubeCoral(state) => {
                Some(8984 + (!state.waterlogged() as i32))
            }
            Blocks::DeadBrainCoral(state) => {
                Some(8986 + (!state.waterlogged() as i32))
            }
            Blocks::DeadBubbleCoral(state) => {
                Some(8988 + (!state.waterlogged() as i32))
            }
            Blocks::DeadFireCoral(state) => {
                Some(8990 + (!state.waterlogged() as i32))
            }
            Blocks::DeadHornCoral(state) => {
                Some(8992 + (!state.waterlogged() as i32))
            }
            Blocks::TubeCoral(state) => {
                Some(8994 + (!state.waterlogged() as i32))
            }
            Blocks::BrainCoral(state) => {
                Some(8996 + (!state.waterlogged() as i32))
            }
            Blocks::BubbleCoral(state) => {
                Some(8998 + (!state.waterlogged() as i32))
            }
            Blocks::FireCoral(state) => {
                Some(9000 + (!state.waterlogged() as i32))
            }
            Blocks::HornCoral(state) => {
                Some(9002 + (!state.waterlogged() as i32))
            }
            Blocks::DeadTubeCoralFan(state) => {
                Some(9004 + (!state.waterlogged() as i32))
            }
            Blocks::DeadBrainCoralFan(state) => {
                Some(9006 + (!state.waterlogged() as i32))
            }
            Blocks::DeadBubbleCoralFan(state) => {
                Some(9008 + (!state.waterlogged() as i32))
            }
            Blocks::DeadFireCoralFan(state) => {
                Some(9010 + (!state.waterlogged() as i32))
            }
            Blocks::DeadHornCoralFan(state) => {
                Some(9012 + (!state.waterlogged() as i32))
            }
            Blocks::TubeCoralFan(state) => {
                Some(9014 + (!state.waterlogged() as i32))
            }
            Blocks::BrainCoralFan(state) => {
                Some(9016 + (!state.waterlogged() as i32))
            }
            Blocks::BubbleCoralFan(state) => {
                Some(9018 + (!state.waterlogged() as i32))
            }
            Blocks::FireCoralFan(state) => {
                Some(9020 + (!state.waterlogged() as i32))
            }
            Blocks::HornCoralFan(state) => {
                Some(9022 + (!state.waterlogged() as i32))
            }
            Blocks::DeadTubeCoralWallFan(state) => {
                Some(9024 + (!state.waterlogged() as i32) + 2 * (state.facing as i32))
            }
            Blocks::DeadBrainCoralWallFan(state) => {
                Some(9032 + (!state.waterlogged() as i32) + 2 * (state.facing as i32))
            }
            Blocks::DeadBubbleCoralWallFan(state) => {
                Some(9040 + (!state.waterlogged() as i32) + 2 * (state.facing as i32))
            }
            Blocks::DeadFireCoralWallFan(state) => {
                Some(9048 + (!state.waterlogged() as i32) + 2 * (state.facing as i32))
            }
            Blocks::DeadHornCoralWallFan(state) => {
                Some(9056 + (!state.waterlogged() as i32) + 2 * (state.facing as i32))
            }
            Blocks::TubeCoralWallFan(state) => {
                Some(9064 + (!state.waterlogged() as i32) + 2 * (state.facing as i32))
            }
            Blocks::BrainCoralWallFan(state) => {
                Some(9072 + (!state.waterlogged() as i32) + 2 * (state.facing as i32))
            }
            Blocks::BubbleCoralWallFan(state) => {
                Some(9080 + (!state.waterlogged() as i32) + 2 * (state.facing as i32))
            }
            Blocks::FireCoralWallFan(state) => {
                Some(9088 + (!state.waterlogged() as i32) + 2 * (state.facing as i32))
            }
            Blocks::HornCoralWallFan(state) => {
                Some(9096 + (!state.waterlogged() as i32) + 2 * (state.facing as i32))
            }
            Blocks::SeaPickle(state) => {
                Some(9104 + (!state.waterlogged() as i32) + 2 * state.pickles)
            }
            Blocks::BlueIce => Some(9112),
            Blocks::Conduit(state) => {
                Some(9113 + (!state.waterlogged() as i32))
            }
            Blocks::BambooSapling => Some(9115),
            Blocks::Bamboo(state) => {
                Some(9116 + state.stage + 2 * (state.leaves as i32) + 6 * state.age)
            }
            Blocks::PottedBamboo => Some(9128),
            Blocks::VoidAir => Some(9129),
            Blocks::CaveAir => Some(9130),
            Blocks::BubbleColumn(state) => {
                Some(9131 + (!state.drag() as i32))
            }
            Blocks::PolishedGraniteStairs(state) => {
                Some(9133 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::SmoothRedSandstoneStairs(state) => {
                Some(9213 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::MossyStoneBrickStairs(state) => {
                Some(9293 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::PolishedDioriteStairs(state) => {
                Some(9373 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::MossyCobblestoneStairs(state) => {
                Some(9453 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::EndStoneBrickStairs(state) => {
                Some(9533 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::StoneStairs(state) => {
                Some(9613 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::SmoothSandstoneStairs(state) => {
                Some(9693 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::SmoothQuartzStairs(state) => {
                Some(9773 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::GraniteStairs(state) => {
                Some(9853 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::AndesiteStairs(state) => {
                Some(9933 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::RedNetherBrickStairs(state) => {
                Some(10013 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::PolishedAndesiteStairs(state) => {
                Some(10093 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::DioriteStairs(state) => {
                Some(10173 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::PolishedGraniteSlab(state) => {
                Some(10253 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::SmoothRedSandstoneSlab(state) => {
                Some(10259 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::MossyStoneBrickSlab(state) => {
                Some(10265 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::PolishedDioriteSlab(state) => {
                Some(10271 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::MossyCobblestoneSlab(state) => {
                Some(10277 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::EndStoneBrickSlab(state) => {
                Some(10283 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::SmoothSandstoneSlab(state) => {
                Some(10289 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::SmoothQuartzSlab(state) => {
                Some(10295 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::GraniteSlab(state) => {
                Some(10301 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::AndesiteSlab(state) => {
                Some(10307 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::RedNetherBrickSlab(state) => {
                Some(10313 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::PolishedAndesiteSlab(state) => {
                Some(10319 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::DioriteSlab(state) => {
                Some(10325 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::BrickWall(state) => {
                let value0 = match state.west {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                let value1 = match state.south {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                let value2 = match state.north {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                let value3 = match state.east {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                Some(10331 + value0 + 2 * (!state.waterlogged() as i32) + 4 * (!state.up() as i32) + 8 * value1 + 16 * value2 + 32 * value3)
            }
            Blocks::PrismarineWall(state) => {
                let value0 = match state.west {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                let value1 = match state.south {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                let value2 = match state.north {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                let value3 = match state.east {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                Some(10395 + value0 + 2 * (!state.waterlogged() as i32) + 4 * (!state.up() as i32) + 8 * value1 + 16 * value2 + 32 * value3)
            }
            Blocks::RedSandstoneWall(state) => {
                let value0 = match state.west {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                let value1 = match state.south {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                let value2 = match state.north {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                let value3 = match state.east {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                Some(10459 + value0 + 2 * (!state.waterlogged() as i32) + 4 * (!state.up() as i32) + 8 * value1 + 16 * value2 + 32 * value3)
            }
            Blocks::MossyStoneBrickWall(state) => {
                let value0 = match state.west {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                let value1 = match state.south {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                let value2 = match state.north {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                let value3 = match state.east {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                Some(10523 + value0 + 2 * (!state.waterlogged() as i32) + 4 * (!state.up() as i32) + 8 * value1 + 16 * value2 + 32 * value3)
            }
            Blocks::GraniteWall(state) => {
                let value0 = match state.west {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                let value1 = match state.south {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                let value2 = match state.north {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                let value3 = match state.east {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                Some(10587 + value0 + 2 * (!state.waterlogged() as i32) + 4 * (!state.up() as i32) + 8 * value1 + 16 * value2 + 32 * value3)
            }
            Blocks::StoneBrickWall(state) => {
                let value0 = match state.west {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                let value1 = match state.south {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                let value2 = match state.north {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                let value3 = match state.east {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                Some(10651 + value0 + 2 * (!state.waterlogged() as i32) + 4 * (!state.up() as i32) + 8 * value1 + 16 * value2 + 32 * value3)
            }
            Blocks::NetherBrickWall(state) => {
                let value0 = match state.west {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                let value1 = match state.south {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                let value2 = match state.north {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                let value3 = match state.east {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                Some(10715 + value0 + 2 * (!state.waterlogged() as i32) + 4 * (!state.up() as i32) + 8 * value1 + 16 * value2 + 32 * value3)
            }
            Blocks::AndesiteWall(state) => {
                let value0 = match state.west {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                let value1 = match state.south {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                let value2 = match state.north {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                let value3 = match state.east {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                Some(10779 + value0 + 2 * (!state.waterlogged() as i32) + 4 * (!state.up() as i32) + 8 * value1 + 16 * value2 + 32 * value3)
            }
            Blocks::RedNetherBrickWall(state) => {
                let value0 = match state.west {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                let value1 = match state.south {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                let value2 = match state.north {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                let value3 = match state.east {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                Some(10843 + value0 + 2 * (!state.waterlogged() as i32) + 4 * (!state.up() as i32) + 8 * value1 + 16 * value2 + 32 * value3)
            }
            Blocks::SandstoneWall(state) => {
                let value0 = match state.west {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                let value1 = match state.south {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                let value2 = match state.north {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                let value3 = match state.east {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                Some(10907 + value0 + 2 * (!state.waterlogged() as i32) + 4 * (!state.up() as i32) + 8 * value1 + 16 * value2 + 32 * value3)
            }
            Blocks::EndStoneBrickWall(state) => {
                let value0 = match state.west {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                let value1 = match state.south {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                let value2 = match state.north {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                let value3 = match state.east {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                Some(10971 + value0 + 2 * (!state.waterlogged() as i32) + 4 * (!state.up() as i32) + 8 * value1 + 16 * value2 + 32 * value3)
            }
            Blocks::DioriteWall(state) => {
                let value0 = match state.west {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                let value1 = match state.south {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                let value2 = match state.north {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                let value3 = match state.east {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                Some(11035 + value0 + 2 * (!state.waterlogged() as i32) + 4 * (!state.up() as i32) + 8 * value1 + 16 * value2 + 32 * value3)
            }
            Blocks::Scaffolding(state) => {
                Some(11099 + (!state.waterlogged() as i32) + 2 * state.distance + 16 * (!state.bottom() as i32))
            }
            Blocks::Loom(state) => {
                Some(11131 + (state.facing as i32))
            }
            Blocks::Barrel(state) => {
                Some(11135 + (!state.open() as i32) + 2 * (state.facing as i32))
            }
            Blocks::Smoker(state) => {
                Some(11147 + (!state.lit() as i32) + 2 * (state.facing as i32))
            }
            Blocks::BlastFurnace(state) => {
                Some(11155 + (!state.lit() as i32) + 2 * (state.facing as i32))
            }
            Blocks::CartographyTable => Some(11163),
            Blocks::FletchingTable => Some(11164),
            Blocks::Grindstone(state) => {
                Some(11165 + (state.facing as i32) + 4 * (state.face as i32))
            }
            Blocks::Lectern(state) => {
                Some(11177 + (!state.powered() as i32) + 2 * (!state.has_book() as i32) + 4 * (state.facing as i32))
            }
            Blocks::SmithingTable => Some(11193),
            Blocks::Stonecutter(state) => {
                Some(11194 + (state.facing as i32))
            }
            Blocks::Bell(state) => {
                Some(11198 + (state.facing as i32) + 4 * (state.attachment as i32))
            }
            Blocks::Lantern(state) => {
                Some(11214 + (!state.hanging() as i32))
            }
            Blocks::SoulLantern(_) => None,
            Blocks::Campfire(state) => {
                Some(11216 + (!state.waterlogged() as i32) + 2 * (!state.signal_fire() as i32) + 4 * (!state.lit() as i32) + 8 * (state.facing as i32))
            }
            Blocks::SoulCampfire(_) => None,
            Blocks::SweetBerryBush(state) => {
                Some(11248 + state.age)
            }
            Blocks::WarpedStem(_) => None,
            Blocks::StrippedWarpedStem(_) => None,
            Blocks::WarpedHyphae(_) => None,
            Blocks::StrippedWarpedHyphae(_) => None,
            Blocks::WarpedNylium => None,
            Blocks::WarpedFungus => None,
            Blocks::WarpedWartBlock => None,
            Blocks::WarpedRoots => None,
            Blocks::NetherSprouts => None,
            Blocks::CrimsonStem(_) => None,
            Blocks::StrippedCrimsonStem(_) => None,
            Blocks::CrimsonHyphae(_) => None,
            Blocks::StrippedCrimsonHyphae(_) => None,
            Blocks::CrimsonNylium => None,
            Blocks::CrimsonFungus => None,
            Blocks::Shroomlight => None,
            Blocks::WeepingVines(_) => None,
            Blocks::WeepingVinesPlant => None,
            Blocks::TwistingVines(_) => None,
            Blocks::TwistingVinesPlant => None,
            Blocks::CrimsonRoots => None,
            Blocks::CrimsonPlanks => None,
            Blocks::WarpedPlanks => None,
            Blocks::CrimsonSlab(_) => None,
            Blocks::WarpedSlab(_) => None,
            Blocks::CrimsonPressurePlate(_) => None,
            Blocks::WarpedPressurePlate(_) => None,
            Blocks::CrimsonFence(_) => None,
            Blocks::WarpedFence(_) => None,
            Blocks::CrimsonTrapdoor(_) => None,
            Blocks::WarpedTrapdoor(_) => None,
            Blocks::CrimsonFenceGate(_) => None,
            Blocks::WarpedFenceGate(_) => None,
            Blocks::CrimsonStairs(_) => None,
            Blocks::WarpedStairs(_) => None,
            Blocks::CrimsonButton(_) => None,
            Blocks::WarpedButton(_) => None,
            Blocks::CrimsonDoor(_) => None,
            Blocks::WarpedDoor(_) => None,
            Blocks::CrimsonSign(_) => None,
            Blocks::WarpedSign(_) => None,
            Blocks::CrimsonWallSign(_) => None,
            Blocks::WarpedWallSign(_) => None,
            Blocks::StructureBlock(state) => {
                Some(11252 + (state.mode as i32))
            }
            Blocks::Jigsaw(_) => None,
            Blocks::Composter(state) => {
                Some(11262 + state.level)
            }
            Blocks::Target(_) => None,
            Blocks::BeeNest(_) => None,
            Blocks::Beehive(_) => None,
            Blocks::HoneyBlock => None,
            Blocks::HoneycombBlock => None,
            Blocks::NetheriteBlock => None,
            Blocks::AncientDebris => None,
            Blocks::CryingObsidian => None,
            Blocks::RespawnAnchor(_) => None,
            Blocks::PottedCrimsonFungus => None,
            Blocks::PottedWarpedFungus => None,
            Blocks::PottedCrimsonRoots => None,
            Blocks::PottedWarpedRoots => None,
            Blocks::Lodestone => None,
            Blocks::Blackstone => None,
            Blocks::BlackstoneStairs(_) => None,
            Blocks::BlackstoneWall(_) => None,
            Blocks::BlackstoneSlab(_) => None,
            Blocks::PolishedBlackstone => None,
            Blocks::PolishedBlackstoneBricks => None,
            Blocks::CrackedPolishedBlackstoneBricks => None,
            Blocks::ChiseledPolishedBlackstone => None,
            Blocks::PolishedBlackstoneBrickSlab(_) => None,
            Blocks::PolishedBlackstoneBrickStairs(_) => None,
            Blocks::PolishedBlackstoneBrickWall(_) => None,
            Blocks::GildedBlackstone => None,
            Blocks::PolishedBlackstoneStairs(_) => None,
            Blocks::PolishedBlackstoneSlab(_) => None,
            Blocks::PolishedBlackstonePressurePlate(_) => None,
            Blocks::PolishedBlackstoneButton(_) => None,
            Blocks::PolishedBlackstoneWall(_) => None,
            Blocks::ChiseledNetherBricks => None,
            Blocks::CrackedNetherBricks => None,
            Blocks::QuartzBricks => None,
            Blocks::Candle(_) => None,
            Blocks::WhiteCandle(_) => None,
            Blocks::OrangeCandle(_) => None,
            Blocks::MagentaCandle(_) => None,
            Blocks::LightBlueCandle(_) => None,
            Blocks::YellowCandle(_) => None,
            Blocks::LimeCandle(_) => None,
            Blocks::PinkCandle(_) => None,
            Blocks::GrayCandle(_) => None,
            Blocks::LightGrayCandle(_) => None,
            Blocks::CyanCandle(_) => None,
            Blocks::PurpleCandle(_) => None,
            Blocks::BlueCandle(_) => None,
            Blocks::BrownCandle(_) => None,
            Blocks::GreenCandle(_) => None,
            Blocks::RedCandle(_) => None,
            Blocks::BlackCandle(_) => None,
            Blocks::CandleCake(_) => None,
            Blocks::WhiteCandleCake(_) => None,
            Blocks::OrangeCandleCake(_) => None,
            Blocks::MagentaCandleCake(_) => None,
            Blocks::LightBlueCandleCake(_) => None,
            Blocks::YellowCandleCake(_) => None,
            Blocks::LimeCandleCake(_) => None,
            Blocks::PinkCandleCake(_) => None,
            Blocks::GrayCandleCake(_) => None,
            Blocks::LightGrayCandleCake(_) => None,
            Blocks::CyanCandleCake(_) => None,
            Blocks::PurpleCandleCake(_) => None,
            Blocks::BlueCandleCake(_) => None,
            Blocks::BrownCandleCake(_) => None,
            Blocks::GreenCandleCake(_) => None,
            Blocks::RedCandleCake(_) => None,
            Blocks::BlackCandleCake(_) => None,
            Blocks::AmethystBlock => None,
            Blocks::BuddingAmethyst => None,
            Blocks::AmethystCluster(_) => None,
            Blocks::LargeAmethystBud(_) => None,
            Blocks::MediumAmethystBud(_) => None,
            Blocks::SmallAmethystBud(_) => None,
            Blocks::Tuff => None,
            Blocks::Calcite => None,
            Blocks::TintedGlass => None,
            Blocks::PowderSnow => None,
            Blocks::SculkSensor(_) => None,
            Blocks::OxidizedCopper => None,
            Blocks::WeatheredCopper => None,
            Blocks::ExposedCopper => None,
            Blocks::CopperBlock => None,
            Blocks::CopperOre => None,
            Blocks::DeepslateCopperOre => None,
            Blocks::OxidizedCutCopper => None,
            Blocks::WeatheredCutCopper => None,
            Blocks::ExposedCutCopper => None,
            Blocks::CutCopper => None,
            Blocks::OxidizedCutCopperStairs(_) => None,
            Blocks::WeatheredCutCopperStairs(_) => None,
            Blocks::ExposedCutCopperStairs(_) => None,
            Blocks::CutCopperStairs(_) => None,
            Blocks::OxidizedCutCopperSlab(_) => None,
            Blocks::WeatheredCutCopperSlab(_) => None,
            Blocks::ExposedCutCopperSlab(_) => None,
            Blocks::CutCopperSlab(_) => None,
            Blocks::WaxedCopperBlock => None,
            Blocks::WaxedWeatheredCopper => None,
            Blocks::WaxedExposedCopper => None,
            Blocks::WaxedOxidizedCopper => None,
            Blocks::WaxedOxidizedCutCopper => None,
            Blocks::WaxedWeatheredCutCopper => None,
            Blocks::WaxedExposedCutCopper => None,
            Blocks::WaxedCutCopper => None,
            Blocks::WaxedOxidizedCutCopperStairs(_) => None,
            Blocks::WaxedWeatheredCutCopperStairs(_) => None,
            Blocks::WaxedExposedCutCopperStairs(_) => None,
            Blocks::WaxedCutCopperStairs(_) => None,
            Blocks::WaxedOxidizedCutCopperSlab(_) => None,
            Blocks::WaxedWeatheredCutCopperSlab(_) => None,
            Blocks::WaxedExposedCutCopperSlab(_) => None,
            Blocks::WaxedCutCopperSlab(_) => None,
            Blocks::LightningRod(_) => None,
            Blocks::PointedDripstone(_) => None,
            Blocks::DripstoneBlock => None,
            Blocks::CaveVines(_) => None,
            Blocks::CaveVinesPlant(_) => None,
            Blocks::SporeBlossom => None,
            Blocks::Azalea => None,
            Blocks::FloweringAzalea => None,
            Blocks::MossCarpet => None,
            Blocks::MossBlock => None,
            Blocks::BigDripleaf(_) => None,
            Blocks::BigDripleafStem(_) => None,
            Blocks::SmallDripleaf(_) => None,
            Blocks::HangingRoots(_) => None,
            Blocks::RootedDirt => None,
            Blocks::Deepslate(_) => None,
            Blocks::CobbledDeepslate => None,
            Blocks::CobbledDeepslateStairs(_) => None,
            Blocks::CobbledDeepslateSlab(_) => None,
            Blocks::CobbledDeepslateWall(_) => None,
            Blocks::PolishedDeepslate => None,
            Blocks::PolishedDeepslateStairs(_) => None,
            Blocks::PolishedDeepslateSlab(_) => None,
            Blocks::PolishedDeepslateWall(_) => None,
            Blocks::DeepslateTiles => None,
            Blocks::DeepslateTileStairs(_) => None,
            Blocks::DeepslateTileSlab(_) => None,
            Blocks::DeepslateTileWall(_) => None,
            Blocks::DeepslateBricks => None,
            Blocks::DeepslateBrickStairs(_) => None,
            Blocks::DeepslateBrickSlab(_) => None,
            Blocks::DeepslateBrickWall(_) => None,
            Blocks::ChiseledDeepslate => None,
            Blocks::CrackedDeepslateBricks => None,
            Blocks::CrackedDeepslateTiles => None,
            Blocks::InfestedDeepslate(_) => None,
            Blocks::SmoothBasalt => None,
            Blocks::RawIronBlock => None,
            Blocks::RawCopperBlock => None,
            Blocks::RawGoldBlock => None,
            Blocks::PottedAzaleaBush => None,
            Blocks::PottedFloweringAzaleaBush => None,
        }
    }
    pub fn get_global_id_1631(&self) -> Option<i32> {
        match self {
            Blocks::Air => Some(0),
            Blocks::Stone => Some(1),
            Blocks::Granite => Some(2),
            Blocks::PolishedGranite => Some(3),
            Blocks::Diorite => Some(4),
            Blocks::PolishedDiorite => Some(5),
            Blocks::Andesite => Some(6),
            Blocks::PolishedAndesite => Some(7),
            Blocks::GrassBlock(state) => {
                Some(8 + (!state.snowy() as i32))
            }
            Blocks::Dirt => Some(10),
            Blocks::CoarseDirt => Some(11),
            Blocks::Podzol(state) => {
                Some(12 + (!state.snowy() as i32))
            }
            Blocks::Cobblestone => Some(14),
            Blocks::OakPlanks => Some(15),
            Blocks::SprucePlanks => Some(16),
            Blocks::BirchPlanks => Some(17),
            Blocks::JunglePlanks => Some(18),
            Blocks::AcaciaPlanks => Some(19),
            Blocks::DarkOakPlanks => Some(20),
            Blocks::OakSapling(state) => {
                Some(21 + state.stage)
            }
            Blocks::SpruceSapling(state) => {
                Some(23 + state.stage)
            }
            Blocks::BirchSapling(state) => {
                Some(25 + state.stage)
            }
            Blocks::JungleSapling(state) => {
                Some(27 + state.stage)
            }
            Blocks::AcaciaSapling(state) => {
                Some(29 + state.stage)
            }
            Blocks::DarkOakSapling(state) => {
                Some(31 + state.stage)
            }
            Blocks::Bedrock => Some(33),
            Blocks::Water(state) => {
                Some(34 + state.level)
            }
            Blocks::Lava(state) => {
                Some(50 + state.level)
            }
            Blocks::Sand => Some(66),
            Blocks::RedSand => Some(67),
            Blocks::Gravel => Some(68),
            Blocks::GoldOre => Some(69),
            Blocks::DeepslateGoldOre => None,
            Blocks::IronOre => Some(70),
            Blocks::DeepslateIronOre => None,
            Blocks::CoalOre => Some(71),
            Blocks::DeepslateCoalOre => None,
            Blocks::NetherGoldOre => None,
            Blocks::OakLog(state) => {
                Some(72 + (state.axis as i32))
            }
            Blocks::SpruceLog(state) => {
                Some(75 + (state.axis as i32))
            }
            Blocks::BirchLog(state) => {
                Some(78 + (state.axis as i32))
            }
            Blocks::JungleLog(state) => {
                Some(81 + (state.axis as i32))
            }
            Blocks::AcaciaLog(state) => {
                Some(84 + (state.axis as i32))
            }
            Blocks::DarkOakLog(state) => {
                Some(87 + (state.axis as i32))
            }
            Blocks::StrippedSpruceLog(state) => {
                Some(90 + (state.axis as i32))
            }
            Blocks::StrippedBirchLog(state) => {
                Some(93 + (state.axis as i32))
            }
            Blocks::StrippedJungleLog(state) => {
                Some(96 + (state.axis as i32))
            }
            Blocks::StrippedAcaciaLog(state) => {
                Some(99 + (state.axis as i32))
            }
            Blocks::StrippedDarkOakLog(state) => {
                Some(102 + (state.axis as i32))
            }
            Blocks::StrippedOakLog(state) => {
                Some(105 + (state.axis as i32))
            }
            Blocks::OakWood(state) => {
                Some(108 + (state.axis as i32))
            }
            Blocks::SpruceWood(state) => {
                Some(111 + (state.axis as i32))
            }
            Blocks::BirchWood(state) => {
                Some(114 + (state.axis as i32))
            }
            Blocks::JungleWood(state) => {
                Some(117 + (state.axis as i32))
            }
            Blocks::AcaciaWood(state) => {
                Some(120 + (state.axis as i32))
            }
            Blocks::DarkOakWood(state) => {
                Some(123 + (state.axis as i32))
            }
            Blocks::StrippedOakWood(state) => {
                Some(126 + (state.axis as i32))
            }
            Blocks::StrippedSpruceWood(state) => {
                Some(129 + (state.axis as i32))
            }
            Blocks::StrippedBirchWood(state) => {
                Some(132 + (state.axis as i32))
            }
            Blocks::StrippedJungleWood(state) => {
                Some(135 + (state.axis as i32))
            }
            Blocks::StrippedAcaciaWood(state) => {
                Some(138 + (state.axis as i32))
            }
            Blocks::StrippedDarkOakWood(state) => {
                Some(141 + (state.axis as i32))
            }
            Blocks::OakLeaves(state) => {
                Some(144 + (!state.persistent() as i32) + 2 * state.distance)
            }
            Blocks::SpruceLeaves(state) => {
                Some(158 + (!state.persistent() as i32) + 2 * state.distance)
            }
            Blocks::BirchLeaves(state) => {
                Some(172 + (!state.persistent() as i32) + 2 * state.distance)
            }
            Blocks::JungleLeaves(state) => {
                Some(186 + (!state.persistent() as i32) + 2 * state.distance)
            }
            Blocks::AcaciaLeaves(state) => {
                Some(200 + (!state.persistent() as i32) + 2 * state.distance)
            }
            Blocks::DarkOakLeaves(state) => {
                Some(214 + (!state.persistent() as i32) + 2 * state.distance)
            }
            Blocks::AzaleaLeaves(_) => None,
            Blocks::FloweringAzaleaLeaves(_) => None,
            Blocks::Sponge => Some(228),
            Blocks::WetSponge => Some(229),
            Blocks::Glass => Some(230),
            Blocks::LapisOre => Some(231),
            Blocks::DeepslateLapisOre => None,
            Blocks::LapisBlock => Some(232),
            Blocks::Dispenser(state) => {
                Some(233 + (!state.triggered() as i32) + 2 * (state.facing as i32))
            }
            Blocks::Sandstone => Some(245),
            Blocks::ChiseledSandstone => Some(246),
            Blocks::CutSandstone => Some(247),
            Blocks::NoteBlock(state) => {
                if state.instrument > Instrument::Xylophone {
                    return None;
                }
                Some(248 + (!state.powered() as i32) + 2 * state.note + 50 * (state.instrument as i32))
            }
            Blocks::WhiteBed(state) => {
                Some(748 + (state.part as i32) + 2 * (!state.occupied() as i32) + 4 * (state.facing as i32))
            }
            Blocks::OrangeBed(state) => {
                Some(764 + (state.part as i32) + 2 * (!state.occupied() as i32) + 4 * (state.facing as i32))
            }
            Blocks::MagentaBed(state) => {
                Some(780 + (state.part as i32) + 2 * (!state.occupied() as i32) + 4 * (state.facing as i32))
            }
            Blocks::LightBlueBed(state) => {
                Some(796 + (state.part as i32) + 2 * (!state.occupied() as i32) + 4 * (state.facing as i32))
            }
            Blocks::YellowBed(state) => {
                Some(812 + (state.part as i32) + 2 * (!state.occupied() as i32) + 4 * (state.facing as i32))
            }
            Blocks::LimeBed(state) => {
                Some(828 + (state.part as i32) + 2 * (!state.occupied() as i32) + 4 * (state.facing as i32))
            }
            Blocks::PinkBed(state) => {
                Some(844 + (state.part as i32) + 2 * (!state.occupied() as i32) + 4 * (state.facing as i32))
            }
            Blocks::GrayBed(state) => {
                Some(860 + (state.part as i32) + 2 * (!state.occupied() as i32) + 4 * (state.facing as i32))
            }
            Blocks::LightGrayBed(state) => {
                Some(876 + (state.part as i32) + 2 * (!state.occupied() as i32) + 4 * (state.facing as i32))
            }
            Blocks::CyanBed(state) => {
                Some(892 + (state.part as i32) + 2 * (!state.occupied() as i32) + 4 * (state.facing as i32))
            }
            Blocks::PurpleBed(state) => {
                Some(908 + (state.part as i32) + 2 * (!state.occupied() as i32) + 4 * (state.facing as i32))
            }
            Blocks::BlueBed(state) => {
                Some(924 + (state.part as i32) + 2 * (!state.occupied() as i32) + 4 * (state.facing as i32))
            }
            Blocks::BrownBed(state) => {
                Some(940 + (state.part as i32) + 2 * (!state.occupied() as i32) + 4 * (state.facing as i32))
            }
            Blocks::GreenBed(state) => {
                Some(956 + (state.part as i32) + 2 * (!state.occupied() as i32) + 4 * (state.facing as i32))
            }
            Blocks::RedBed(state) => {
                Some(972 + (state.part as i32) + 2 * (!state.occupied() as i32) + 4 * (state.facing as i32))
            }
            Blocks::BlackBed(state) => {
                Some(988 + (state.part as i32) + 2 * (!state.occupied() as i32) + 4 * (state.facing as i32))
            }
            Blocks::PoweredRail(state) => {
                Some(1004 + (state.shape as i32) + 6 * (!state.powered() as i32))
            }
            Blocks::DetectorRail(state) => {
                Some(1016 + (state.shape as i32) + 6 * (!state.powered() as i32))
            }
            Blocks::StickyPiston(state) => {
                Some(1028 + (state.facing as i32) + 6 * (!state.extended() as i32))
            }
            Blocks::Cobweb => Some(1040),
            Blocks::Grass => Some(1041),
            Blocks::Fern => Some(1042),
            Blocks::DeadBush => Some(1043),
            Blocks::Seagrass => Some(1044),
            Blocks::TallSeagrass(state) => {
                Some(1045 + (state.half as i32))
            }
            Blocks::Piston(state) => {
                Some(1047 + (state.facing as i32) + 6 * (!state.extended() as i32))
            }
            Blocks::PistonHead(state) => {
                Some(1059 + (state.typed as i32) + 2 * (!state.short() as i32) + 4 * (state.facing as i32))
            }
            Blocks::WhiteWool => Some(1083),
            Blocks::OrangeWool => Some(1084),
            Blocks::MagentaWool => Some(1085),
            Blocks::LightBlueWool => Some(1086),
            Blocks::YellowWool => Some(1087),
            Blocks::LimeWool => Some(1088),
            Blocks::PinkWool => Some(1089),
            Blocks::GrayWool => Some(1090),
            Blocks::LightGrayWool => Some(1091),
            Blocks::CyanWool => Some(1092),
            Blocks::PurpleWool => Some(1093),
            Blocks::BlueWool => Some(1094),
            Blocks::BrownWool => Some(1095),
            Blocks::GreenWool => Some(1096),
            Blocks::RedWool => Some(1097),
            Blocks::BlackWool => Some(1098),
            Blocks::MovingPiston(state) => {
                Some(1099 + (state.typed as i32) + 2 * (state.facing as i32))
            }
            Blocks::Dandelion => Some(1111),
            Blocks::Poppy => Some(1112),
            Blocks::BlueOrchid => Some(1113),
            Blocks::Allium => Some(1114),
            Blocks::AzureBluet => Some(1115),
            Blocks::RedTulip => Some(1116),
            Blocks::OrangeTulip => Some(1117),
            Blocks::WhiteTulip => Some(1118),
            Blocks::PinkTulip => Some(1119),
            Blocks::OxeyeDaisy => Some(1120),
            Blocks::Cornflower => None,
            Blocks::WitherRose => None,
            Blocks::LilyOfTheValley => None,
            Blocks::BrownMushroom => Some(1121),
            Blocks::RedMushroom => Some(1122),
            Blocks::GoldBlock => Some(1123),
            Blocks::IronBlock => Some(1124),
            Blocks::Bricks => Some(1125),
            Blocks::Tnt(state) => {
                Some(1126 + (!state.unstable() as i32))
            }
            Blocks::Bookshelf => Some(1128),
            Blocks::MossyCobblestone => Some(1129),
            Blocks::Obsidian => Some(1130),
            Blocks::Torch => Some(1131),
            Blocks::WallTorch(state) => {
                Some(1132 + (state.facing as i32))
            }
            Blocks::Fire(state) => {
                Some(1136 + (!state.west() as i32) + 2 * (!state.up() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32) + 32 * state.age)
            }
            Blocks::SoulFire => None,
            Blocks::Spawner => Some(1648),
            Blocks::OakStairs(state) => {
                Some(1649 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::Chest(state) => {
                Some(1729 + (!state.waterlogged() as i32) + 2 * (state.typed as i32) + 6 * (state.facing as i32))
            }
            Blocks::RedstoneWire(state) => {
                Some(1753 + (state.west as i32) + 3 * (state.south as i32) + 9 * state.power + 144 * (state.north as i32) + 432 * (state.east as i32))
            }
            Blocks::DiamondOre => Some(3049),
            Blocks::DeepslateDiamondOre => None,
            Blocks::DiamondBlock => Some(3050),
            Blocks::CraftingTable => Some(3051),
            Blocks::Wheat(state) => {
                Some(3052 + state.age)
            }
            Blocks::Farmland(state) => {
                Some(3060 + state.moisture)
            }
            Blocks::Furnace(state) => {
                Some(3068 + (!state.lit() as i32) + 2 * (state.facing as i32))
            }
            Blocks::OakSign(state) => {
                Some(3076 + (!state.waterlogged() as i32) + 2 * state.rotation)
            }
            Blocks::SpruceSign(_) => None,
            Blocks::BirchSign(_) => None,
            Blocks::AcaciaSign(_) => None,
            Blocks::JungleSign(_) => None,
            Blocks::DarkOakSign(_) => None,
            Blocks::OakDoor(state) => {
                Some(3108 + (!state.powered() as i32) + 2 * (!state.open() as i32) + 4 * (state.hinge as i32) + 8 * (state.half as i32) + 16 * (state.facing as i32))
            }
            Blocks::Ladder(state) => {
                Some(3172 + (!state.waterlogged() as i32) + 2 * (state.facing as i32))
            }
            Blocks::Rail(state) => {
                Some(3180 + (state.shape as i32))
            }
            Blocks::CobblestoneStairs(state) => {
                Some(3190 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::OakWallSign(state) => {
                Some(3270 + (!state.waterlogged() as i32) + 2 * (state.facing as i32))
            }
            Blocks::SpruceWallSign(_) => None,
            Blocks::BirchWallSign(_) => None,
            Blocks::AcaciaWallSign(_) => None,
            Blocks::JungleWallSign(_) => None,
            Blocks::DarkOakWallSign(_) => None,
            Blocks::Lever(state) => {
                Some(3278 + (!state.powered() as i32) + 2 * (state.facing as i32) + 8 * (state.face as i32))
            }
            Blocks::StonePressurePlate(state) => {
                Some(3302 + (!state.powered() as i32))
            }
            Blocks::IronDoor(state) => {
                Some(3304 + (!state.powered() as i32) + 2 * (!state.open() as i32) + 4 * (state.hinge as i32) + 8 * (state.half as i32) + 16 * (state.facing as i32))
            }
            Blocks::OakPressurePlate(state) => {
                Some(3368 + (!state.powered() as i32))
            }
            Blocks::SprucePressurePlate(state) => {
                Some(3370 + (!state.powered() as i32))
            }
            Blocks::BirchPressurePlate(state) => {
                Some(3372 + (!state.powered() as i32))
            }
            Blocks::JunglePressurePlate(state) => {
                Some(3374 + (!state.powered() as i32))
            }
            Blocks::AcaciaPressurePlate(state) => {
                Some(3376 + (!state.powered() as i32))
            }
            Blocks::DarkOakPressurePlate(state) => {
                Some(3378 + (!state.powered() as i32))
            }
            Blocks::RedstoneOre(state) => {
                Some(3380 + (!state.lit() as i32))
            }
            Blocks::DeepslateRedstoneOre(_) => None,
            Blocks::RedstoneTorch(state) => {
                Some(3382 + (!state.lit() as i32))
            }
            Blocks::RedstoneWallTorch(state) => {
                Some(3384 + (!state.lit() as i32) + 2 * (state.facing as i32))
            }
            Blocks::StoneButton(state) => {
                Some(3392 + (!state.powered() as i32) + 2 * (state.facing as i32) + 8 * (state.face as i32))
            }
            Blocks::Snow(state) => {
                Some(3416 + state.layers)
            }
            Blocks::Ice => Some(3424),
            Blocks::SnowBlock => Some(3425),
            Blocks::Cactus(state) => {
                Some(3426 + state.age)
            }
            Blocks::Clay => Some(3442),
            Blocks::SugarCane(state) => {
                Some(3443 + state.age)
            }
            Blocks::Jukebox(state) => {
                Some(3459 + (!state.has_record() as i32))
            }
            Blocks::OakFence(state) => {
                Some(3461 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::Pumpkin => Some(3493),
            Blocks::Netherrack => Some(3494),
            Blocks::SoulSand => Some(3495),
            Blocks::SoulSoil => None,
            Blocks::Basalt(_) => None,
            Blocks::PolishedBasalt(_) => None,
            Blocks::SoulTorch => None,
            Blocks::SoulWallTorch(_) => None,
            Blocks::Glowstone => Some(3496),
            Blocks::NetherPortal(state) => {
                Some(3497 + (state.axis as i32))
            }
            Blocks::CarvedPumpkin(state) => {
                Some(3499 + (state.facing as i32))
            }
            Blocks::JackOLantern(state) => {
                Some(3503 + (state.facing as i32))
            }
            Blocks::Cake(state) => {
                Some(3507 + state.bites)
            }
            Blocks::Repeater(state) => {
                Some(3514 + (!state.powered() as i32) + 2 * (!state.locked() as i32) + 4 * (state.facing as i32) + 16 * state.delay)
            }
            Blocks::WhiteStainedGlass => Some(3578),
            Blocks::OrangeStainedGlass => Some(3579),
            Blocks::MagentaStainedGlass => Some(3580),
            Blocks::LightBlueStainedGlass => Some(3581),
            Blocks::YellowStainedGlass => Some(3582),
            Blocks::LimeStainedGlass => Some(3583),
            Blocks::PinkStainedGlass => Some(3584),
            Blocks::GrayStainedGlass => Some(3585),
            Blocks::LightGrayStainedGlass => Some(3586),
            Blocks::CyanStainedGlass => Some(3587),
            Blocks::PurpleStainedGlass => Some(3588),
            Blocks::BlueStainedGlass => Some(3589),
            Blocks::BrownStainedGlass => Some(3590),
            Blocks::GreenStainedGlass => Some(3591),
            Blocks::RedStainedGlass => Some(3592),
            Blocks::BlackStainedGlass => Some(3593),
            Blocks::OakTrapdoor(state) => {
                Some(3594 + (!state.waterlogged() as i32) + 2 * (!state.powered() as i32) + 4 * (!state.open() as i32) + 8 * (state.half as i32) + 16 * (state.facing as i32))
            }
            Blocks::SpruceTrapdoor(state) => {
                Some(3658 + (!state.waterlogged() as i32) + 2 * (!state.powered() as i32) + 4 * (!state.open() as i32) + 8 * (state.half as i32) + 16 * (state.facing as i32))
            }
            Blocks::BirchTrapdoor(state) => {
                Some(3722 + (!state.waterlogged() as i32) + 2 * (!state.powered() as i32) + 4 * (!state.open() as i32) + 8 * (state.half as i32) + 16 * (state.facing as i32))
            }
            Blocks::JungleTrapdoor(state) => {
                Some(3786 + (!state.waterlogged() as i32) + 2 * (!state.powered() as i32) + 4 * (!state.open() as i32) + 8 * (state.half as i32) + 16 * (state.facing as i32))
            }
            Blocks::AcaciaTrapdoor(state) => {
                Some(3850 + (!state.waterlogged() as i32) + 2 * (!state.powered() as i32) + 4 * (!state.open() as i32) + 8 * (state.half as i32) + 16 * (state.facing as i32))
            }
            Blocks::DarkOakTrapdoor(state) => {
                Some(3914 + (!state.waterlogged() as i32) + 2 * (!state.powered() as i32) + 4 * (!state.open() as i32) + 8 * (state.half as i32) + 16 * (state.facing as i32))
            }
            Blocks::StoneBricks => Some(3984),
            Blocks::MossyStoneBricks => Some(3985),
            Blocks::CrackedStoneBricks => Some(3986),
            Blocks::ChiseledStoneBricks => Some(3987),
            Blocks::InfestedStone => Some(3978),
            Blocks::InfestedCobblestone => Some(3979),
            Blocks::InfestedStoneBricks => Some(3980),
            Blocks::InfestedMossyStoneBricks => Some(3981),
            Blocks::InfestedCrackedStoneBricks => Some(3982),
            Blocks::InfestedChiseledStoneBricks => Some(3983),
            Blocks::BrownMushroomBlock(state) => {
                Some(3988 + (!state.west() as i32) + 2 * (!state.up() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32) + 32 * (!state.down() as i32))
            }
            Blocks::RedMushroomBlock(state) => {
                Some(4052 + (!state.west() as i32) + 2 * (!state.up() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32) + 32 * (!state.down() as i32))
            }
            Blocks::MushroomStem(state) => {
                Some(4116 + (!state.west() as i32) + 2 * (!state.up() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32) + 32 * (!state.down() as i32))
            }
            Blocks::IronBars(state) => {
                Some(4180 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::Chain(_) => None,
            Blocks::GlassPane(state) => {
                Some(4212 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::Melon => Some(4244),
            Blocks::AttachedPumpkinStem(state) => {
                Some(4245 + (state.facing as i32))
            }
            Blocks::AttachedMelonStem(state) => {
                Some(4249 + (state.facing as i32))
            }
            Blocks::PumpkinStem(state) => {
                Some(4253 + state.age)
            }
            Blocks::MelonStem(state) => {
                Some(4261 + state.age)
            }
            Blocks::Vine(state) => {
                Some(4269 + (!state.west() as i32) + 2 * (!state.up() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::GlowLichen(_) => None,
            Blocks::OakFenceGate(state) => {
                Some(4301 + (!state.powered() as i32) + 2 * (!state.open() as i32) + 4 * (!state.in_wall() as i32) + 8 * (state.facing as i32))
            }
            Blocks::BrickStairs(state) => {
                Some(4333 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::StoneBrickStairs(state) => {
                Some(4413 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::Mycelium(state) => {
                Some(4493 + (!state.snowy() as i32))
            }
            Blocks::LilyPad => Some(4495),
            Blocks::NetherBricks => Some(4496),
            Blocks::NetherBrickFence(state) => {
                Some(4497 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::NetherBrickStairs(state) => {
                Some(4529 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::NetherWart(state) => {
                Some(4609 + state.age)
            }
            Blocks::EnchantingTable => Some(4613),
            Blocks::BrewingStand(state) => {
                Some(4614 + (!state.has_bottle_2() as i32) + 2 * (!state.has_bottle_1() as i32) + 4 * (!state.has_bottle_0() as i32))
            }
            Blocks::Cauldron => Some(4622),
            Blocks::WaterCauldron(state) => {
                Some(4623 + state.level)
            }
            Blocks::LavaCauldron => None,
            Blocks::PowderSnowCauldron(_) => None,
            Blocks::EndPortal => Some(4626),
            Blocks::EndPortalFrame(state) => {
                Some(4627 + (state.facing as i32) + 4 * (!state.eye() as i32))
            }
            Blocks::EndStone => Some(4635),
            Blocks::DragonEgg => Some(4636),
            Blocks::RedstoneLamp(state) => {
                Some(4637 + (!state.lit() as i32))
            }
            Blocks::Cocoa(state) => {
                Some(4639 + (state.facing as i32) + 4 * state.age)
            }
            Blocks::SandstoneStairs(state) => {
                Some(4651 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::EmeraldOre => Some(4731),
            Blocks::DeepslateEmeraldOre => None,
            Blocks::EnderChest(state) => {
                Some(4732 + (!state.waterlogged() as i32) + 2 * (state.facing as i32))
            }
            Blocks::TripwireHook(state) => {
                Some(4740 + (!state.powered() as i32) + 2 * (state.facing as i32) + 8 * (!state.attached() as i32))
            }
            Blocks::Tripwire(state) => {
                Some(4756 + (!state.west() as i32) + 2 * (!state.south() as i32) + 4 * (!state.powered() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32) + 32 * (!state.disarmed() as i32) + 64 * (!state.attached() as i32))
            }
            Blocks::EmeraldBlock => Some(4884),
            Blocks::SpruceStairs(state) => {
                Some(4885 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::BirchStairs(state) => {
                Some(4965 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::JungleStairs(state) => {
                Some(5045 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::CommandBlock(state) => {
                Some(5125 + (state.facing as i32) + 6 * (!state.conditional() as i32))
            }
            Blocks::Beacon => Some(5137),
            Blocks::CobblestoneWall(state) => {
                let value0 = match state.west {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                let value1 = match state.south {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                let value2 = match state.north {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                let value3 = match state.east {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                Some(5138 + value0 + 2 * (!state.waterlogged() as i32) + 4 * (!state.up() as i32) + 8 * value1 + 16 * value2 + 32 * value3)
            }
            Blocks::MossyCobblestoneWall(state) => {
                let value0 = match state.west {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                let value1 = match state.south {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                let value2 = match state.north {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                let value3 = match state.east {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                Some(5202 + value0 + 2 * (!state.waterlogged() as i32) + 4 * (!state.up() as i32) + 8 * value1 + 16 * value2 + 32 * value3)
            }
            Blocks::FlowerPot => Some(5266),
            Blocks::PottedOakSapling => Some(5267),
            Blocks::PottedSpruceSapling => Some(5268),
            Blocks::PottedBirchSapling => Some(5269),
            Blocks::PottedJungleSapling => Some(5270),
            Blocks::PottedAcaciaSapling => Some(5271),
            Blocks::PottedDarkOakSapling => Some(5272),
            Blocks::PottedFern => Some(5273),
            Blocks::PottedDandelion => Some(5274),
            Blocks::PottedPoppy => Some(5275),
            Blocks::PottedBlueOrchid => Some(5276),
            Blocks::PottedAllium => Some(5277),
            Blocks::PottedAzureBluet => Some(5278),
            Blocks::PottedRedTulip => Some(5279),
            Blocks::PottedOrangeTulip => Some(5280),
            Blocks::PottedWhiteTulip => Some(5281),
            Blocks::PottedPinkTulip => Some(5282),
            Blocks::PottedOxeyeDaisy => Some(5283),
            Blocks::PottedCornflower => None,
            Blocks::PottedLilyOfTheValley => None,
            Blocks::PottedWitherRose => None,
            Blocks::PottedRedMushroom => Some(5284),
            Blocks::PottedBrownMushroom => Some(5285),
            Blocks::PottedDeadBush => Some(5286),
            Blocks::PottedCactus => Some(5287),
            Blocks::Carrots(state) => {
                Some(5288 + state.age)
            }
            Blocks::Potatoes(state) => {
                Some(5296 + state.age)
            }
            Blocks::OakButton(state) => {
                Some(5304 + (!state.powered() as i32) + 2 * (state.facing as i32) + 8 * (state.face as i32))
            }
            Blocks::SpruceButton(state) => {
                Some(5328 + (!state.powered() as i32) + 2 * (state.facing as i32) + 8 * (state.face as i32))
            }
            Blocks::BirchButton(state) => {
                Some(5352 + (!state.powered() as i32) + 2 * (state.facing as i32) + 8 * (state.face as i32))
            }
            Blocks::JungleButton(state) => {
                Some(5376 + (!state.powered() as i32) + 2 * (state.facing as i32) + 8 * (state.face as i32))
            }
            Blocks::AcaciaButton(state) => {
                Some(5400 + (!state.powered() as i32) + 2 * (state.facing as i32) + 8 * (state.face as i32))
            }
            Blocks::DarkOakButton(state) => {
                Some(5424 + (!state.powered() as i32) + 2 * (state.facing as i32) + 8 * (state.face as i32))
            }
            Blocks::SkeletonSkull(state) => {
                Some(5452 + state.rotation)
            }
            Blocks::SkeletonWallSkull(state) => {
                Some(5448 + (state.facing as i32))
            }
            Blocks::WitherSkeletonSkull(state) => {
                Some(5472 + state.rotation)
            }
            Blocks::WitherSkeletonWallSkull(state) => {
                Some(5468 + (state.facing as i32))
            }
            Blocks::ZombieHead(state) => {
                Some(5492 + state.rotation)
            }
            Blocks::ZombieWallHead(state) => {
                Some(5488 + (state.facing as i32))
            }
            Blocks::PlayerHead(state) => {
                Some(5512 + state.rotation)
            }
            Blocks::PlayerWallHead(state) => {
                Some(5508 + (state.facing as i32))
            }
            Blocks::CreeperHead(state) => {
                Some(5532 + state.rotation)
            }
            Blocks::CreeperWallHead(state) => {
                Some(5528 + (state.facing as i32))
            }
            Blocks::DragonHead(state) => {
                Some(5552 + state.rotation)
            }
            Blocks::DragonWallHead(state) => {
                Some(5548 + (state.facing as i32))
            }
            Blocks::Anvil(state) => {
                Some(5568 + (state.facing as i32))
            }
            Blocks::ChippedAnvil(state) => {
                Some(5572 + (state.facing as i32))
            }
            Blocks::DamagedAnvil(state) => {
                Some(5576 + (state.facing as i32))
            }
            Blocks::TrappedChest(state) => {
                Some(5580 + (!state.waterlogged() as i32) + 2 * (state.typed as i32) + 6 * (state.facing as i32))
            }
            Blocks::LightWeightedPressurePlate(state) => {
                Some(5604 + state.power)
            }
            Blocks::HeavyWeightedPressurePlate(state) => {
                Some(5620 + state.power)
            }
            Blocks::Comparator(state) => {
                Some(5636 + (!state.powered() as i32) + 2 * (state.mode as i32) + 4 * (state.facing as i32))
            }
            Blocks::DaylightDetector(state) => {
                Some(5652 + state.power + 16 * (!state.inverted() as i32))
            }
            Blocks::RedstoneBlock => Some(5684),
            Blocks::NetherQuartzOre => Some(5685),
            Blocks::Hopper(state) => {
                Some(5686 + (state.facing as i32) + 5 * (!state.enabled() as i32))
            }
            Blocks::QuartzBlock => Some(5696),
            Blocks::ChiseledQuartzBlock => Some(5697),
            Blocks::QuartzPillar(state) => {
                Some(5698 + (state.axis as i32))
            }
            Blocks::QuartzStairs(state) => {
                Some(5701 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::ActivatorRail(state) => {
                Some(5781 + (state.shape as i32) + 6 * (!state.powered() as i32))
            }
            Blocks::Dropper(state) => {
                Some(5793 + (!state.triggered() as i32) + 2 * (state.facing as i32))
            }
            Blocks::WhiteTerracotta => Some(5805),
            Blocks::OrangeTerracotta => Some(5806),
            Blocks::MagentaTerracotta => Some(5807),
            Blocks::LightBlueTerracotta => Some(5808),
            Blocks::YellowTerracotta => Some(5809),
            Blocks::LimeTerracotta => Some(5810),
            Blocks::PinkTerracotta => Some(5811),
            Blocks::GrayTerracotta => Some(5812),
            Blocks::LightGrayTerracotta => Some(5813),
            Blocks::CyanTerracotta => Some(5814),
            Blocks::PurpleTerracotta => Some(5815),
            Blocks::BlueTerracotta => Some(5816),
            Blocks::BrownTerracotta => Some(5817),
            Blocks::GreenTerracotta => Some(5818),
            Blocks::RedTerracotta => Some(5819),
            Blocks::BlackTerracotta => Some(5820),
            Blocks::WhiteStainedGlassPane(state) => {
                Some(5821 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::OrangeStainedGlassPane(state) => {
                Some(5853 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::MagentaStainedGlassPane(state) => {
                Some(5885 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::LightBlueStainedGlassPane(state) => {
                Some(5917 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::YellowStainedGlassPane(state) => {
                Some(5949 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::LimeStainedGlassPane(state) => {
                Some(5981 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::PinkStainedGlassPane(state) => {
                Some(6013 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::GrayStainedGlassPane(state) => {
                Some(6045 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::LightGrayStainedGlassPane(state) => {
                Some(6077 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::CyanStainedGlassPane(state) => {
                Some(6109 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::PurpleStainedGlassPane(state) => {
                Some(6141 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::BlueStainedGlassPane(state) => {
                Some(6173 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::BrownStainedGlassPane(state) => {
                Some(6205 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::GreenStainedGlassPane(state) => {
                Some(6237 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::RedStainedGlassPane(state) => {
                Some(6269 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::BlackStainedGlassPane(state) => {
                Some(6301 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::AcaciaStairs(state) => {
                Some(6333 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::DarkOakStairs(state) => {
                Some(6413 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::SlimeBlock => Some(6493),
            Blocks::Barrier => Some(6494),
            Blocks::Light(_) => None,
            Blocks::IronTrapdoor(state) => {
                Some(6495 + (!state.waterlogged() as i32) + 2 * (!state.powered() as i32) + 4 * (!state.open() as i32) + 8 * (state.half as i32) + 16 * (state.facing as i32))
            }
            Blocks::Prismarine => Some(6559),
            Blocks::PrismarineBricks => Some(6560),
            Blocks::DarkPrismarine => Some(6561),
            Blocks::PrismarineStairs(state) => {
                Some(6562 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::PrismarineBrickStairs(state) => {
                Some(6642 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::DarkPrismarineStairs(state) => {
                Some(6722 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::PrismarineSlab(state) => {
                Some(6802 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::PrismarineBrickSlab(state) => {
                Some(6808 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::DarkPrismarineSlab(state) => {
                Some(6814 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::SeaLantern => Some(6820),
            Blocks::HayBlock(state) => {
                Some(6821 + (state.axis as i32))
            }
            Blocks::WhiteCarpet => Some(6824),
            Blocks::OrangeCarpet => Some(6825),
            Blocks::MagentaCarpet => Some(6826),
            Blocks::LightBlueCarpet => Some(6827),
            Blocks::YellowCarpet => Some(6828),
            Blocks::LimeCarpet => Some(6829),
            Blocks::PinkCarpet => Some(6830),
            Blocks::GrayCarpet => Some(6831),
            Blocks::LightGrayCarpet => Some(6832),
            Blocks::CyanCarpet => Some(6833),
            Blocks::PurpleCarpet => Some(6834),
            Blocks::BlueCarpet => Some(6835),
            Blocks::BrownCarpet => Some(6836),
            Blocks::GreenCarpet => Some(6837),
            Blocks::RedCarpet => Some(6838),
            Blocks::BlackCarpet => Some(6839),
            Blocks::Terracotta => Some(6840),
            Blocks::CoalBlock => Some(6841),
            Blocks::PackedIce => Some(6842),
            Blocks::Sunflower(state) => {
                Some(6843 + (state.half as i32))
            }
            Blocks::Lilac(state) => {
                Some(6845 + (state.half as i32))
            }
            Blocks::RoseBush(state) => {
                Some(6847 + (state.half as i32))
            }
            Blocks::Peony(state) => {
                Some(6849 + (state.half as i32))
            }
            Blocks::TallGrass(state) => {
                Some(6851 + (state.half as i32))
            }
            Blocks::LargeFern(state) => {
                Some(6853 + (state.half as i32))
            }
            Blocks::WhiteBanner(state) => {
                Some(6855 + state.rotation)
            }
            Blocks::OrangeBanner(state) => {
                Some(6871 + state.rotation)
            }
            Blocks::MagentaBanner(state) => {
                Some(6887 + state.rotation)
            }
            Blocks::LightBlueBanner(state) => {
                Some(6903 + state.rotation)
            }
            Blocks::YellowBanner(state) => {
                Some(6919 + state.rotation)
            }
            Blocks::LimeBanner(state) => {
                Some(6935 + state.rotation)
            }
            Blocks::PinkBanner(state) => {
                Some(6951 + state.rotation)
            }
            Blocks::GrayBanner(state) => {
                Some(6967 + state.rotation)
            }
            Blocks::LightGrayBanner(state) => {
                Some(6983 + state.rotation)
            }
            Blocks::CyanBanner(state) => {
                Some(6999 + state.rotation)
            }
            Blocks::PurpleBanner(state) => {
                Some(7015 + state.rotation)
            }
            Blocks::BlueBanner(state) => {
                Some(7031 + state.rotation)
            }
            Blocks::BrownBanner(state) => {
                Some(7047 + state.rotation)
            }
            Blocks::GreenBanner(state) => {
                Some(7063 + state.rotation)
            }
            Blocks::RedBanner(state) => {
                Some(7079 + state.rotation)
            }
            Blocks::BlackBanner(state) => {
                Some(7095 + state.rotation)
            }
            Blocks::WhiteWallBanner(state) => {
                Some(7111 + (state.facing as i32))
            }
            Blocks::OrangeWallBanner(state) => {
                Some(7115 + (state.facing as i32))
            }
            Blocks::MagentaWallBanner(state) => {
                Some(7119 + (state.facing as i32))
            }
            Blocks::LightBlueWallBanner(state) => {
                Some(7123 + (state.facing as i32))
            }
            Blocks::YellowWallBanner(state) => {
                Some(7127 + (state.facing as i32))
            }
            Blocks::LimeWallBanner(state) => {
                Some(7131 + (state.facing as i32))
            }
            Blocks::PinkWallBanner(state) => {
                Some(7135 + (state.facing as i32))
            }
            Blocks::GrayWallBanner(state) => {
                Some(7139 + (state.facing as i32))
            }
            Blocks::LightGrayWallBanner(state) => {
                Some(7143 + (state.facing as i32))
            }
            Blocks::CyanWallBanner(state) => {
                Some(7147 + (state.facing as i32))
            }
            Blocks::PurpleWallBanner(state) => {
                Some(7151 + (state.facing as i32))
            }
            Blocks::BlueWallBanner(state) => {
                Some(7155 + (state.facing as i32))
            }
            Blocks::BrownWallBanner(state) => {
                Some(7159 + (state.facing as i32))
            }
            Blocks::GreenWallBanner(state) => {
                Some(7163 + (state.facing as i32))
            }
            Blocks::RedWallBanner(state) => {
                Some(7167 + (state.facing as i32))
            }
            Blocks::BlackWallBanner(state) => {
                Some(7171 + (state.facing as i32))
            }
            Blocks::RedSandstone => Some(7175),
            Blocks::ChiseledRedSandstone => Some(7176),
            Blocks::CutRedSandstone => Some(7177),
            Blocks::RedSandstoneStairs(state) => {
                Some(7178 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::OakSlab(state) => {
                Some(7258 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::SpruceSlab(state) => {
                Some(7264 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::BirchSlab(state) => {
                Some(7270 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::JungleSlab(state) => {
                Some(7276 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::AcaciaSlab(state) => {
                Some(7282 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::DarkOakSlab(state) => {
                Some(7288 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::StoneSlab(state) => {
                Some(7294 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::SmoothStoneSlab(_) => None,
            Blocks::SandstoneSlab(state) => {
                Some(7300 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::CutSandstoneSlab(_) => None,
            Blocks::PetrifiedOakSlab(state) => {
                Some(7306 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::CobblestoneSlab(state) => {
                Some(7312 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::BrickSlab(state) => {
                Some(7318 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::StoneBrickSlab(state) => {
                Some(7324 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::NetherBrickSlab(state) => {
                Some(7330 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::QuartzSlab(state) => {
                Some(7336 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::RedSandstoneSlab(state) => {
                Some(7342 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::CutRedSandstoneSlab(_) => None,
            Blocks::PurpurSlab(state) => {
                Some(7348 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::SmoothStone => Some(7354),
            Blocks::SmoothSandstone => Some(7355),
            Blocks::SmoothQuartz => Some(7356),
            Blocks::SmoothRedSandstone => Some(7357),
            Blocks::SpruceFenceGate(state) => {
                Some(7358 + (!state.powered() as i32) + 2 * (!state.open() as i32) + 4 * (!state.in_wall() as i32) + 8 * (state.facing as i32))
            }
            Blocks::BirchFenceGate(state) => {
                Some(7390 + (!state.powered() as i32) + 2 * (!state.open() as i32) + 4 * (!state.in_wall() as i32) + 8 * (state.facing as i32))
            }
            Blocks::JungleFenceGate(state) => {
                Some(7422 + (!state.powered() as i32) + 2 * (!state.open() as i32) + 4 * (!state.in_wall() as i32) + 8 * (state.facing as i32))
            }
            Blocks::AcaciaFenceGate(state) => {
                Some(7454 + (!state.powered() as i32) + 2 * (!state.open() as i32) + 4 * (!state.in_wall() as i32) + 8 * (state.facing as i32))
            }
            Blocks::DarkOakFenceGate(state) => {
                Some(7486 + (!state.powered() as i32) + 2 * (!state.open() as i32) + 4 * (!state.in_wall() as i32) + 8 * (state.facing as i32))
            }
            Blocks::SpruceFence(state) => {
                Some(7518 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::BirchFence(state) => {
                Some(7550 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::JungleFence(state) => {
                Some(7582 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::AcaciaFence(state) => {
                Some(7614 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::DarkOakFence(state) => {
                Some(7646 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::SpruceDoor(state) => {
                Some(7678 + (!state.powered() as i32) + 2 * (!state.open() as i32) + 4 * (state.hinge as i32) + 8 * (state.half as i32) + 16 * (state.facing as i32))
            }
            Blocks::BirchDoor(state) => {
                Some(7742 + (!state.powered() as i32) + 2 * (!state.open() as i32) + 4 * (state.hinge as i32) + 8 * (state.half as i32) + 16 * (state.facing as i32))
            }
            Blocks::JungleDoor(state) => {
                Some(7806 + (!state.powered() as i32) + 2 * (!state.open() as i32) + 4 * (state.hinge as i32) + 8 * (state.half as i32) + 16 * (state.facing as i32))
            }
            Blocks::AcaciaDoor(state) => {
                Some(7870 + (!state.powered() as i32) + 2 * (!state.open() as i32) + 4 * (state.hinge as i32) + 8 * (state.half as i32) + 16 * (state.facing as i32))
            }
            Blocks::DarkOakDoor(state) => {
                Some(7934 + (!state.powered() as i32) + 2 * (!state.open() as i32) + 4 * (state.hinge as i32) + 8 * (state.half as i32) + 16 * (state.facing as i32))
            }
            Blocks::EndRod(state) => {
                Some(7998 + (state.facing as i32))
            }
            Blocks::ChorusPlant(state) => {
                Some(8004 + (!state.west() as i32) + 2 * (!state.up() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32) + 32 * (!state.down() as i32))
            }
            Blocks::ChorusFlower(state) => {
                Some(8068 + state.age)
            }
            Blocks::PurpurBlock => Some(8074),
            Blocks::PurpurPillar(state) => {
                Some(8075 + (state.axis as i32))
            }
            Blocks::PurpurStairs(state) => {
                Some(8078 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::EndStoneBricks => Some(8158),
            Blocks::Beetroots(state) => {
                Some(8159 + state.age)
            }
            Blocks::DirtPath => Some(8163),
            Blocks::EndGateway => Some(8164),
            Blocks::RepeatingCommandBlock(state) => {
                Some(8165 + (state.facing as i32) + 6 * (!state.conditional() as i32))
            }
            Blocks::ChainCommandBlock(state) => {
                Some(8177 + (state.facing as i32) + 6 * (!state.conditional() as i32))
            }
            Blocks::FrostedIce(state) => {
                Some(8189 + state.age)
            }
            Blocks::MagmaBlock => Some(8193),
            Blocks::NetherWartBlock => Some(8194),
            Blocks::RedNetherBricks => Some(8195),
            Blocks::BoneBlock(state) => {
                Some(8196 + (state.axis as i32))
            }
            Blocks::StructureVoid => Some(8199),
            Blocks::Observer(state) => {
                Some(8200 + (!state.powered() as i32) + 2 * (state.facing as i32))
            }
            Blocks::ShulkerBox(state) => {
                Some(8212 + (state.facing as i32))
            }
            Blocks::WhiteShulkerBox(state) => {
                Some(8218 + (state.facing as i32))
            }
            Blocks::OrangeShulkerBox(state) => {
                Some(8224 + (state.facing as i32))
            }
            Blocks::MagentaShulkerBox(state) => {
                Some(8230 + (state.facing as i32))
            }
            Blocks::LightBlueShulkerBox(state) => {
                Some(8236 + (state.facing as i32))
            }
            Blocks::YellowShulkerBox(state) => {
                Some(8242 + (state.facing as i32))
            }
            Blocks::LimeShulkerBox(state) => {
                Some(8248 + (state.facing as i32))
            }
            Blocks::PinkShulkerBox(state) => {
                Some(8254 + (state.facing as i32))
            }
            Blocks::GrayShulkerBox(state) => {
                Some(8260 + (state.facing as i32))
            }
            Blocks::LightGrayShulkerBox(state) => {
                Some(8266 + (state.facing as i32))
            }
            Blocks::CyanShulkerBox(state) => {
                Some(8272 + (state.facing as i32))
            }
            Blocks::PurpleShulkerBox(state) => {
                Some(8278 + (state.facing as i32))
            }
            Blocks::BlueShulkerBox(state) => {
                Some(8284 + (state.facing as i32))
            }
            Blocks::BrownShulkerBox(state) => {
                Some(8290 + (state.facing as i32))
            }
            Blocks::GreenShulkerBox(state) => {
                Some(8296 + (state.facing as i32))
            }
            Blocks::RedShulkerBox(state) => {
                Some(8302 + (state.facing as i32))
            }
            Blocks::BlackShulkerBox(state) => {
                Some(8308 + (state.facing as i32))
            }
            Blocks::WhiteGlazedTerracotta(state) => {
                Some(8314 + (state.facing as i32))
            }
            Blocks::OrangeGlazedTerracotta(state) => {
                Some(8318 + (state.facing as i32))
            }
            Blocks::MagentaGlazedTerracotta(state) => {
                Some(8322 + (state.facing as i32))
            }
            Blocks::LightBlueGlazedTerracotta(state) => {
                Some(8326 + (state.facing as i32))
            }
            Blocks::YellowGlazedTerracotta(state) => {
                Some(8330 + (state.facing as i32))
            }
            Blocks::LimeGlazedTerracotta(state) => {
                Some(8334 + (state.facing as i32))
            }
            Blocks::PinkGlazedTerracotta(state) => {
                Some(8338 + (state.facing as i32))
            }
            Blocks::GrayGlazedTerracotta(state) => {
                Some(8342 + (state.facing as i32))
            }
            Blocks::LightGrayGlazedTerracotta(state) => {
                Some(8346 + (state.facing as i32))
            }
            Blocks::CyanGlazedTerracotta(state) => {
                Some(8350 + (state.facing as i32))
            }
            Blocks::PurpleGlazedTerracotta(state) => {
                Some(8354 + (state.facing as i32))
            }
            Blocks::BlueGlazedTerracotta(state) => {
                Some(8358 + (state.facing as i32))
            }
            Blocks::BrownGlazedTerracotta(state) => {
                Some(8362 + (state.facing as i32))
            }
            Blocks::GreenGlazedTerracotta(state) => {
                Some(8366 + (state.facing as i32))
            }
            Blocks::RedGlazedTerracotta(state) => {
                Some(8370 + (state.facing as i32))
            }
            Blocks::BlackGlazedTerracotta(state) => {
                Some(8374 + (state.facing as i32))
            }
            Blocks::WhiteConcrete => Some(8378),
            Blocks::OrangeConcrete => Some(8379),
            Blocks::MagentaConcrete => Some(8380),
            Blocks::LightBlueConcrete => Some(8381),
            Blocks::YellowConcrete => Some(8382),
            Blocks::LimeConcrete => Some(8383),
            Blocks::PinkConcrete => Some(8384),
            Blocks::GrayConcrete => Some(8385),
            Blocks::LightGrayConcrete => Some(8386),
            Blocks::CyanConcrete => Some(8387),
            Blocks::PurpleConcrete => Some(8388),
            Blocks::BlueConcrete => Some(8389),
            Blocks::BrownConcrete => Some(8390),
            Blocks::GreenConcrete => Some(8391),
            Blocks::RedConcrete => Some(8392),
            Blocks::BlackConcrete => Some(8393),
            Blocks::WhiteConcretePowder => Some(8394),
            Blocks::OrangeConcretePowder => Some(8395),
            Blocks::MagentaConcretePowder => Some(8396),
            Blocks::LightBlueConcretePowder => Some(8397),
            Blocks::YellowConcretePowder => Some(8398),
            Blocks::LimeConcretePowder => Some(8399),
            Blocks::PinkConcretePowder => Some(8400),
            Blocks::GrayConcretePowder => Some(8401),
            Blocks::LightGrayConcretePowder => Some(8402),
            Blocks::CyanConcretePowder => Some(8403),
            Blocks::PurpleConcretePowder => Some(8404),
            Blocks::BlueConcretePowder => Some(8405),
            Blocks::BrownConcretePowder => Some(8406),
            Blocks::GreenConcretePowder => Some(8407),
            Blocks::RedConcretePowder => Some(8408),
            Blocks::BlackConcretePowder => Some(8409),
            Blocks::Kelp(state) => {
                Some(8410 + state.age)
            }
            Blocks::KelpPlant => Some(8436),
            Blocks::DriedKelpBlock => Some(8437),
            Blocks::TurtleEgg(state) => {
                Some(8438 + state.hatch + 3 * state.eggs)
            }
            Blocks::DeadTubeCoralBlock => Some(8450),
            Blocks::DeadBrainCoralBlock => Some(8451),
            Blocks::DeadBubbleCoralBlock => Some(8452),
            Blocks::DeadFireCoralBlock => Some(8453),
            Blocks::DeadHornCoralBlock => Some(8454),
            Blocks::TubeCoralBlock => Some(8455),
            Blocks::BrainCoralBlock => Some(8456),
            Blocks::BubbleCoralBlock => Some(8457),
            Blocks::FireCoralBlock => Some(8458),
            Blocks::HornCoralBlock => Some(8459),
            Blocks::DeadTubeCoral(state) => {
                Some(8460 + (!state.waterlogged() as i32))
            }
            Blocks::DeadBrainCoral(state) => {
                Some(8462 + (!state.waterlogged() as i32))
            }
            Blocks::DeadBubbleCoral(state) => {
                Some(8464 + (!state.waterlogged() as i32))
            }
            Blocks::DeadFireCoral(state) => {
                Some(8466 + (!state.waterlogged() as i32))
            }
            Blocks::DeadHornCoral(state) => {
                Some(8468 + (!state.waterlogged() as i32))
            }
            Blocks::TubeCoral(state) => {
                Some(8470 + (!state.waterlogged() as i32))
            }
            Blocks::BrainCoral(state) => {
                Some(8472 + (!state.waterlogged() as i32))
            }
            Blocks::BubbleCoral(state) => {
                Some(8474 + (!state.waterlogged() as i32))
            }
            Blocks::FireCoral(state) => {
                Some(8476 + (!state.waterlogged() as i32))
            }
            Blocks::HornCoral(state) => {
                Some(8478 + (!state.waterlogged() as i32))
            }
            Blocks::DeadTubeCoralFan(state) => {
                Some(8560 + (!state.waterlogged() as i32))
            }
            Blocks::DeadBrainCoralFan(state) => {
                Some(8562 + (!state.waterlogged() as i32))
            }
            Blocks::DeadBubbleCoralFan(state) => {
                Some(8564 + (!state.waterlogged() as i32))
            }
            Blocks::DeadFireCoralFan(state) => {
                Some(8566 + (!state.waterlogged() as i32))
            }
            Blocks::DeadHornCoralFan(state) => {
                Some(8568 + (!state.waterlogged() as i32))
            }
            Blocks::TubeCoralFan(state) => {
                Some(8570 + (!state.waterlogged() as i32))
            }
            Blocks::BrainCoralFan(state) => {
                Some(8572 + (!state.waterlogged() as i32))
            }
            Blocks::BubbleCoralFan(state) => {
                Some(8574 + (!state.waterlogged() as i32))
            }
            Blocks::FireCoralFan(state) => {
                Some(8576 + (!state.waterlogged() as i32))
            }
            Blocks::HornCoralFan(state) => {
                Some(8578 + (!state.waterlogged() as i32))
            }
            Blocks::DeadTubeCoralWallFan(state) => {
                Some(8480 + (!state.waterlogged() as i32) + 2 * (state.facing as i32))
            }
            Blocks::DeadBrainCoralWallFan(state) => {
                Some(8488 + (!state.waterlogged() as i32) + 2 * (state.facing as i32))
            }
            Blocks::DeadBubbleCoralWallFan(state) => {
                Some(8496 + (!state.waterlogged() as i32) + 2 * (state.facing as i32))
            }
            Blocks::DeadFireCoralWallFan(state) => {
                Some(8504 + (!state.waterlogged() as i32) + 2 * (state.facing as i32))
            }
            Blocks::DeadHornCoralWallFan(state) => {
                Some(8512 + (!state.waterlogged() as i32) + 2 * (state.facing as i32))
            }
            Blocks::TubeCoralWallFan(state) => {
                Some(8520 + (!state.waterlogged() as i32) + 2 * (state.facing as i32))
            }
            Blocks::BrainCoralWallFan(state) => {
                Some(8528 + (!state.waterlogged() as i32) + 2 * (state.facing as i32))
            }
            Blocks::BubbleCoralWallFan(state) => {
                Some(8536 + (!state.waterlogged() as i32) + 2 * (state.facing as i32))
            }
            Blocks::FireCoralWallFan(state) => {
                Some(8544 + (!state.waterlogged() as i32) + 2 * (state.facing as i32))
            }
            Blocks::HornCoralWallFan(state) => {
                Some(8552 + (!state.waterlogged() as i32) + 2 * (state.facing as i32))
            }
            Blocks::SeaPickle(state) => {
                Some(8580 + (!state.waterlogged() as i32) + 2 * state.pickles)
            }
            Blocks::BlueIce => Some(8588),
            Blocks::Conduit(state) => {
                Some(8589 + (!state.waterlogged() as i32))
            }
            Blocks::BambooSapling => None,
            Blocks::Bamboo(_) => None,
            Blocks::PottedBamboo => None,
            Blocks::VoidAir => Some(8591),
            Blocks::CaveAir => Some(8592),
            Blocks::BubbleColumn(state) => {
                Some(8593 + (!state.drag() as i32))
            }
            Blocks::PolishedGraniteStairs(_) => None,
            Blocks::SmoothRedSandstoneStairs(_) => None,
            Blocks::MossyStoneBrickStairs(_) => None,
            Blocks::PolishedDioriteStairs(_) => None,
            Blocks::MossyCobblestoneStairs(_) => None,
            Blocks::EndStoneBrickStairs(_) => None,
            Blocks::StoneStairs(_) => None,
            Blocks::SmoothSandstoneStairs(_) => None,
            Blocks::SmoothQuartzStairs(_) => None,
            Blocks::GraniteStairs(_) => None,
            Blocks::AndesiteStairs(_) => None,
            Blocks::RedNetherBrickStairs(_) => None,
            Blocks::PolishedAndesiteStairs(_) => None,
            Blocks::DioriteStairs(_) => None,
            Blocks::PolishedGraniteSlab(_) => None,
            Blocks::SmoothRedSandstoneSlab(_) => None,
            Blocks::MossyStoneBrickSlab(_) => None,
            Blocks::PolishedDioriteSlab(_) => None,
            Blocks::MossyCobblestoneSlab(_) => None,
            Blocks::EndStoneBrickSlab(_) => None,
            Blocks::SmoothSandstoneSlab(_) => None,
            Blocks::SmoothQuartzSlab(_) => None,
            Blocks::GraniteSlab(_) => None,
            Blocks::AndesiteSlab(_) => None,
            Blocks::RedNetherBrickSlab(_) => None,
            Blocks::PolishedAndesiteSlab(_) => None,
            Blocks::DioriteSlab(_) => None,
            Blocks::BrickWall(_) => None,
            Blocks::PrismarineWall(_) => None,
            Blocks::RedSandstoneWall(_) => None,
            Blocks::MossyStoneBrickWall(_) => None,
            Blocks::GraniteWall(_) => None,
            Blocks::StoneBrickWall(_) => None,
            Blocks::NetherBrickWall(_) => None,
            Blocks::AndesiteWall(_) => None,
            Blocks::RedNetherBrickWall(_) => None,
            Blocks::SandstoneWall(_) => None,
            Blocks::EndStoneBrickWall(_) => None,
            Blocks::DioriteWall(_) => None,
            Blocks::Scaffolding(_) => None,
            Blocks::Loom(_) => None,
            Blocks::Barrel(_) => None,
            Blocks::Smoker(_) => None,
            Blocks::BlastFurnace(_) => None,
            Blocks::CartographyTable => None,
            Blocks::FletchingTable => None,
            Blocks::Grindstone(_) => None,
            Blocks::Lectern(_) => None,
            Blocks::SmithingTable => None,
            Blocks::Stonecutter(_) => None,
            Blocks::Bell(_) => None,
            Blocks::Lantern(_) => None,
            Blocks::SoulLantern(_) => None,
            Blocks::Campfire(_) => None,
            Blocks::SoulCampfire(_) => None,
            Blocks::SweetBerryBush(_) => None,
            Blocks::WarpedStem(_) => None,
            Blocks::StrippedWarpedStem(_) => None,
            Blocks::WarpedHyphae(_) => None,
            Blocks::StrippedWarpedHyphae(_) => None,
            Blocks::WarpedNylium => None,
            Blocks::WarpedFungus => None,
            Blocks::WarpedWartBlock => None,
            Blocks::WarpedRoots => None,
            Blocks::NetherSprouts => None,
            Blocks::CrimsonStem(_) => None,
            Blocks::StrippedCrimsonStem(_) => None,
            Blocks::CrimsonHyphae(_) => None,
            Blocks::StrippedCrimsonHyphae(_) => None,
            Blocks::CrimsonNylium => None,
            Blocks::CrimsonFungus => None,
            Blocks::Shroomlight => None,
            Blocks::WeepingVines(_) => None,
            Blocks::WeepingVinesPlant => None,
            Blocks::TwistingVines(_) => None,
            Blocks::TwistingVinesPlant => None,
            Blocks::CrimsonRoots => None,
            Blocks::CrimsonPlanks => None,
            Blocks::WarpedPlanks => None,
            Blocks::CrimsonSlab(_) => None,
            Blocks::WarpedSlab(_) => None,
            Blocks::CrimsonPressurePlate(_) => None,
            Blocks::WarpedPressurePlate(_) => None,
            Blocks::CrimsonFence(_) => None,
            Blocks::WarpedFence(_) => None,
            Blocks::CrimsonTrapdoor(_) => None,
            Blocks::WarpedTrapdoor(_) => None,
            Blocks::CrimsonFenceGate(_) => None,
            Blocks::WarpedFenceGate(_) => None,
            Blocks::CrimsonStairs(_) => None,
            Blocks::WarpedStairs(_) => None,
            Blocks::CrimsonButton(_) => None,
            Blocks::WarpedButton(_) => None,
            Blocks::CrimsonDoor(_) => None,
            Blocks::WarpedDoor(_) => None,
            Blocks::CrimsonSign(_) => None,
            Blocks::WarpedSign(_) => None,
            Blocks::CrimsonWallSign(_) => None,
            Blocks::WarpedWallSign(_) => None,
            Blocks::StructureBlock(state) => {
                Some(8595 + (state.mode as i32))
            }
            Blocks::Jigsaw(_) => None,
            Blocks::Composter(_) => None,
            Blocks::Target(_) => None,
            Blocks::BeeNest(_) => None,
            Blocks::Beehive(_) => None,
            Blocks::HoneyBlock => None,
            Blocks::HoneycombBlock => None,
            Blocks::NetheriteBlock => None,
            Blocks::AncientDebris => None,
            Blocks::CryingObsidian => None,
            Blocks::RespawnAnchor(_) => None,
            Blocks::PottedCrimsonFungus => None,
            Blocks::PottedWarpedFungus => None,
            Blocks::PottedCrimsonRoots => None,
            Blocks::PottedWarpedRoots => None,
            Blocks::Lodestone => None,
            Blocks::Blackstone => None,
            Blocks::BlackstoneStairs(_) => None,
            Blocks::BlackstoneWall(_) => None,
            Blocks::BlackstoneSlab(_) => None,
            Blocks::PolishedBlackstone => None,
            Blocks::PolishedBlackstoneBricks => None,
            Blocks::CrackedPolishedBlackstoneBricks => None,
            Blocks::ChiseledPolishedBlackstone => None,
            Blocks::PolishedBlackstoneBrickSlab(_) => None,
            Blocks::PolishedBlackstoneBrickStairs(_) => None,
            Blocks::PolishedBlackstoneBrickWall(_) => None,
            Blocks::GildedBlackstone => None,
            Blocks::PolishedBlackstoneStairs(_) => None,
            Blocks::PolishedBlackstoneSlab(_) => None,
            Blocks::PolishedBlackstonePressurePlate(_) => None,
            Blocks::PolishedBlackstoneButton(_) => None,
            Blocks::PolishedBlackstoneWall(_) => None,
            Blocks::ChiseledNetherBricks => None,
            Blocks::CrackedNetherBricks => None,
            Blocks::QuartzBricks => None,
            Blocks::Candle(_) => None,
            Blocks::WhiteCandle(_) => None,
            Blocks::OrangeCandle(_) => None,
            Blocks::MagentaCandle(_) => None,
            Blocks::LightBlueCandle(_) => None,
            Blocks::YellowCandle(_) => None,
            Blocks::LimeCandle(_) => None,
            Blocks::PinkCandle(_) => None,
            Blocks::GrayCandle(_) => None,
            Blocks::LightGrayCandle(_) => None,
            Blocks::CyanCandle(_) => None,
            Blocks::PurpleCandle(_) => None,
            Blocks::BlueCandle(_) => None,
            Blocks::BrownCandle(_) => None,
            Blocks::GreenCandle(_) => None,
            Blocks::RedCandle(_) => None,
            Blocks::BlackCandle(_) => None,
            Blocks::CandleCake(_) => None,
            Blocks::WhiteCandleCake(_) => None,
            Blocks::OrangeCandleCake(_) => None,
            Blocks::MagentaCandleCake(_) => None,
            Blocks::LightBlueCandleCake(_) => None,
            Blocks::YellowCandleCake(_) => None,
            Blocks::LimeCandleCake(_) => None,
            Blocks::PinkCandleCake(_) => None,
            Blocks::GrayCandleCake(_) => None,
            Blocks::LightGrayCandleCake(_) => None,
            Blocks::CyanCandleCake(_) => None,
            Blocks::PurpleCandleCake(_) => None,
            Blocks::BlueCandleCake(_) => None,
            Blocks::BrownCandleCake(_) => None,
            Blocks::GreenCandleCake(_) => None,
            Blocks::RedCandleCake(_) => None,
            Blocks::BlackCandleCake(_) => None,
            Blocks::AmethystBlock => None,
            Blocks::BuddingAmethyst => None,
            Blocks::AmethystCluster(_) => None,
            Blocks::LargeAmethystBud(_) => None,
            Blocks::MediumAmethystBud(_) => None,
            Blocks::SmallAmethystBud(_) => None,
            Blocks::Tuff => None,
            Blocks::Calcite => None,
            Blocks::TintedGlass => None,
            Blocks::PowderSnow => None,
            Blocks::SculkSensor(_) => None,
            Blocks::OxidizedCopper => None,
            Blocks::WeatheredCopper => None,
            Blocks::ExposedCopper => None,
            Blocks::CopperBlock => None,
            Blocks::CopperOre => None,
            Blocks::DeepslateCopperOre => None,
            Blocks::OxidizedCutCopper => None,
            Blocks::WeatheredCutCopper => None,
            Blocks::ExposedCutCopper => None,
            Blocks::CutCopper => None,
            Blocks::OxidizedCutCopperStairs(_) => None,
            Blocks::WeatheredCutCopperStairs(_) => None,
            Blocks::ExposedCutCopperStairs(_) => None,
            Blocks::CutCopperStairs(_) => None,
            Blocks::OxidizedCutCopperSlab(_) => None,
            Blocks::WeatheredCutCopperSlab(_) => None,
            Blocks::ExposedCutCopperSlab(_) => None,
            Blocks::CutCopperSlab(_) => None,
            Blocks::WaxedCopperBlock => None,
            Blocks::WaxedWeatheredCopper => None,
            Blocks::WaxedExposedCopper => None,
            Blocks::WaxedOxidizedCopper => None,
            Blocks::WaxedOxidizedCutCopper => None,
            Blocks::WaxedWeatheredCutCopper => None,
            Blocks::WaxedExposedCutCopper => None,
            Blocks::WaxedCutCopper => None,
            Blocks::WaxedOxidizedCutCopperStairs(_) => None,
            Blocks::WaxedWeatheredCutCopperStairs(_) => None,
            Blocks::WaxedExposedCutCopperStairs(_) => None,
            Blocks::WaxedCutCopperStairs(_) => None,
            Blocks::WaxedOxidizedCutCopperSlab(_) => None,
            Blocks::WaxedWeatheredCutCopperSlab(_) => None,
            Blocks::WaxedExposedCutCopperSlab(_) => None,
            Blocks::WaxedCutCopperSlab(_) => None,
            Blocks::LightningRod(_) => None,
            Blocks::PointedDripstone(_) => None,
            Blocks::DripstoneBlock => None,
            Blocks::CaveVines(_) => None,
            Blocks::CaveVinesPlant(_) => None,
            Blocks::SporeBlossom => None,
            Blocks::Azalea => None,
            Blocks::FloweringAzalea => None,
            Blocks::MossCarpet => None,
            Blocks::MossBlock => None,
            Blocks::BigDripleaf(_) => None,
            Blocks::BigDripleafStem(_) => None,
            Blocks::SmallDripleaf(_) => None,
            Blocks::HangingRoots(_) => None,
            Blocks::RootedDirt => None,
            Blocks::Deepslate(_) => None,
            Blocks::CobbledDeepslate => None,
            Blocks::CobbledDeepslateStairs(_) => None,
            Blocks::CobbledDeepslateSlab(_) => None,
            Blocks::CobbledDeepslateWall(_) => None,
            Blocks::PolishedDeepslate => None,
            Blocks::PolishedDeepslateStairs(_) => None,
            Blocks::PolishedDeepslateSlab(_) => None,
            Blocks::PolishedDeepslateWall(_) => None,
            Blocks::DeepslateTiles => None,
            Blocks::DeepslateTileStairs(_) => None,
            Blocks::DeepslateTileSlab(_) => None,
            Blocks::DeepslateTileWall(_) => None,
            Blocks::DeepslateBricks => None,
            Blocks::DeepslateBrickStairs(_) => None,
            Blocks::DeepslateBrickSlab(_) => None,
            Blocks::DeepslateBrickWall(_) => None,
            Blocks::ChiseledDeepslate => None,
            Blocks::CrackedDeepslateBricks => None,
            Blocks::CrackedDeepslateTiles => None,
            Blocks::InfestedDeepslate(_) => None,
            Blocks::SmoothBasalt => None,
            Blocks::RawIronBlock => None,
            Blocks::RawCopperBlock => None,
            Blocks::RawGoldBlock => None,
            Blocks::PottedAzaleaBush => None,
            Blocks::PottedFloweringAzaleaBush => None,
        }
    }
    pub fn get_global_id_1519(&self) -> Option<i32> {
        match self {
            Blocks::Air => Some(0),
            Blocks::Stone => Some(1),
            Blocks::Granite => Some(2),
            Blocks::PolishedGranite => Some(3),
            Blocks::Diorite => Some(4),
            Blocks::PolishedDiorite => Some(5),
            Blocks::Andesite => Some(6),
            Blocks::PolishedAndesite => Some(7),
            Blocks::GrassBlock(state) => {
                Some(8 + (!state.snowy() as i32))
            }
            Blocks::Dirt => Some(10),
            Blocks::CoarseDirt => Some(11),
            Blocks::Podzol(state) => {
                Some(12 + (!state.snowy() as i32))
            }
            Blocks::Cobblestone => Some(14),
            Blocks::OakPlanks => Some(15),
            Blocks::SprucePlanks => Some(16),
            Blocks::BirchPlanks => Some(17),
            Blocks::JunglePlanks => Some(18),
            Blocks::AcaciaPlanks => Some(19),
            Blocks::DarkOakPlanks => Some(20),
            Blocks::OakSapling(state) => {
                Some(21 + state.stage)
            }
            Blocks::SpruceSapling(state) => {
                Some(23 + state.stage)
            }
            Blocks::BirchSapling(state) => {
                Some(25 + state.stage)
            }
            Blocks::JungleSapling(state) => {
                Some(27 + state.stage)
            }
            Blocks::AcaciaSapling(state) => {
                Some(29 + state.stage)
            }
            Blocks::DarkOakSapling(state) => {
                Some(31 + state.stage)
            }
            Blocks::Bedrock => Some(33),
            Blocks::Water(state) => {
                Some(34 + state.level)
            }
            Blocks::Lava(state) => {
                Some(50 + state.level)
            }
            Blocks::Sand => Some(66),
            Blocks::RedSand => Some(67),
            Blocks::Gravel => Some(68),
            Blocks::GoldOre => Some(69),
            Blocks::DeepslateGoldOre => None,
            Blocks::IronOre => Some(70),
            Blocks::DeepslateIronOre => None,
            Blocks::CoalOre => Some(71),
            Blocks::DeepslateCoalOre => None,
            Blocks::NetherGoldOre => None,
            Blocks::OakLog(state) => {
                Some(72 + (state.axis as i32))
            }
            Blocks::SpruceLog(state) => {
                Some(75 + (state.axis as i32))
            }
            Blocks::BirchLog(state) => {
                Some(78 + (state.axis as i32))
            }
            Blocks::JungleLog(state) => {
                Some(81 + (state.axis as i32))
            }
            Blocks::AcaciaLog(state) => {
                Some(84 + (state.axis as i32))
            }
            Blocks::DarkOakLog(state) => {
                Some(87 + (state.axis as i32))
            }
            Blocks::StrippedSpruceLog(state) => {
                Some(90 + (state.axis as i32))
            }
            Blocks::StrippedBirchLog(state) => {
                Some(93 + (state.axis as i32))
            }
            Blocks::StrippedJungleLog(state) => {
                Some(96 + (state.axis as i32))
            }
            Blocks::StrippedAcaciaLog(state) => {
                Some(99 + (state.axis as i32))
            }
            Blocks::StrippedDarkOakLog(state) => {
                Some(102 + (state.axis as i32))
            }
            Blocks::StrippedOakLog(state) => {
                Some(105 + (state.axis as i32))
            }
            Blocks::OakWood(state) => {
                Some(108 + (state.axis as i32))
            }
            Blocks::SpruceWood(state) => {
                Some(111 + (state.axis as i32))
            }
            Blocks::BirchWood(state) => {
                Some(114 + (state.axis as i32))
            }
            Blocks::JungleWood(state) => {
                Some(117 + (state.axis as i32))
            }
            Blocks::AcaciaWood(state) => {
                Some(120 + (state.axis as i32))
            }
            Blocks::DarkOakWood(state) => {
                Some(123 + (state.axis as i32))
            }
            Blocks::StrippedOakWood(state) => {
                Some(126 + (state.axis as i32))
            }
            Blocks::StrippedSpruceWood(state) => {
                Some(129 + (state.axis as i32))
            }
            Blocks::StrippedBirchWood(state) => {
                Some(132 + (state.axis as i32))
            }
            Blocks::StrippedJungleWood(state) => {
                Some(135 + (state.axis as i32))
            }
            Blocks::StrippedAcaciaWood(state) => {
                Some(138 + (state.axis as i32))
            }
            Blocks::StrippedDarkOakWood(state) => {
                Some(141 + (state.axis as i32))
            }
            Blocks::OakLeaves(state) => {
                Some(144 + (!state.persistent() as i32) + 2 * state.distance)
            }
            Blocks::SpruceLeaves(state) => {
                Some(158 + (!state.persistent() as i32) + 2 * state.distance)
            }
            Blocks::BirchLeaves(state) => {
                Some(172 + (!state.persistent() as i32) + 2 * state.distance)
            }
            Blocks::JungleLeaves(state) => {
                Some(186 + (!state.persistent() as i32) + 2 * state.distance)
            }
            Blocks::AcaciaLeaves(state) => {
                Some(200 + (!state.persistent() as i32) + 2 * state.distance)
            }
            Blocks::DarkOakLeaves(state) => {
                Some(214 + (!state.persistent() as i32) + 2 * state.distance)
            }
            Blocks::AzaleaLeaves(_) => None,
            Blocks::FloweringAzaleaLeaves(_) => None,
            Blocks::Sponge => Some(228),
            Blocks::WetSponge => Some(229),
            Blocks::Glass => Some(230),
            Blocks::LapisOre => Some(231),
            Blocks::DeepslateLapisOre => None,
            Blocks::LapisBlock => Some(232),
            Blocks::Dispenser(state) => {
                Some(233 + (!state.triggered() as i32) + 2 * (state.facing as i32))
            }
            Blocks::Sandstone => Some(245),
            Blocks::ChiseledSandstone => Some(246),
            Blocks::CutSandstone => Some(247),
            Blocks::NoteBlock(state) => {
                if state.instrument > Instrument::Xylophone {
                    return None;
                }
                Some(248 + (!state.powered() as i32) + 2 * state.note + 50 * (state.instrument as i32))
            }
            Blocks::WhiteBed(state) => {
                Some(748 + (state.part as i32) + 2 * (!state.occupied() as i32) + 4 * (state.facing as i32))
            }
            Blocks::OrangeBed(state) => {
                Some(764 + (state.part as i32) + 2 * (!state.occupied() as i32) + 4 * (state.facing as i32))
            }
            Blocks::MagentaBed(state) => {
                Some(780 + (state.part as i32) + 2 * (!state.occupied() as i32) + 4 * (state.facing as i32))
            }
            Blocks::LightBlueBed(state) => {
                Some(796 + (state.part as i32) + 2 * (!state.occupied() as i32) + 4 * (state.facing as i32))
            }
            Blocks::YellowBed(state) => {
                Some(812 + (state.part as i32) + 2 * (!state.occupied() as i32) + 4 * (state.facing as i32))
            }
            Blocks::LimeBed(state) => {
                Some(828 + (state.part as i32) + 2 * (!state.occupied() as i32) + 4 * (state.facing as i32))
            }
            Blocks::PinkBed(state) => {
                Some(844 + (state.part as i32) + 2 * (!state.occupied() as i32) + 4 * (state.facing as i32))
            }
            Blocks::GrayBed(state) => {
                Some(860 + (state.part as i32) + 2 * (!state.occupied() as i32) + 4 * (state.facing as i32))
            }
            Blocks::LightGrayBed(state) => {
                Some(876 + (state.part as i32) + 2 * (!state.occupied() as i32) + 4 * (state.facing as i32))
            }
            Blocks::CyanBed(state) => {
                Some(892 + (state.part as i32) + 2 * (!state.occupied() as i32) + 4 * (state.facing as i32))
            }
            Blocks::PurpleBed(state) => {
                Some(908 + (state.part as i32) + 2 * (!state.occupied() as i32) + 4 * (state.facing as i32))
            }
            Blocks::BlueBed(state) => {
                Some(924 + (state.part as i32) + 2 * (!state.occupied() as i32) + 4 * (state.facing as i32))
            }
            Blocks::BrownBed(state) => {
                Some(940 + (state.part as i32) + 2 * (!state.occupied() as i32) + 4 * (state.facing as i32))
            }
            Blocks::GreenBed(state) => {
                Some(956 + (state.part as i32) + 2 * (!state.occupied() as i32) + 4 * (state.facing as i32))
            }
            Blocks::RedBed(state) => {
                Some(972 + (state.part as i32) + 2 * (!state.occupied() as i32) + 4 * (state.facing as i32))
            }
            Blocks::BlackBed(state) => {
                Some(988 + (state.part as i32) + 2 * (!state.occupied() as i32) + 4 * (state.facing as i32))
            }
            Blocks::PoweredRail(state) => {
                Some(1004 + (state.shape as i32) + 6 * (!state.powered() as i32))
            }
            Blocks::DetectorRail(state) => {
                Some(1016 + (state.shape as i32) + 6 * (!state.powered() as i32))
            }
            Blocks::StickyPiston(state) => {
                Some(1028 + (state.facing as i32) + 6 * (!state.extended() as i32))
            }
            Blocks::Cobweb => Some(1040),
            Blocks::Grass => Some(1041),
            Blocks::Fern => Some(1042),
            Blocks::DeadBush => Some(1043),
            Blocks::Seagrass => Some(1044),
            Blocks::TallSeagrass(state) => {
                Some(1045 + (state.half as i32))
            }
            Blocks::Piston(state) => {
                Some(1047 + (state.facing as i32) + 6 * (!state.extended() as i32))
            }
            Blocks::PistonHead(state) => {
                Some(1059 + (state.typed as i32) + 2 * (!state.short() as i32) + 4 * (state.facing as i32))
            }
            Blocks::WhiteWool => Some(1083),
            Blocks::OrangeWool => Some(1084),
            Blocks::MagentaWool => Some(1085),
            Blocks::LightBlueWool => Some(1086),
            Blocks::YellowWool => Some(1087),
            Blocks::LimeWool => Some(1088),
            Blocks::PinkWool => Some(1089),
            Blocks::GrayWool => Some(1090),
            Blocks::LightGrayWool => Some(1091),
            Blocks::CyanWool => Some(1092),
            Blocks::PurpleWool => Some(1093),
            Blocks::BlueWool => Some(1094),
            Blocks::BrownWool => Some(1095),
            Blocks::GreenWool => Some(1096),
            Blocks::RedWool => Some(1097),
            Blocks::BlackWool => Some(1098),
            Blocks::MovingPiston(state) => {
                Some(1099 + (state.typed as i32) + 2 * (state.facing as i32))
            }
            Blocks::Dandelion => Some(1111),
            Blocks::Poppy => Some(1112),
            Blocks::BlueOrchid => Some(1113),
            Blocks::Allium => Some(1114),
            Blocks::AzureBluet => Some(1115),
            Blocks::RedTulip => Some(1116),
            Blocks::OrangeTulip => Some(1117),
            Blocks::WhiteTulip => Some(1118),
            Blocks::PinkTulip => Some(1119),
            Blocks::OxeyeDaisy => Some(1120),
            Blocks::Cornflower => None,
            Blocks::WitherRose => None,
            Blocks::LilyOfTheValley => None,
            Blocks::BrownMushroom => Some(1121),
            Blocks::RedMushroom => Some(1122),
            Blocks::GoldBlock => Some(1123),
            Blocks::IronBlock => Some(1124),
            Blocks::Bricks => Some(1125),
            Blocks::Tnt(_) => Some(1126),
            Blocks::Bookshelf => Some(1127),
            Blocks::MossyCobblestone => Some(1128),
            Blocks::Obsidian => Some(1129),
            Blocks::Torch => Some(1130),
            Blocks::WallTorch(state) => {
                Some(1131 + (state.facing as i32))
            }
            Blocks::Fire(state) => {
                Some(1135 + (!state.west() as i32) + 2 * (!state.up() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32) + 32 * state.age)
            }
            Blocks::SoulFire => None,
            Blocks::Spawner => Some(1647),
            Blocks::OakStairs(state) => {
                Some(1648 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::Chest(state) => {
                Some(1728 + (!state.waterlogged() as i32) + 2 * (state.typed as i32) + 6 * (state.facing as i32))
            }
            Blocks::RedstoneWire(state) => {
                Some(1752 + (state.west as i32) + 3 * (state.south as i32) + 9 * state.power + 144 * (state.north as i32) + 432 * (state.east as i32))
            }
            Blocks::DiamondOre => Some(3048),
            Blocks::DeepslateDiamondOre => None,
            Blocks::DiamondBlock => Some(3049),
            Blocks::CraftingTable => Some(3050),
            Blocks::Wheat(state) => {
                Some(3051 + state.age)
            }
            Blocks::Farmland(state) => {
                Some(3059 + state.moisture)
            }
            Blocks::Furnace(state) => {
                Some(3067 + (!state.lit() as i32) + 2 * (state.facing as i32))
            }
            Blocks::OakSign(state) => {
                Some(3075 + (!state.waterlogged() as i32) + 2 * state.rotation)
            }
            Blocks::SpruceSign(_) => None,
            Blocks::BirchSign(_) => None,
            Blocks::AcaciaSign(_) => None,
            Blocks::JungleSign(_) => None,
            Blocks::DarkOakSign(_) => None,
            Blocks::OakDoor(state) => {
                Some(3107 + (!state.powered() as i32) + 2 * (!state.open() as i32) + 4 * (state.hinge as i32) + 8 * (state.half as i32) + 16 * (state.facing as i32))
            }
            Blocks::Ladder(state) => {
                Some(3171 + (!state.waterlogged() as i32) + 2 * (state.facing as i32))
            }
            Blocks::Rail(state) => {
                Some(3179 + (state.shape as i32))
            }
            Blocks::CobblestoneStairs(state) => {
                Some(3189 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::OakWallSign(state) => {
                Some(3269 + (!state.waterlogged() as i32) + 2 * (state.facing as i32))
            }
            Blocks::SpruceWallSign(_) => None,
            Blocks::BirchWallSign(_) => None,
            Blocks::AcaciaWallSign(_) => None,
            Blocks::JungleWallSign(_) => None,
            Blocks::DarkOakWallSign(_) => None,
            Blocks::Lever(state) => {
                Some(3277 + (!state.powered() as i32) + 2 * (state.facing as i32) + 8 * (state.face as i32))
            }
            Blocks::StonePressurePlate(state) => {
                Some(3301 + (!state.powered() as i32))
            }
            Blocks::IronDoor(state) => {
                Some(3303 + (!state.powered() as i32) + 2 * (!state.open() as i32) + 4 * (state.hinge as i32) + 8 * (state.half as i32) + 16 * (state.facing as i32))
            }
            Blocks::OakPressurePlate(state) => {
                Some(3367 + (!state.powered() as i32))
            }
            Blocks::SprucePressurePlate(state) => {
                Some(3369 + (!state.powered() as i32))
            }
            Blocks::BirchPressurePlate(state) => {
                Some(3371 + (!state.powered() as i32))
            }
            Blocks::JunglePressurePlate(state) => {
                Some(3373 + (!state.powered() as i32))
            }
            Blocks::AcaciaPressurePlate(state) => {
                Some(3375 + (!state.powered() as i32))
            }
            Blocks::DarkOakPressurePlate(state) => {
                Some(3377 + (!state.powered() as i32))
            }
            Blocks::RedstoneOre(state) => {
                Some(3379 + (!state.lit() as i32))
            }
            Blocks::DeepslateRedstoneOre(_) => None,
            Blocks::RedstoneTorch(state) => {
                Some(3381 + (!state.lit() as i32))
            }
            Blocks::RedstoneWallTorch(state) => {
                Some(3383 + (!state.lit() as i32) + 2 * (state.facing as i32))
            }
            Blocks::StoneButton(state) => {
                Some(3391 + (!state.powered() as i32) + 2 * (state.facing as i32) + 8 * (state.face as i32))
            }
            Blocks::Snow(state) => {
                Some(3415 + state.layers)
            }
            Blocks::Ice => Some(3423),
            Blocks::SnowBlock => Some(3424),
            Blocks::Cactus(state) => {
                Some(3425 + state.age)
            }
            Blocks::Clay => Some(3441),
            Blocks::SugarCane(state) => {
                Some(3442 + state.age)
            }
            Blocks::Jukebox(state) => {
                Some(3458 + (!state.has_record() as i32))
            }
            Blocks::OakFence(state) => {
                Some(3460 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::Pumpkin => Some(3492),
            Blocks::Netherrack => Some(3493),
            Blocks::SoulSand => Some(3494),
            Blocks::SoulSoil => None,
            Blocks::Basalt(_) => None,
            Blocks::PolishedBasalt(_) => None,
            Blocks::SoulTorch => None,
            Blocks::SoulWallTorch(_) => None,
            Blocks::Glowstone => Some(3495),
            Blocks::NetherPortal(state) => {
                Some(3496 + (state.axis as i32))
            }
            Blocks::CarvedPumpkin(state) => {
                Some(3498 + (state.facing as i32))
            }
            Blocks::JackOLantern(state) => {
                Some(3502 + (state.facing as i32))
            }
            Blocks::Cake(state) => {
                Some(3506 + state.bites)
            }
            Blocks::Repeater(state) => {
                Some(3513 + (!state.powered() as i32) + 2 * (!state.locked() as i32) + 4 * (state.facing as i32) + 16 * state.delay)
            }
            Blocks::WhiteStainedGlass => Some(3577),
            Blocks::OrangeStainedGlass => Some(3578),
            Blocks::MagentaStainedGlass => Some(3579),
            Blocks::LightBlueStainedGlass => Some(3580),
            Blocks::YellowStainedGlass => Some(3581),
            Blocks::LimeStainedGlass => Some(3582),
            Blocks::PinkStainedGlass => Some(3583),
            Blocks::GrayStainedGlass => Some(3584),
            Blocks::LightGrayStainedGlass => Some(3585),
            Blocks::CyanStainedGlass => Some(3586),
            Blocks::PurpleStainedGlass => Some(3587),
            Blocks::BlueStainedGlass => Some(3588),
            Blocks::BrownStainedGlass => Some(3589),
            Blocks::GreenStainedGlass => Some(3590),
            Blocks::RedStainedGlass => Some(3591),
            Blocks::BlackStainedGlass => Some(3592),
            Blocks::OakTrapdoor(state) => {
                Some(3593 + (!state.waterlogged() as i32) + 2 * (!state.powered() as i32) + 4 * (!state.open() as i32) + 8 * (state.half as i32) + 16 * (state.facing as i32))
            }
            Blocks::SpruceTrapdoor(state) => {
                Some(3657 + (!state.waterlogged() as i32) + 2 * (!state.powered() as i32) + 4 * (!state.open() as i32) + 8 * (state.half as i32) + 16 * (state.facing as i32))
            }
            Blocks::BirchTrapdoor(state) => {
                Some(3721 + (!state.waterlogged() as i32) + 2 * (!state.powered() as i32) + 4 * (!state.open() as i32) + 8 * (state.half as i32) + 16 * (state.facing as i32))
            }
            Blocks::JungleTrapdoor(state) => {
                Some(3785 + (!state.waterlogged() as i32) + 2 * (!state.powered() as i32) + 4 * (!state.open() as i32) + 8 * (state.half as i32) + 16 * (state.facing as i32))
            }
            Blocks::AcaciaTrapdoor(state) => {
                Some(3849 + (!state.waterlogged() as i32) + 2 * (!state.powered() as i32) + 4 * (!state.open() as i32) + 8 * (state.half as i32) + 16 * (state.facing as i32))
            }
            Blocks::DarkOakTrapdoor(state) => {
                Some(3913 + (!state.waterlogged() as i32) + 2 * (!state.powered() as i32) + 4 * (!state.open() as i32) + 8 * (state.half as i32) + 16 * (state.facing as i32))
            }
            Blocks::StoneBricks => Some(3983),
            Blocks::MossyStoneBricks => Some(3984),
            Blocks::CrackedStoneBricks => Some(3985),
            Blocks::ChiseledStoneBricks => Some(3986),
            Blocks::InfestedStone => Some(3977),
            Blocks::InfestedCobblestone => Some(3978),
            Blocks::InfestedStoneBricks => Some(3979),
            Blocks::InfestedMossyStoneBricks => Some(3980),
            Blocks::InfestedCrackedStoneBricks => Some(3981),
            Blocks::InfestedChiseledStoneBricks => Some(3982),
            Blocks::BrownMushroomBlock(state) => {
                Some(3987 + (!state.west() as i32) + 2 * (!state.up() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32) + 32 * (!state.down() as i32))
            }
            Blocks::RedMushroomBlock(state) => {
                Some(4051 + (!state.west() as i32) + 2 * (!state.up() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32) + 32 * (!state.down() as i32))
            }
            Blocks::MushroomStem(state) => {
                Some(4115 + (!state.west() as i32) + 2 * (!state.up() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32) + 32 * (!state.down() as i32))
            }
            Blocks::IronBars(state) => {
                Some(4179 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::Chain(_) => None,
            Blocks::GlassPane(state) => {
                Some(4211 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::Melon => Some(4243),
            Blocks::AttachedPumpkinStem(state) => {
                Some(4244 + (state.facing as i32))
            }
            Blocks::AttachedMelonStem(state) => {
                Some(4248 + (state.facing as i32))
            }
            Blocks::PumpkinStem(state) => {
                Some(4252 + state.age)
            }
            Blocks::MelonStem(state) => {
                Some(4260 + state.age)
            }
            Blocks::Vine(state) => {
                Some(4268 + (!state.west() as i32) + 2 * (!state.up() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::GlowLichen(_) => None,
            Blocks::OakFenceGate(state) => {
                Some(4300 + (!state.powered() as i32) + 2 * (!state.open() as i32) + 4 * (!state.in_wall() as i32) + 8 * (state.facing as i32))
            }
            Blocks::BrickStairs(state) => {
                Some(4332 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::StoneBrickStairs(state) => {
                Some(4412 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::Mycelium(state) => {
                Some(4492 + (!state.snowy() as i32))
            }
            Blocks::LilyPad => Some(4494),
            Blocks::NetherBricks => Some(4495),
            Blocks::NetherBrickFence(state) => {
                Some(4496 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::NetherBrickStairs(state) => {
                Some(4528 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::NetherWart(state) => {
                Some(4608 + state.age)
            }
            Blocks::EnchantingTable => Some(4612),
            Blocks::BrewingStand(state) => {
                Some(4613 + (!state.has_bottle_2() as i32) + 2 * (!state.has_bottle_1() as i32) + 4 * (!state.has_bottle_0() as i32))
            }
            Blocks::Cauldron => Some(4621),
            Blocks::WaterCauldron(state) => {
                Some(4622 + state.level)
            }
            Blocks::LavaCauldron => None,
            Blocks::PowderSnowCauldron(_) => None,
            Blocks::EndPortal => Some(4625),
            Blocks::EndPortalFrame(state) => {
                Some(4626 + (state.facing as i32) + 4 * (!state.eye() as i32))
            }
            Blocks::EndStone => Some(4634),
            Blocks::DragonEgg => Some(4635),
            Blocks::RedstoneLamp(state) => {
                Some(4636 + (!state.lit() as i32))
            }
            Blocks::Cocoa(state) => {
                Some(4638 + (state.facing as i32) + 4 * state.age)
            }
            Blocks::SandstoneStairs(state) => {
                Some(4650 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::EmeraldOre => Some(4730),
            Blocks::DeepslateEmeraldOre => None,
            Blocks::EnderChest(state) => {
                Some(4731 + (!state.waterlogged() as i32) + 2 * (state.facing as i32))
            }
            Blocks::TripwireHook(state) => {
                Some(4739 + (!state.powered() as i32) + 2 * (state.facing as i32) + 8 * (!state.attached() as i32))
            }
            Blocks::Tripwire(state) => {
                Some(4755 + (!state.west() as i32) + 2 * (!state.south() as i32) + 4 * (!state.powered() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32) + 32 * (!state.disarmed() as i32) + 64 * (!state.attached() as i32))
            }
            Blocks::EmeraldBlock => Some(4883),
            Blocks::SpruceStairs(state) => {
                Some(4884 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::BirchStairs(state) => {
                Some(4964 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::JungleStairs(state) => {
                Some(5044 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::CommandBlock(state) => {
                Some(5124 + (state.facing as i32) + 6 * (!state.conditional() as i32))
            }
            Blocks::Beacon => Some(5136),
            Blocks::CobblestoneWall(state) => {
                let value0 = match state.west {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                let value1 = match state.south {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                let value2 = match state.north {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                let value3 = match state.east {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                Some(5137 + value0 + 2 * (!state.waterlogged() as i32) + 4 * (!state.up() as i32) + 8 * value1 + 16 * value2 + 32 * value3)
            }
            Blocks::MossyCobblestoneWall(state) => {
                let value0 = match state.west {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                let value1 = match state.south {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                let value2 = match state.north {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                let value3 = match state.east {
                    WallType::Low => 0,
                    WallType::None => 1,
                    _ => return None,
                };
                Some(5201 + value0 + 2 * (!state.waterlogged() as i32) + 4 * (!state.up() as i32) + 8 * value1 + 16 * value2 + 32 * value3)
            }
            Blocks::FlowerPot => Some(5265),
            Blocks::PottedOakSapling => Some(5266),
            Blocks::PottedSpruceSapling => Some(5267),
            Blocks::PottedBirchSapling => Some(5268),
            Blocks::PottedJungleSapling => Some(5269),
            Blocks::PottedAcaciaSapling => Some(5270),
            Blocks::PottedDarkOakSapling => Some(5271),
            Blocks::PottedFern => Some(5272),
            Blocks::PottedDandelion => Some(5273),
            Blocks::PottedPoppy => Some(5274),
            Blocks::PottedBlueOrchid => Some(5275),
            Blocks::PottedAllium => Some(5276),
            Blocks::PottedAzureBluet => Some(5277),
            Blocks::PottedRedTulip => Some(5278),
            Blocks::PottedOrangeTulip => Some(5279),
            Blocks::PottedWhiteTulip => Some(5280),
            Blocks::PottedPinkTulip => Some(5281),
            Blocks::PottedOxeyeDaisy => Some(5282),
            Blocks::PottedCornflower => None,
            Blocks::PottedLilyOfTheValley => None,
            Blocks::PottedWitherRose => None,
            Blocks::PottedRedMushroom => Some(5283),
            Blocks::PottedBrownMushroom => Some(5284),
            Blocks::PottedDeadBush => Some(5285),
            Blocks::PottedCactus => Some(5286),
            Blocks::Carrots(state) => {
                Some(5287 + state.age)
            }
            Blocks::Potatoes(state) => {
                Some(5295 + state.age)
            }
            Blocks::OakButton(state) => {
                Some(5303 + (!state.powered() as i32) + 2 * (state.facing as i32) + 8 * (state.face as i32))
            }
            Blocks::SpruceButton(state) => {
                Some(5327 + (!state.powered() as i32) + 2 * (state.facing as i32) + 8 * (state.face as i32))
            }
            Blocks::BirchButton(state) => {
                Some(5351 + (!state.powered() as i32) + 2 * (state.facing as i32) + 8 * (state.face as i32))
            }
            Blocks::JungleButton(state) => {
                Some(5375 + (!state.powered() as i32) + 2 * (state.facing as i32) + 8 * (state.face as i32))
            }
            Blocks::AcaciaButton(state) => {
                Some(5399 + (!state.powered() as i32) + 2 * (state.facing as i32) + 8 * (state.face as i32))
            }
            Blocks::DarkOakButton(state) => {
                Some(5423 + (!state.powered() as i32) + 2 * (state.facing as i32) + 8 * (state.face as i32))
            }
            Blocks::SkeletonSkull(state) => {
                Some(5451 + state.rotation)
            }
            Blocks::SkeletonWallSkull(state) => {
                Some(5447 + (state.facing as i32))
            }
            Blocks::WitherSkeletonSkull(state) => {
                Some(5471 + state.rotation)
            }
            Blocks::WitherSkeletonWallSkull(state) => {
                Some(5467 + (state.facing as i32))
            }
            Blocks::ZombieHead(state) => {
                Some(5491 + state.rotation)
            }
            Blocks::ZombieWallHead(state) => {
                Some(5487 + (state.facing as i32))
            }
            Blocks::PlayerHead(state) => {
                Some(5511 + state.rotation)
            }
            Blocks::PlayerWallHead(state) => {
                Some(5507 + (state.facing as i32))
            }
            Blocks::CreeperHead(state) => {
                Some(5531 + state.rotation)
            }
            Blocks::CreeperWallHead(state) => {
                Some(5527 + (state.facing as i32))
            }
            Blocks::DragonHead(state) => {
                Some(5551 + state.rotation)
            }
            Blocks::DragonWallHead(state) => {
                Some(5547 + (state.facing as i32))
            }
            Blocks::Anvil(state) => {
                Some(5567 + (state.facing as i32))
            }
            Blocks::ChippedAnvil(state) => {
                Some(5571 + (state.facing as i32))
            }
            Blocks::DamagedAnvil(state) => {
                Some(5575 + (state.facing as i32))
            }
            Blocks::TrappedChest(state) => {
                Some(5579 + (!state.waterlogged() as i32) + 2 * (state.typed as i32) + 6 * (state.facing as i32))
            }
            Blocks::LightWeightedPressurePlate(state) => {
                Some(5603 + state.power)
            }
            Blocks::HeavyWeightedPressurePlate(state) => {
                Some(5619 + state.power)
            }
            Blocks::Comparator(state) => {
                Some(5635 + (!state.powered() as i32) + 2 * (state.mode as i32) + 4 * (state.facing as i32))
            }
            Blocks::DaylightDetector(state) => {
                Some(5651 + state.power + 16 * (!state.inverted() as i32))
            }
            Blocks::RedstoneBlock => Some(5683),
            Blocks::NetherQuartzOre => Some(5684),
            Blocks::Hopper(state) => {
                Some(5685 + (state.facing as i32) + 5 * (!state.enabled() as i32))
            }
            Blocks::QuartzBlock => Some(5695),
            Blocks::ChiseledQuartzBlock => Some(5696),
            Blocks::QuartzPillar(state) => {
                Some(5697 + (state.axis as i32))
            }
            Blocks::QuartzStairs(state) => {
                Some(5700 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::ActivatorRail(state) => {
                Some(5780 + (state.shape as i32) + 6 * (!state.powered() as i32))
            }
            Blocks::Dropper(state) => {
                Some(5792 + (!state.triggered() as i32) + 2 * (state.facing as i32))
            }
            Blocks::WhiteTerracotta => Some(5804),
            Blocks::OrangeTerracotta => Some(5805),
            Blocks::MagentaTerracotta => Some(5806),
            Blocks::LightBlueTerracotta => Some(5807),
            Blocks::YellowTerracotta => Some(5808),
            Blocks::LimeTerracotta => Some(5809),
            Blocks::PinkTerracotta => Some(5810),
            Blocks::GrayTerracotta => Some(5811),
            Blocks::LightGrayTerracotta => Some(5812),
            Blocks::CyanTerracotta => Some(5813),
            Blocks::PurpleTerracotta => Some(5814),
            Blocks::BlueTerracotta => Some(5815),
            Blocks::BrownTerracotta => Some(5816),
            Blocks::GreenTerracotta => Some(5817),
            Blocks::RedTerracotta => Some(5818),
            Blocks::BlackTerracotta => Some(5819),
            Blocks::WhiteStainedGlassPane(state) => {
                Some(5820 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::OrangeStainedGlassPane(state) => {
                Some(5852 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::MagentaStainedGlassPane(state) => {
                Some(5884 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::LightBlueStainedGlassPane(state) => {
                Some(5916 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::YellowStainedGlassPane(state) => {
                Some(5948 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::LimeStainedGlassPane(state) => {
                Some(5980 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::PinkStainedGlassPane(state) => {
                Some(6012 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::GrayStainedGlassPane(state) => {
                Some(6044 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::LightGrayStainedGlassPane(state) => {
                Some(6076 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::CyanStainedGlassPane(state) => {
                Some(6108 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::PurpleStainedGlassPane(state) => {
                Some(6140 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::BlueStainedGlassPane(state) => {
                Some(6172 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::BrownStainedGlassPane(state) => {
                Some(6204 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::GreenStainedGlassPane(state) => {
                Some(6236 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::RedStainedGlassPane(state) => {
                Some(6268 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::BlackStainedGlassPane(state) => {
                Some(6300 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::AcaciaStairs(state) => {
                Some(6332 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::DarkOakStairs(state) => {
                Some(6412 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::SlimeBlock => Some(6492),
            Blocks::Barrier => Some(6493),
            Blocks::Light(_) => None,
            Blocks::IronTrapdoor(state) => {
                Some(6494 + (!state.waterlogged() as i32) + 2 * (!state.powered() as i32) + 4 * (!state.open() as i32) + 8 * (state.half as i32) + 16 * (state.facing as i32))
            }
            Blocks::Prismarine => Some(6558),
            Blocks::PrismarineBricks => Some(6559),
            Blocks::DarkPrismarine => Some(6560),
            Blocks::PrismarineStairs(state) => {
                Some(6561 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::PrismarineBrickStairs(state) => {
                Some(6641 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::DarkPrismarineStairs(state) => {
                Some(6721 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::PrismarineSlab(state) => {
                Some(6801 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::PrismarineBrickSlab(state) => {
                Some(6807 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::DarkPrismarineSlab(state) => {
                Some(6813 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::SeaLantern => Some(6819),
            Blocks::HayBlock(state) => {
                Some(6820 + (state.axis as i32))
            }
            Blocks::WhiteCarpet => Some(6823),
            Blocks::OrangeCarpet => Some(6824),
            Blocks::MagentaCarpet => Some(6825),
            Blocks::LightBlueCarpet => Some(6826),
            Blocks::YellowCarpet => Some(6827),
            Blocks::LimeCarpet => Some(6828),
            Blocks::PinkCarpet => Some(6829),
            Blocks::GrayCarpet => Some(6830),
            Blocks::LightGrayCarpet => Some(6831),
            Blocks::CyanCarpet => Some(6832),
            Blocks::PurpleCarpet => Some(6833),
            Blocks::BlueCarpet => Some(6834),
            Blocks::BrownCarpet => Some(6835),
            Blocks::GreenCarpet => Some(6836),
            Blocks::RedCarpet => Some(6837),
            Blocks::BlackCarpet => Some(6838),
            Blocks::Terracotta => Some(6839),
            Blocks::CoalBlock => Some(6840),
            Blocks::PackedIce => Some(6841),
            Blocks::Sunflower(state) => {
                Some(6842 + (state.half as i32))
            }
            Blocks::Lilac(state) => {
                Some(6844 + (state.half as i32))
            }
            Blocks::RoseBush(state) => {
                Some(6846 + (state.half as i32))
            }
            Blocks::Peony(state) => {
                Some(6848 + (state.half as i32))
            }
            Blocks::TallGrass(state) => {
                Some(6850 + (state.half as i32))
            }
            Blocks::LargeFern(state) => {
                Some(6852 + (state.half as i32))
            }
            Blocks::WhiteBanner(state) => {
                Some(6854 + state.rotation)
            }
            Blocks::OrangeBanner(state) => {
                Some(6870 + state.rotation)
            }
            Blocks::MagentaBanner(state) => {
                Some(6886 + state.rotation)
            }
            Blocks::LightBlueBanner(state) => {
                Some(6902 + state.rotation)
            }
            Blocks::YellowBanner(state) => {
                Some(6918 + state.rotation)
            }
            Blocks::LimeBanner(state) => {
                Some(6934 + state.rotation)
            }
            Blocks::PinkBanner(state) => {
                Some(6950 + state.rotation)
            }
            Blocks::GrayBanner(state) => {
                Some(6966 + state.rotation)
            }
            Blocks::LightGrayBanner(state) => {
                Some(6982 + state.rotation)
            }
            Blocks::CyanBanner(state) => {
                Some(6998 + state.rotation)
            }
            Blocks::PurpleBanner(state) => {
                Some(7014 + state.rotation)
            }
            Blocks::BlueBanner(state) => {
                Some(7030 + state.rotation)
            }
            Blocks::BrownBanner(state) => {
                Some(7046 + state.rotation)
            }
            Blocks::GreenBanner(state) => {
                Some(7062 + state.rotation)
            }
            Blocks::RedBanner(state) => {
                Some(7078 + state.rotation)
            }
            Blocks::BlackBanner(state) => {
                Some(7094 + state.rotation)
            }
            Blocks::WhiteWallBanner(state) => {
                Some(7110 + (state.facing as i32))
            }
            Blocks::OrangeWallBanner(state) => {
                Some(7114 + (state.facing as i32))
            }
            Blocks::MagentaWallBanner(state) => {
                Some(7118 + (state.facing as i32))
            }
            Blocks::LightBlueWallBanner(state) => {
                Some(7122 + (state.facing as i32))
            }
            Blocks::YellowWallBanner(state) => {
                Some(7126 + (state.facing as i32))
            }
            Blocks::LimeWallBanner(state) => {
                Some(7130 + (state.facing as i32))
            }
            Blocks::PinkWallBanner(state) => {
                Some(7134 + (state.facing as i32))
            }
            Blocks::GrayWallBanner(state) => {
                Some(7138 + (state.facing as i32))
            }
            Blocks::LightGrayWallBanner(state) => {
                Some(7142 + (state.facing as i32))
            }
            Blocks::CyanWallBanner(state) => {
                Some(7146 + (state.facing as i32))
            }
            Blocks::PurpleWallBanner(state) => {
                Some(7150 + (state.facing as i32))
            }
            Blocks::BlueWallBanner(state) => {
                Some(7154 + (state.facing as i32))
            }
            Blocks::BrownWallBanner(state) => {
                Some(7158 + (state.facing as i32))
            }
            Blocks::GreenWallBanner(state) => {
                Some(7162 + (state.facing as i32))
            }
            Blocks::RedWallBanner(state) => {
                Some(7166 + (state.facing as i32))
            }
            Blocks::BlackWallBanner(state) => {
                Some(7170 + (state.facing as i32))
            }
            Blocks::RedSandstone => Some(7174),
            Blocks::ChiseledRedSandstone => Some(7175),
            Blocks::CutRedSandstone => Some(7176),
            Blocks::RedSandstoneStairs(state) => {
                Some(7177 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::OakSlab(state) => {
                Some(7257 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::SpruceSlab(state) => {
                Some(7263 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::BirchSlab(state) => {
                Some(7269 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::JungleSlab(state) => {
                Some(7275 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::AcaciaSlab(state) => {
                Some(7281 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::DarkOakSlab(state) => {
                Some(7287 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::StoneSlab(state) => {
                Some(7293 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::SmoothStoneSlab(_) => None,
            Blocks::SandstoneSlab(state) => {
                Some(7299 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::CutSandstoneSlab(_) => None,
            Blocks::PetrifiedOakSlab(state) => {
                Some(7305 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::CobblestoneSlab(state) => {
                Some(7311 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::BrickSlab(state) => {
                Some(7317 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::StoneBrickSlab(state) => {
                Some(7323 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::NetherBrickSlab(state) => {
                Some(7329 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::QuartzSlab(state) => {
                Some(7335 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::RedSandstoneSlab(state) => {
                Some(7341 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::CutRedSandstoneSlab(_) => None,
            Blocks::PurpurSlab(state) => {
                Some(7347 + (!state.waterlogged() as i32) + 2 * (state.typed as i32))
            }
            Blocks::SmoothStone => Some(7353),
            Blocks::SmoothSandstone => Some(7354),
            Blocks::SmoothQuartz => Some(7355),
            Blocks::SmoothRedSandstone => Some(7356),
            Blocks::SpruceFenceGate(state) => {
                Some(7357 + (!state.powered() as i32) + 2 * (!state.open() as i32) + 4 * (!state.in_wall() as i32) + 8 * (state.facing as i32))
            }
            Blocks::BirchFenceGate(state) => {
                Some(7389 + (!state.powered() as i32) + 2 * (!state.open() as i32) + 4 * (!state.in_wall() as i32) + 8 * (state.facing as i32))
            }
            Blocks::JungleFenceGate(state) => {
                Some(7421 + (!state.powered() as i32) + 2 * (!state.open() as i32) + 4 * (!state.in_wall() as i32) + 8 * (state.facing as i32))
            }
            Blocks::AcaciaFenceGate(state) => {
                Some(7453 + (!state.powered() as i32) + 2 * (!state.open() as i32) + 4 * (!state.in_wall() as i32) + 8 * (state.facing as i32))
            }
            Blocks::DarkOakFenceGate(state) => {
                Some(7485 + (!state.powered() as i32) + 2 * (!state.open() as i32) + 4 * (!state.in_wall() as i32) + 8 * (state.facing as i32))
            }
            Blocks::SpruceFence(state) => {
                Some(7517 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::BirchFence(state) => {
                Some(7549 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::JungleFence(state) => {
                Some(7581 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::AcaciaFence(state) => {
                Some(7613 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::DarkOakFence(state) => {
                Some(7645 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32))
            }
            Blocks::SpruceDoor(state) => {
                Some(7677 + (!state.powered() as i32) + 2 * (!state.open() as i32) + 4 * (state.hinge as i32) + 8 * (state.half as i32) + 16 * (state.facing as i32))
            }
            Blocks::BirchDoor(state) => {
                Some(7741 + (!state.powered() as i32) + 2 * (!state.open() as i32) + 4 * (state.hinge as i32) + 8 * (state.half as i32) + 16 * (state.facing as i32))
            }
            Blocks::JungleDoor(state) => {
                Some(7805 + (!state.powered() as i32) + 2 * (!state.open() as i32) + 4 * (state.hinge as i32) + 8 * (state.half as i32) + 16 * (state.facing as i32))
            }
            Blocks::AcaciaDoor(state) => {
                Some(7869 + (!state.powered() as i32) + 2 * (!state.open() as i32) + 4 * (state.hinge as i32) + 8 * (state.half as i32) + 16 * (state.facing as i32))
            }
            Blocks::DarkOakDoor(state) => {
                Some(7933 + (!state.powered() as i32) + 2 * (!state.open() as i32) + 4 * (state.hinge as i32) + 8 * (state.half as i32) + 16 * (state.facing as i32))
            }
            Blocks::EndRod(state) => {
                Some(7997 + (state.facing as i32))
            }
            Blocks::ChorusPlant(state) => {
                Some(8003 + (!state.west() as i32) + 2 * (!state.up() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32) + 32 * (!state.down() as i32))
            }
            Blocks::ChorusFlower(state) => {
                Some(8067 + state.age)
            }
            Blocks::PurpurBlock => Some(8073),
            Blocks::PurpurPillar(state) => {
                Some(8074 + (state.axis as i32))
            }
            Blocks::PurpurStairs(state) => {
                Some(8077 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32))
            }
            Blocks::EndStoneBricks => Some(8157),
            Blocks::Beetroots(state) => {
                Some(8158 + state.age)
            }
            Blocks::DirtPath => Some(8162),
            Blocks::EndGateway => Some(8163),
            Blocks::RepeatingCommandBlock(state) => {
                Some(8164 + (state.facing as i32) + 6 * (!state.conditional() as i32))
            }
            Blocks::ChainCommandBlock(state) => {
                Some(8176 + (state.facing as i32) + 6 * (!state.conditional() as i32))
            }
            Blocks::FrostedIce(state) => {
                Some(8188 + state.age)
            }
            Blocks::MagmaBlock => Some(8192),
            Blocks::NetherWartBlock => Some(8193),
            Blocks::RedNetherBricks => Some(8194),
            Blocks::BoneBlock(state) => {
                Some(8195 + (state.axis as i32))
            }
            Blocks::StructureVoid => Some(8198),
            Blocks::Observer(state) => {
                Some(8199 + (!state.powered() as i32) + 2 * (state.facing as i32))
            }
            Blocks::ShulkerBox(state) => {
                Some(8211 + (state.facing as i32))
            }
            Blocks::WhiteShulkerBox(state) => {
                Some(8217 + (state.facing as i32))
            }
            Blocks::OrangeShulkerBox(state) => {
                Some(8223 + (state.facing as i32))
            }
            Blocks::MagentaShulkerBox(state) => {
                Some(8229 + (state.facing as i32))
            }
            Blocks::LightBlueShulkerBox(state) => {
                Some(8235 + (state.facing as i32))
            }
            Blocks::YellowShulkerBox(state) => {
                Some(8241 + (state.facing as i32))
            }
            Blocks::LimeShulkerBox(state) => {
                Some(8247 + (state.facing as i32))
            }
            Blocks::PinkShulkerBox(state) => {
                Some(8253 + (state.facing as i32))
            }
            Blocks::GrayShulkerBox(state) => {
                Some(8259 + (state.facing as i32))
            }
            Blocks::LightGrayShulkerBox(state) => {
                Some(8265 + (state.facing as i32))
            }
            Blocks::CyanShulkerBox(state) => {
                Some(8271 + (state.facing as i32))
            }
            Blocks::PurpleShulkerBox(state) => {
                Some(8277 + (state.facing as i32))
            }
            Blocks::BlueShulkerBox(state) => {
                Some(8283 + (state.facing as i32))
            }
            Blocks::BrownShulkerBox(state) => {
                Some(8289 + (state.facing as i32))
            }
            Blocks::GreenShulkerBox(state) => {
                Some(8295 + (state.facing as i32))
            }
            Blocks::RedShulkerBox(state) => {
                Some(8301 + (state.facing as i32))
            }
            Blocks::BlackShulkerBox(state) => {
                Some(8307 + (state.facing as i32))
            }
            Blocks::WhiteGlazedTerracotta(state) => {
                Some(8313 + (state.facing as i32))
            }
            Blocks::OrangeGlazedTerracotta(state) => {
                Some(8317 + (state.facing as i32))
            }
            Blocks::MagentaGlazedTerracotta(state) => {
                Some(8321 + (state.facing as i32))
            }
            Blocks::LightBlueGlazedTerracotta(state) => {
                Some(8325 + (state.facing as i32))
            }
            Blocks::YellowGlazedTerracotta(state) => {
                Some(8329 + (state.facing as i32))
            }
            Blocks::LimeGlazedTerracotta(state) => {
                Some(8333 + (state.facing as i32))
            }
            Blocks::PinkGlazedTerracotta(state) => {
                Some(8337 + (state.facing as i32))
            }
            Blocks::GrayGlazedTerracotta(state) => {
                Some(8341 + (state.facing as i32))
            }
            Blocks::LightGrayGlazedTerracotta(state) => {
                Some(8345 + (state.facing as i32))
            }
            Blocks::CyanGlazedTerracotta(state) => {
                Some(8349 + (state.facing as i32))
            }
            Blocks::PurpleGlazedTerracotta(state) => {
                Some(8353 + (state.facing as i32))
            }
            Blocks::BlueGlazedTerracotta(state) => {
                Some(8357 + (state.facing as i32))
            }
            Blocks::BrownGlazedTerracotta(state) => {
                Some(8361 + (state.facing as i32))
            }
            Blocks::GreenGlazedTerracotta(state) => {
                Some(8365 + (state.facing as i32))
            }
            Blocks::RedGlazedTerracotta(state) => {
                Some(8369 + (state.facing as i32))
            }
            Blocks::BlackGlazedTerracotta(state) => {
                Some(8373 + (state.facing as i32))
            }
            Blocks::WhiteConcrete => Some(8377),
            Blocks::OrangeConcrete => Some(8378),
            Blocks::MagentaConcrete => Some(8379),
            Blocks::LightBlueConcrete => Some(8380),
            Blocks::YellowConcrete => Some(8381),
            Blocks::LimeConcrete => Some(8382),
            Blocks::PinkConcrete => Some(8383),
            Blocks::GrayConcrete => Some(8384),
            Blocks::LightGrayConcrete => Some(8385),
            Blocks::CyanConcrete => Some(8386),
            Blocks::PurpleConcrete => Some(8387),
            Blocks::BlueConcrete => Some(8388),
            Blocks::BrownConcrete => Some(8389),
            Blocks::GreenConcrete => Some(8390),
            Blocks::RedConcrete => Some(8391),
            Blocks::BlackConcrete => Some(8392),
            Blocks::WhiteConcretePowder => Some(8393),
            Blocks::OrangeConcretePowder => Some(8394),
            Blocks::MagentaConcretePowder => Some(8395),
            Blocks::LightBlueConcretePowder => Some(8396),
            Blocks::YellowConcretePowder => Some(8397),
            Blocks::LimeConcretePowder => Some(8398),
            Blocks::PinkConcretePowder => Some(8399),
            Blocks::GrayConcretePowder => Some(8400),
            Blocks::LightGrayConcretePowder => Some(8401),
            Blocks::CyanConcretePowder => Some(8402),
            Blocks::PurpleConcretePowder => Some(8403),
            Blocks::BlueConcretePowder => Some(8404),
            Blocks::BrownConcretePowder => Some(8405),
            Blocks::GreenConcretePowder => Some(8406),
            Blocks::RedConcretePowder => Some(8407),
            Blocks::BlackConcretePowder => Some(8408),
            Blocks::Kelp(state) => {
                Some(8409 + state.age)
            }
            Blocks::KelpPlant => Some(8435),
            Blocks::DriedKelpBlock => Some(8436),
            Blocks::TurtleEgg(state) => {
                Some(8437 + state.hatch + 3 * state.eggs)
            }
            Blocks::DeadTubeCoralBlock => Some(8449),
            Blocks::DeadBrainCoralBlock => Some(8450),
            Blocks::DeadBubbleCoralBlock => Some(8451),
            Blocks::DeadFireCoralBlock => Some(8452),
            Blocks::DeadHornCoralBlock => Some(8453),
            Blocks::TubeCoralBlock => Some(8454),
            Blocks::BrainCoralBlock => Some(8455),
            Blocks::BubbleCoralBlock => Some(8456),
            Blocks::FireCoralBlock => Some(8457),
            Blocks::HornCoralBlock => Some(8458),
            Blocks::DeadTubeCoral(_) => None,
            Blocks::DeadBrainCoral(_) => None,
            Blocks::DeadBubbleCoral(_) => None,
            Blocks::DeadFireCoral(_) => None,
            Blocks::DeadHornCoral(_) => None,
            Blocks::TubeCoral(_) => Some(8459),
            Blocks::BrainCoral(_) => Some(8460),
            Blocks::BubbleCoral(_) => Some(8461),
            Blocks::FireCoral(_) => Some(8462),
            Blocks::HornCoral(_) => Some(8463),
            Blocks::DeadTubeCoralFan(state) => {
                Some(8544 + (!state.waterlogged() as i32))
            }
            Blocks::DeadBrainCoralFan(state) => {
                Some(8546 + (!state.waterlogged() as i32))
            }
            Blocks::DeadBubbleCoralFan(state) => {
                Some(8548 + (!state.waterlogged() as i32))
            }
            Blocks::DeadFireCoralFan(state) => {
                Some(8550 + (!state.waterlogged() as i32))
            }
            Blocks::DeadHornCoralFan(state) => {
                Some(8552 + (!state.waterlogged() as i32))
            }
            Blocks::TubeCoralFan(state) => {
                Some(8554 + (!state.waterlogged() as i32))
            }
            Blocks::BrainCoralFan(state) => {
                Some(8556 + (!state.waterlogged() as i32))
            }
            Blocks::BubbleCoralFan(state) => {
                Some(8558 + (!state.waterlogged() as i32))
            }
            Blocks::FireCoralFan(state) => {
                Some(8560 + (!state.waterlogged() as i32))
            }
            Blocks::HornCoralFan(state) => {
                Some(8562 + (!state.waterlogged() as i32))
            }
            Blocks::DeadTubeCoralWallFan(state) => {
                Some(8464 + (!state.waterlogged() as i32) + 2 * (state.facing as i32))
            }
            Blocks::DeadBrainCoralWallFan(state) => {
                Some(8472 + (!state.waterlogged() as i32) + 2 * (state.facing as i32))
            }
            Blocks::DeadBubbleCoralWallFan(state) => {
                Some(8480 + (!state.waterlogged() as i32) + 2 * (state.facing as i32))
            }
            Blocks::DeadFireCoralWallFan(state) => {
                Some(8488 + (!state.waterlogged() as i32) + 2 * (state.facing as i32))
            }
            Blocks::DeadHornCoralWallFan(state) => {
                Some(8496 + (!state.waterlogged() as i32) + 2 * (state.facing as i32))
            }
            Blocks::TubeCoralWallFan(state) => {
                Some(8504 + (!state.waterlogged() as i32) + 2 * (state.facing as i32))
            }
            Blocks::BrainCoralWallFan(state) => {
                Some(8512 + (!state.waterlogged() as i32) + 2 * (state.facing as i32))
            }
            Blocks::BubbleCoralWallFan(state) => {
                Some(8520 + (!state.waterlogged() as i32) + 2 * (state.facing as i32))
            }
            Blocks::FireCoralWallFan(state) => {
                Some(8528 + (!state.waterlogged() as i32) + 2 * (state.facing as i32))
            }
            Blocks::HornCoralWallFan(state) => {
                Some(8536 + (!state.waterlogged() as i32) + 2 * (state.facing as i32))
            }
            Blocks::SeaPickle(state) => {
                Some(8564 + (!state.waterlogged() as i32) + 2 * state.pickles)
            }
            Blocks::BlueIce => Some(8572),
            Blocks::Conduit(_) => Some(8573),
            Blocks::BambooSapling => None,
            Blocks::Bamboo(_) => None,
            Blocks::PottedBamboo => None,
            Blocks::VoidAir => Some(8574),
            Blocks::CaveAir => Some(8575),
            Blocks::BubbleColumn(state) => {
                Some(8576 + (!state.drag() as i32))
            }
            Blocks::PolishedGraniteStairs(_) => None,
            Blocks::SmoothRedSandstoneStairs(_) => None,
            Blocks::MossyStoneBrickStairs(_) => None,
            Blocks::PolishedDioriteStairs(_) => None,
            Blocks::MossyCobblestoneStairs(_) => None,
            Blocks::EndStoneBrickStairs(_) => None,
            Blocks::StoneStairs(_) => None,
            Blocks::SmoothSandstoneStairs(_) => None,
            Blocks::SmoothQuartzStairs(_) => None,
            Blocks::GraniteStairs(_) => None,
            Blocks::AndesiteStairs(_) => None,
            Blocks::RedNetherBrickStairs(_) => None,
            Blocks::PolishedAndesiteStairs(_) => None,
            Blocks::DioriteStairs(_) => None,
            Blocks::PolishedGraniteSlab(_) => None,
            Blocks::SmoothRedSandstoneSlab(_) => None,
            Blocks::MossyStoneBrickSlab(_) => None,
            Blocks::PolishedDioriteSlab(_) => None,
            Blocks::MossyCobblestoneSlab(_) => None,
            Blocks::EndStoneBrickSlab(_) => None,
            Blocks::SmoothSandstoneSlab(_) => None,
            Blocks::SmoothQuartzSlab(_) => None,
            Blocks::GraniteSlab(_) => None,
            Blocks::AndesiteSlab(_) => None,
            Blocks::RedNetherBrickSlab(_) => None,
            Blocks::PolishedAndesiteSlab(_) => None,
            Blocks::DioriteSlab(_) => None,
            Blocks::BrickWall(_) => None,
            Blocks::PrismarineWall(_) => None,
            Blocks::RedSandstoneWall(_) => None,
            Blocks::MossyStoneBrickWall(_) => None,
            Blocks::GraniteWall(_) => None,
            Blocks::StoneBrickWall(_) => None,
            Blocks::NetherBrickWall(_) => None,
            Blocks::AndesiteWall(_) => None,
            Blocks::RedNetherBrickWall(_) => None,
            Blocks::SandstoneWall(_) => None,
            Blocks::EndStoneBrickWall(_) => None,
            Blocks::DioriteWall(_) => None,
            Blocks::Scaffolding(_) => None,
            Blocks::Loom(_) => None,
            Blocks::Barrel(_) => None,
            Blocks::Smoker(_) => None,
            Blocks::BlastFurnace(_) => None,
            Blocks::CartographyTable => None,
            Blocks::FletchingTable => None,
            Blocks::Grindstone(_) => None,
            Blocks::Lectern(_) => None,
            Blocks::SmithingTable => None,
            Blocks::Stonecutter(_) => None,
            Blocks::Bell(_) => None,
            Blocks::Lantern(_) => None,
            Blocks::SoulLantern(_) => None,
            Blocks::Campfire(_) => None,
            Blocks::SoulCampfire(_) => None,
            Blocks::SweetBerryBush(_) => None,
            Blocks::WarpedStem(_) => None,
            Blocks::StrippedWarpedStem(_) => None,
            Blocks::WarpedHyphae(_) => None,
            Blocks::StrippedWarpedHyphae(_) => None,
            Blocks::WarpedNylium => None,
            Blocks::WarpedFungus => None,
            Blocks::WarpedWartBlock => None,
            Blocks::WarpedRoots => None,
            Blocks::NetherSprouts => None,
            Blocks::CrimsonStem(_) => None,
            Blocks::StrippedCrimsonStem(_) => None,
            Blocks::CrimsonHyphae(_) => None,
            Blocks::StrippedCrimsonHyphae(_) => None,
            Blocks::CrimsonNylium => None,
            Blocks::CrimsonFungus => None,
            Blocks::Shroomlight => None,
            Blocks::WeepingVines(_) => None,
            Blocks::WeepingVinesPlant => None,
            Blocks::TwistingVines(_) => None,
            Blocks::TwistingVinesPlant => None,
            Blocks::CrimsonRoots => None,
            Blocks::CrimsonPlanks => None,
            Blocks::WarpedPlanks => None,
            Blocks::CrimsonSlab(_) => None,
            Blocks::WarpedSlab(_) => None,
            Blocks::CrimsonPressurePlate(_) => None,
            Blocks::WarpedPressurePlate(_) => None,
            Blocks::CrimsonFence(_) => None,
            Blocks::WarpedFence(_) => None,
            Blocks::CrimsonTrapdoor(_) => None,
            Blocks::WarpedTrapdoor(_) => None,
            Blocks::CrimsonFenceGate(_) => None,
            Blocks::WarpedFenceGate(_) => None,
            Blocks::CrimsonStairs(_) => None,
            Blocks::WarpedStairs(_) => None,
            Blocks::CrimsonButton(_) => None,
            Blocks::WarpedButton(_) => None,
            Blocks::CrimsonDoor(_) => None,
            Blocks::WarpedDoor(_) => None,
            Blocks::CrimsonSign(_) => None,
            Blocks::WarpedSign(_) => None,
            Blocks::CrimsonWallSign(_) => None,
            Blocks::WarpedWallSign(_) => None,
            Blocks::StructureBlock(state) => {
                Some(8578 + (state.mode as i32))
            }
            Blocks::Jigsaw(_) => None,
            Blocks::Composter(_) => None,
            Blocks::Target(_) => None,
            Blocks::BeeNest(_) => None,
            Blocks::Beehive(_) => None,
            Blocks::HoneyBlock => None,
            Blocks::HoneycombBlock => None,
            Blocks::NetheriteBlock => None,
            Blocks::AncientDebris => None,
            Blocks::CryingObsidian => None,
            Blocks::RespawnAnchor(_) => None,
            Blocks::PottedCrimsonFungus => None,
            Blocks::PottedWarpedFungus => None,
            Blocks::PottedCrimsonRoots => None,
            Blocks::PottedWarpedRoots => None,
            Blocks::Lodestone => None,
            Blocks::Blackstone => None,
            Blocks::BlackstoneStairs(_) => None,
            Blocks::BlackstoneWall(_) => None,
            Blocks::BlackstoneSlab(_) => None,
            Blocks::PolishedBlackstone => None,
            Blocks::PolishedBlackstoneBricks => None,
            Blocks::CrackedPolishedBlackstoneBricks => None,
            Blocks::ChiseledPolishedBlackstone => None,
            Blocks::PolishedBlackstoneBrickSlab(_) => None,
            Blocks::PolishedBlackstoneBrickStairs(_) => None,
            Blocks::PolishedBlackstoneBrickWall(_) => None,
            Blocks::GildedBlackstone => None,
            Blocks::PolishedBlackstoneStairs(_) => None,
            Blocks::PolishedBlackstoneSlab(_) => None,
            Blocks::PolishedBlackstonePressurePlate(_) => None,
            Blocks::PolishedBlackstoneButton(_) => None,
            Blocks::PolishedBlackstoneWall(_) => None,
            Blocks::ChiseledNetherBricks => None,
            Blocks::CrackedNetherBricks => None,
            Blocks::QuartzBricks => None,
            Blocks::Candle(_) => None,
            Blocks::WhiteCandle(_) => None,
            Blocks::OrangeCandle(_) => None,
            Blocks::MagentaCandle(_) => None,
            Blocks::LightBlueCandle(_) => None,
            Blocks::YellowCandle(_) => None,
            Blocks::LimeCandle(_) => None,
            Blocks::PinkCandle(_) => None,
            Blocks::GrayCandle(_) => None,
            Blocks::LightGrayCandle(_) => None,
            Blocks::CyanCandle(_) => None,
            Blocks::PurpleCandle(_) => None,
            Blocks::BlueCandle(_) => None,
            Blocks::BrownCandle(_) => None,
            Blocks::GreenCandle(_) => None,
            Blocks::RedCandle(_) => None,
            Blocks::BlackCandle(_) => None,
            Blocks::CandleCake(_) => None,
            Blocks::WhiteCandleCake(_) => None,
            Blocks::OrangeCandleCake(_) => None,
            Blocks::MagentaCandleCake(_) => None,
            Blocks::LightBlueCandleCake(_) => None,
            Blocks::YellowCandleCake(_) => None,
            Blocks::LimeCandleCake(_) => None,
            Blocks::PinkCandleCake(_) => None,
            Blocks::GrayCandleCake(_) => None,
            Blocks::LightGrayCandleCake(_) => None,
            Blocks::CyanCandleCake(_) => None,
            Blocks::PurpleCandleCake(_) => None,
            Blocks::BlueCandleCake(_) => None,
            Blocks::BrownCandleCake(_) => None,
            Blocks::GreenCandleCake(_) => None,
            Blocks::RedCandleCake(_) => None,
            Blocks::BlackCandleCake(_) => None,
            Blocks::AmethystBlock => None,
            Blocks::BuddingAmethyst => None,
            Blocks::AmethystCluster(_) => None,
            Blocks::LargeAmethystBud(_) => None,
            Blocks::MediumAmethystBud(_) => None,
            Blocks::SmallAmethystBud(_) => None,
            Blocks::Tuff => None,
            Blocks::Calcite => None,
            Blocks::TintedGlass => None,
            Blocks::PowderSnow => None,
            Blocks::SculkSensor(_) => None,
            Blocks::OxidizedCopper => None,
            Blocks::WeatheredCopper => None,
            Blocks::ExposedCopper => None,
            Blocks::CopperBlock => None,
            Blocks::CopperOre => None,
            Blocks::DeepslateCopperOre => None,
            Blocks::OxidizedCutCopper => None,
            Blocks::WeatheredCutCopper => None,
            Blocks::ExposedCutCopper => None,
            Blocks::CutCopper => None,
            Blocks::OxidizedCutCopperStairs(_) => None,
            Blocks::WeatheredCutCopperStairs(_) => None,
            Blocks::ExposedCutCopperStairs(_) => None,
            Blocks::CutCopperStairs(_) => None,
            Blocks::OxidizedCutCopperSlab(_) => None,
            Blocks::WeatheredCutCopperSlab(_) => None,
            Blocks::ExposedCutCopperSlab(_) => None,
            Blocks::CutCopperSlab(_) => None,
            Blocks::WaxedCopperBlock => None,
            Blocks::WaxedWeatheredCopper => None,
            Blocks::WaxedExposedCopper => None,
            Blocks::WaxedOxidizedCopper => None,
            Blocks::WaxedOxidizedCutCopper => None,
            Blocks::WaxedWeatheredCutCopper => None,
            Blocks::WaxedExposedCutCopper => None,
            Blocks::WaxedCutCopper => None,
            Blocks::WaxedOxidizedCutCopperStairs(_) => None,
            Blocks::WaxedWeatheredCutCopperStairs(_) => None,
            Blocks::WaxedExposedCutCopperStairs(_) => None,
            Blocks::WaxedCutCopperStairs(_) => None,
            Blocks::WaxedOxidizedCutCopperSlab(_) => None,
            Blocks::WaxedWeatheredCutCopperSlab(_) => None,
            Blocks::WaxedExposedCutCopperSlab(_) => None,
            Blocks::WaxedCutCopperSlab(_) => None,
            Blocks::LightningRod(_) => None,
            Blocks::PointedDripstone(_) => None,
            Blocks::DripstoneBlock => None,
            Blocks::CaveVines(_) => None,
            Blocks::CaveVinesPlant(_) => None,
            Blocks::SporeBlossom => None,
            Blocks::Azalea => None,
            Blocks::FloweringAzalea => None,
            Blocks::MossCarpet => None,
            Blocks::MossBlock => None,
            Blocks::BigDripleaf(_) => None,
            Blocks::BigDripleafStem(_) => None,
            Blocks::SmallDripleaf(_) => None,
            Blocks::HangingRoots(_) => None,
            Blocks::RootedDirt => None,
            Blocks::Deepslate(_) => None,
            Blocks::CobbledDeepslate => None,
            Blocks::CobbledDeepslateStairs(_) => None,
            Blocks::CobbledDeepslateSlab(_) => None,
            Blocks::CobbledDeepslateWall(_) => None,
            Blocks::PolishedDeepslate => None,
            Blocks::PolishedDeepslateStairs(_) => None,
            Blocks::PolishedDeepslateSlab(_) => None,
            Blocks::PolishedDeepslateWall(_) => None,
            Blocks::DeepslateTiles => None,
            Blocks::DeepslateTileStairs(_) => None,
            Blocks::DeepslateTileSlab(_) => None,
            Blocks::DeepslateTileWall(_) => None,
            Blocks::DeepslateBricks => None,
            Blocks::DeepslateBrickStairs(_) => None,
            Blocks::DeepslateBrickSlab(_) => None,
            Blocks::DeepslateBrickWall(_) => None,
            Blocks::ChiseledDeepslate => None,
            Blocks::CrackedDeepslateBricks => None,
            Blocks::CrackedDeepslateTiles => None,
            Blocks::InfestedDeepslate(_) => None,
            Blocks::SmoothBasalt => None,
            Blocks::RawIronBlock => None,
            Blocks::RawCopperBlock => None,
            Blocks::RawGoldBlock => None,
            Blocks::PottedAzaleaBush => None,
            Blocks::PottedFloweringAzaleaBush => None,
        }
    }
    pub fn get_global_id_2730(&self) -> i32 {
        match self {
            Blocks::Air => 0,
            Blocks::Stone => 1,
            Blocks::Granite => 2,
            Blocks::PolishedGranite => 3,
            Blocks::Diorite => 4,
            Blocks::PolishedDiorite => 5,
            Blocks::Andesite => 6,
            Blocks::PolishedAndesite => 7,
            Blocks::GrassBlock(state) => {
                8 + (!state.snowy() as i32)
            }
            Blocks::Dirt => 10,
            Blocks::CoarseDirt => 11,
            Blocks::Podzol(state) => {
                12 + (!state.snowy() as i32)
            }
            Blocks::Cobblestone => 14,
            Blocks::OakPlanks => 15,
            Blocks::SprucePlanks => 16,
            Blocks::BirchPlanks => 17,
            Blocks::JunglePlanks => 18,
            Blocks::AcaciaPlanks => 19,
            Blocks::DarkOakPlanks => 20,
            Blocks::OakSapling(state) => {
                21 + state.stage
            }
            Blocks::SpruceSapling(state) => {
                23 + state.stage
            }
            Blocks::BirchSapling(state) => {
                25 + state.stage
            }
            Blocks::JungleSapling(state) => {
                27 + state.stage
            }
            Blocks::AcaciaSapling(state) => {
                29 + state.stage
            }
            Blocks::DarkOakSapling(state) => {
                31 + state.stage
            }
            Blocks::Bedrock => 33,
            Blocks::Water(state) => {
                34 + state.level
            }
            Blocks::Lava(state) => {
                50 + state.level
            }
            Blocks::Sand => 66,
            Blocks::RedSand => 67,
            Blocks::Gravel => 68,
            Blocks::GoldOre => 69,
            Blocks::DeepslateGoldOre => 70,
            Blocks::IronOre => 71,
            Blocks::DeepslateIronOre => 72,
            Blocks::CoalOre => 73,
            Blocks::DeepslateCoalOre => 74,
            Blocks::NetherGoldOre => 75,
            Blocks::OakLog(state) => {
                76 + (state.axis as i32)
            }
            Blocks::SpruceLog(state) => {
                79 + (state.axis as i32)
            }
            Blocks::BirchLog(state) => {
                82 + (state.axis as i32)
            }
            Blocks::JungleLog(state) => {
                85 + (state.axis as i32)
            }
            Blocks::AcaciaLog(state) => {
                88 + (state.axis as i32)
            }
            Blocks::DarkOakLog(state) => {
                91 + (state.axis as i32)
            }
            Blocks::StrippedSpruceLog(state) => {
                94 + (state.axis as i32)
            }
            Blocks::StrippedBirchLog(state) => {
                97 + (state.axis as i32)
            }
            Blocks::StrippedJungleLog(state) => {
                100 + (state.axis as i32)
            }
            Blocks::StrippedAcaciaLog(state) => {
                103 + (state.axis as i32)
            }
            Blocks::StrippedDarkOakLog(state) => {
                106 + (state.axis as i32)
            }
            Blocks::StrippedOakLog(state) => {
                109 + (state.axis as i32)
            }
            Blocks::OakWood(state) => {
                112 + (state.axis as i32)
            }
            Blocks::SpruceWood(state) => {
                115 + (state.axis as i32)
            }
            Blocks::BirchWood(state) => {
                118 + (state.axis as i32)
            }
            Blocks::JungleWood(state) => {
                121 + (state.axis as i32)
            }
            Blocks::AcaciaWood(state) => {
                124 + (state.axis as i32)
            }
            Blocks::DarkOakWood(state) => {
                127 + (state.axis as i32)
            }
            Blocks::StrippedOakWood(state) => {
                130 + (state.axis as i32)
            }
            Blocks::StrippedSpruceWood(state) => {
                133 + (state.axis as i32)
            }
            Blocks::StrippedBirchWood(state) => {
                136 + (state.axis as i32)
            }
            Blocks::StrippedJungleWood(state) => {
                139 + (state.axis as i32)
            }
            Blocks::StrippedAcaciaWood(state) => {
                142 + (state.axis as i32)
            }
            Blocks::StrippedDarkOakWood(state) => {
                145 + (state.axis as i32)
            }
            Blocks::OakLeaves(state) => {
                148 + (!state.persistent() as i32) + 2 * state.distance
            }
            Blocks::SpruceLeaves(state) => {
                162 + (!state.persistent() as i32) + 2 * state.distance
            }
            Blocks::BirchLeaves(state) => {
                176 + (!state.persistent() as i32) + 2 * state.distance
            }
            Blocks::JungleLeaves(state) => {
                190 + (!state.persistent() as i32) + 2 * state.distance
            }
            Blocks::AcaciaLeaves(state) => {
                204 + (!state.persistent() as i32) + 2 * state.distance
            }
            Blocks::DarkOakLeaves(state) => {
                218 + (!state.persistent() as i32) + 2 * state.distance
            }
            Blocks::AzaleaLeaves(state) => {
                232 + (!state.persistent() as i32) + 2 * state.distance
            }
            Blocks::FloweringAzaleaLeaves(state) => {
                246 + (!state.persistent() as i32) + 2 * state.distance
            }
            Blocks::Sponge => 260,
            Blocks::WetSponge => 261,
            Blocks::Glass => 262,
            Blocks::LapisOre => 263,
            Blocks::DeepslateLapisOre => 264,
            Blocks::LapisBlock => 265,
            Blocks::Dispenser(state) => {
                266 + (!state.triggered() as i32) + 2 * (state.facing as i32)
            }
            Blocks::Sandstone => 278,
            Blocks::ChiseledSandstone => 279,
            Blocks::CutSandstone => 280,
            Blocks::NoteBlock(state) => {
                281 + (!state.powered() as i32) + 2 * state.note + 50 * (state.instrument as i32)
            }
            Blocks::WhiteBed(state) => {
                1081 + (state.part as i32) + 2 * (!state.occupied() as i32) + 4 * (state.facing as i32)
            }
            Blocks::OrangeBed(state) => {
                1097 + (state.part as i32) + 2 * (!state.occupied() as i32) + 4 * (state.facing as i32)
            }
            Blocks::MagentaBed(state) => {
                1113 + (state.part as i32) + 2 * (!state.occupied() as i32) + 4 * (state.facing as i32)
            }
            Blocks::LightBlueBed(state) => {
                1129 + (state.part as i32) + 2 * (!state.occupied() as i32) + 4 * (state.facing as i32)
            }
            Blocks::YellowBed(state) => {
                1145 + (state.part as i32) + 2 * (!state.occupied() as i32) + 4 * (state.facing as i32)
            }
            Blocks::LimeBed(state) => {
                1161 + (state.part as i32) + 2 * (!state.occupied() as i32) + 4 * (state.facing as i32)
            }
            Blocks::PinkBed(state) => {
                1177 + (state.part as i32) + 2 * (!state.occupied() as i32) + 4 * (state.facing as i32)
            }
            Blocks::GrayBed(state) => {
                1193 + (state.part as i32) + 2 * (!state.occupied() as i32) + 4 * (state.facing as i32)
            }
            Blocks::LightGrayBed(state) => {
                1209 + (state.part as i32) + 2 * (!state.occupied() as i32) + 4 * (state.facing as i32)
            }
            Blocks::CyanBed(state) => {
                1225 + (state.part as i32) + 2 * (!state.occupied() as i32) + 4 * (state.facing as i32)
            }
            Blocks::PurpleBed(state) => {
                1241 + (state.part as i32) + 2 * (!state.occupied() as i32) + 4 * (state.facing as i32)
            }
            Blocks::BlueBed(state) => {
                1257 + (state.part as i32) + 2 * (!state.occupied() as i32) + 4 * (state.facing as i32)
            }
            Blocks::BrownBed(state) => {
                1273 + (state.part as i32) + 2 * (!state.occupied() as i32) + 4 * (state.facing as i32)
            }
            Blocks::GreenBed(state) => {
                1289 + (state.part as i32) + 2 * (!state.occupied() as i32) + 4 * (state.facing as i32)
            }
            Blocks::RedBed(state) => {
                1305 + (state.part as i32) + 2 * (!state.occupied() as i32) + 4 * (state.facing as i32)
            }
            Blocks::BlackBed(state) => {
                1321 + (state.part as i32) + 2 * (!state.occupied() as i32) + 4 * (state.facing as i32)
            }
            Blocks::PoweredRail(state) => {
                1337 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 12 * (!state.powered() as i32)
            }
            Blocks::DetectorRail(state) => {
                1361 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 12 * (!state.powered() as i32)
            }
            Blocks::StickyPiston(state) => {
                1385 + (state.facing as i32) + 6 * (!state.extended() as i32)
            }
            Blocks::Cobweb => 1397,
            Blocks::Grass => 1398,
            Blocks::Fern => 1399,
            Blocks::DeadBush => 1400,
            Blocks::Seagrass => 1401,
            Blocks::TallSeagrass(state) => {
                1402 + (state.half as i32)
            }
            Blocks::Piston(state) => {
                1404 + (state.facing as i32) + 6 * (!state.extended() as i32)
            }
            Blocks::PistonHead(state) => {
                1416 + (state.typed as i32) + 2 * (!state.short() as i32) + 4 * (state.facing as i32)
            }
            Blocks::WhiteWool => 1440,
            Blocks::OrangeWool => 1441,
            Blocks::MagentaWool => 1442,
            Blocks::LightBlueWool => 1443,
            Blocks::YellowWool => 1444,
            Blocks::LimeWool => 1445,
            Blocks::PinkWool => 1446,
            Blocks::GrayWool => 1447,
            Blocks::LightGrayWool => 1448,
            Blocks::CyanWool => 1449,
            Blocks::PurpleWool => 1450,
            Blocks::BlueWool => 1451,
            Blocks::BrownWool => 1452,
            Blocks::GreenWool => 1453,
            Blocks::RedWool => 1454,
            Blocks::BlackWool => 1455,
            Blocks::MovingPiston(state) => {
                1456 + (state.typed as i32) + 2 * (state.facing as i32)
            }
            Blocks::Dandelion => 1468,
            Blocks::Poppy => 1469,
            Blocks::BlueOrchid => 1470,
            Blocks::Allium => 1471,
            Blocks::AzureBluet => 1472,
            Blocks::RedTulip => 1473,
            Blocks::OrangeTulip => 1474,
            Blocks::WhiteTulip => 1475,
            Blocks::PinkTulip => 1476,
            Blocks::OxeyeDaisy => 1477,
            Blocks::Cornflower => 1478,
            Blocks::WitherRose => 1479,
            Blocks::LilyOfTheValley => 1480,
            Blocks::BrownMushroom => 1481,
            Blocks::RedMushroom => 1482,
            Blocks::GoldBlock => 1483,
            Blocks::IronBlock => 1484,
            Blocks::Bricks => 1485,
            Blocks::Tnt(state) => {
                1486 + (!state.unstable() as i32)
            }
            Blocks::Bookshelf => 1488,
            Blocks::MossyCobblestone => 1489,
            Blocks::Obsidian => 1490,
            Blocks::Torch => 1491,
            Blocks::WallTorch(state) => {
                1492 + (state.facing as i32)
            }
            Blocks::Fire(state) => {
                1496 + (!state.west() as i32) + 2 * (!state.up() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32) + 32 * state.age
            }
            Blocks::SoulFire => 2008,
            Blocks::Spawner => 2009,
            Blocks::OakStairs(state) => {
                2010 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32)
            }
            Blocks::Chest(state) => {
                2090 + (!state.waterlogged() as i32) + 2 * (state.typed as i32) + 6 * (state.facing as i32)
            }
            Blocks::RedstoneWire(state) => {
                2114 + (state.west as i32) + 3 * (state.south as i32) + 9 * state.power + 144 * (state.north as i32) + 432 * (state.east as i32)
            }
            Blocks::DiamondOre => 3410,
            Blocks::DeepslateDiamondOre => 3411,
            Blocks::DiamondBlock => 3412,
            Blocks::CraftingTable => 3413,
            Blocks::Wheat(state) => {
                3414 + state.age
            }
            Blocks::Farmland(state) => {
                3422 + state.moisture
            }
            Blocks::Furnace(state) => {
                3430 + (!state.lit() as i32) + 2 * (state.facing as i32)
            }
            Blocks::OakSign(state) => {
                3438 + (!state.waterlogged() as i32) + 2 * state.rotation
            }
            Blocks::SpruceSign(state) => {
                3470 + (!state.waterlogged() as i32) + 2 * state.rotation
            }
            Blocks::BirchSign(state) => {
                3502 + (!state.waterlogged() as i32) + 2 * state.rotation
            }
            Blocks::AcaciaSign(state) => {
                3534 + (!state.waterlogged() as i32) + 2 * state.rotation
            }
            Blocks::JungleSign(state) => {
                3566 + (!state.waterlogged() as i32) + 2 * state.rotation
            }
            Blocks::DarkOakSign(state) => {
                3598 + (!state.waterlogged() as i32) + 2 * state.rotation
            }
            Blocks::OakDoor(state) => {
                3630 + (!state.powered() as i32) + 2 * (!state.open() as i32) + 4 * (state.hinge as i32) + 8 * (state.half as i32) + 16 * (state.facing as i32)
            }
            Blocks::Ladder(state) => {
                3694 + (!state.waterlogged() as i32) + 2 * (state.facing as i32)
            }
            Blocks::Rail(state) => {
                3702 + (!state.waterlogged() as i32) + 2 * (state.shape as i32)
            }
            Blocks::CobblestoneStairs(state) => {
                3722 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32)
            }
            Blocks::OakWallSign(state) => {
                3802 + (!state.waterlogged() as i32) + 2 * (state.facing as i32)
            }
            Blocks::SpruceWallSign(state) => {
                3810 + (!state.waterlogged() as i32) + 2 * (state.facing as i32)
            }
            Blocks::BirchWallSign(state) => {
                3818 + (!state.waterlogged() as i32) + 2 * (state.facing as i32)
            }
            Blocks::AcaciaWallSign(state) => {
                3826 + (!state.waterlogged() as i32) + 2 * (state.facing as i32)
            }
            Blocks::JungleWallSign(state) => {
                3834 + (!state.waterlogged() as i32) + 2 * (state.facing as i32)
            }
            Blocks::DarkOakWallSign(state) => {
                3842 + (!state.waterlogged() as i32) + 2 * (state.facing as i32)
            }
            Blocks::Lever(state) => {
                3850 + (!state.powered() as i32) + 2 * (state.facing as i32) + 8 * (state.face as i32)
            }
            Blocks::StonePressurePlate(state) => {
                3874 + (!state.powered() as i32)
            }
            Blocks::IronDoor(state) => {
                3876 + (!state.powered() as i32) + 2 * (!state.open() as i32) + 4 * (state.hinge as i32) + 8 * (state.half as i32) + 16 * (state.facing as i32)
            }
            Blocks::OakPressurePlate(state) => {
                3940 + (!state.powered() as i32)
            }
            Blocks::SprucePressurePlate(state) => {
                3942 + (!state.powered() as i32)
            }
            Blocks::BirchPressurePlate(state) => {
                3944 + (!state.powered() as i32)
            }
            Blocks::JunglePressurePlate(state) => {
                3946 + (!state.powered() as i32)
            }
            Blocks::AcaciaPressurePlate(state) => {
                3948 + (!state.powered() as i32)
            }
            Blocks::DarkOakPressurePlate(state) => {
                3950 + (!state.powered() as i32)
            }
            Blocks::RedstoneOre(state) => {
                3952 + (!state.lit() as i32)
            }
            Blocks::DeepslateRedstoneOre(state) => {
                3954 + (!state.lit() as i32)
            }
            Blocks::RedstoneTorch(state) => {
                3956 + (!state.lit() as i32)
            }
            Blocks::RedstoneWallTorch(state) => {
                3958 + (!state.lit() as i32) + 2 * (state.facing as i32)
            }
            Blocks::StoneButton(state) => {
                3966 + (!state.powered() as i32) + 2 * (state.facing as i32) + 8 * (state.face as i32)
            }
            Blocks::Snow(state) => {
                3990 + state.layers
            }
            Blocks::Ice => 3998,
            Blocks::SnowBlock => 3999,
            Blocks::Cactus(state) => {
                4000 + state.age
            }
            Blocks::Clay => 4016,
            Blocks::SugarCane(state) => {
                4017 + state.age
            }
            Blocks::Jukebox(state) => {
                4033 + (!state.has_record() as i32)
            }
            Blocks::OakFence(state) => {
                4035 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32)
            }
            Blocks::Pumpkin => 4067,
            Blocks::Netherrack => 4068,
            Blocks::SoulSand => 4069,
            Blocks::SoulSoil => 4070,
            Blocks::Basalt(state) => {
                4071 + (state.axis as i32)
            }
            Blocks::PolishedBasalt(state) => {
                4074 + (state.axis as i32)
            }
            Blocks::SoulTorch => 4077,
            Blocks::SoulWallTorch(state) => {
                4078 + (state.facing as i32)
            }
            Blocks::Glowstone => 4082,
            Blocks::NetherPortal(state) => {
                4083 + (state.axis as i32)
            }
            Blocks::CarvedPumpkin(state) => {
                4085 + (state.facing as i32)
            }
            Blocks::JackOLantern(state) => {
                4089 + (state.facing as i32)
            }
            Blocks::Cake(state) => {
                4093 + state.bites
            }
            Blocks::Repeater(state) => {
                4100 + (!state.powered() as i32) + 2 * (!state.locked() as i32) + 4 * (state.facing as i32) + 16 * state.delay
            }
            Blocks::WhiteStainedGlass => 4164,
            Blocks::OrangeStainedGlass => 4165,
            Blocks::MagentaStainedGlass => 4166,
            Blocks::LightBlueStainedGlass => 4167,
            Blocks::YellowStainedGlass => 4168,
            Blocks::LimeStainedGlass => 4169,
            Blocks::PinkStainedGlass => 4170,
            Blocks::GrayStainedGlass => 4171,
            Blocks::LightGrayStainedGlass => 4172,
            Blocks::CyanStainedGlass => 4173,
            Blocks::PurpleStainedGlass => 4174,
            Blocks::BlueStainedGlass => 4175,
            Blocks::BrownStainedGlass => 4176,
            Blocks::GreenStainedGlass => 4177,
            Blocks::RedStainedGlass => 4178,
            Blocks::BlackStainedGlass => 4179,
            Blocks::OakTrapdoor(state) => {
                4180 + (!state.waterlogged() as i32) + 2 * (!state.powered() as i32) + 4 * (!state.open() as i32) + 8 * (state.half as i32) + 16 * (state.facing as i32)
            }
            Blocks::SpruceTrapdoor(state) => {
                4244 + (!state.waterlogged() as i32) + 2 * (!state.powered() as i32) + 4 * (!state.open() as i32) + 8 * (state.half as i32) + 16 * (state.facing as i32)
            }
            Blocks::BirchTrapdoor(state) => {
                4308 + (!state.waterlogged() as i32) + 2 * (!state.powered() as i32) + 4 * (!state.open() as i32) + 8 * (state.half as i32) + 16 * (state.facing as i32)
            }
            Blocks::JungleTrapdoor(state) => {
                4372 + (!state.waterlogged() as i32) + 2 * (!state.powered() as i32) + 4 * (!state.open() as i32) + 8 * (state.half as i32) + 16 * (state.facing as i32)
            }
            Blocks::AcaciaTrapdoor(state) => {
                4436 + (!state.waterlogged() as i32) + 2 * (!state.powered() as i32) + 4 * (!state.open() as i32) + 8 * (state.half as i32) + 16 * (state.facing as i32)
            }
            Blocks::DarkOakTrapdoor(state) => {
                4500 + (!state.waterlogged() as i32) + 2 * (!state.powered() as i32) + 4 * (!state.open() as i32) + 8 * (state.half as i32) + 16 * (state.facing as i32)
            }
            Blocks::StoneBricks => 4564,
            Blocks::MossyStoneBricks => 4565,
            Blocks::CrackedStoneBricks => 4566,
            Blocks::ChiseledStoneBricks => 4567,
            Blocks::InfestedStone => 4568,
            Blocks::InfestedCobblestone => 4569,
            Blocks::InfestedStoneBricks => 4570,
            Blocks::InfestedMossyStoneBricks => 4571,
            Blocks::InfestedCrackedStoneBricks => 4572,
            Blocks::InfestedChiseledStoneBricks => 4573,
            Blocks::BrownMushroomBlock(state) => {
                4574 + (!state.west() as i32) + 2 * (!state.up() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32) + 32 * (!state.down() as i32)
            }
            Blocks::RedMushroomBlock(state) => {
                4638 + (!state.west() as i32) + 2 * (!state.up() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32) + 32 * (!state.down() as i32)
            }
            Blocks::MushroomStem(state) => {
                4702 + (!state.west() as i32) + 2 * (!state.up() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32) + 32 * (!state.down() as i32)
            }
            Blocks::IronBars(state) => {
                4766 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32)
            }
            Blocks::Chain(state) => {
                4798 + (!state.waterlogged() as i32) + 2 * (state.axis as i32)
            }
            Blocks::GlassPane(state) => {
                4804 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32)
            }
            Blocks::Melon => 4836,
            Blocks::AttachedPumpkinStem(state) => {
                4837 + (state.facing as i32)
            }
            Blocks::AttachedMelonStem(state) => {
                4841 + (state.facing as i32)
            }
            Blocks::PumpkinStem(state) => {
                4845 + state.age
            }
            Blocks::MelonStem(state) => {
                4853 + state.age
            }
            Blocks::Vine(state) => {
                4861 + (!state.west() as i32) + 2 * (!state.up() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32)
            }
            Blocks::GlowLichen(state) => {
                4893 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.up() as i32) + 8 * (!state.south() as i32) + 16 * (!state.north() as i32) + 32 * (!state.east() as i32) + 64 * (!state.down() as i32)
            }
            Blocks::OakFenceGate(state) => {
                5021 + (!state.powered() as i32) + 2 * (!state.open() as i32) + 4 * (!state.in_wall() as i32) + 8 * (state.facing as i32)
            }
            Blocks::BrickStairs(state) => {
                5053 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32)
            }
            Blocks::StoneBrickStairs(state) => {
                5133 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32)
            }
            Blocks::Mycelium(state) => {
                5213 + (!state.snowy() as i32)
            }
            Blocks::LilyPad => 5215,
            Blocks::NetherBricks => 5216,
            Blocks::NetherBrickFence(state) => {
                5217 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32)
            }
            Blocks::NetherBrickStairs(state) => {
                5249 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32)
            }
            Blocks::NetherWart(state) => {
                5329 + state.age
            }
            Blocks::EnchantingTable => 5333,
            Blocks::BrewingStand(state) => {
                5334 + (!state.has_bottle_2() as i32) + 2 * (!state.has_bottle_1() as i32) + 4 * (!state.has_bottle_0() as i32)
            }
            Blocks::Cauldron => 5342,
            Blocks::WaterCauldron(state) => {
                5343 + state.level
            }
            Blocks::LavaCauldron => 5346,
            Blocks::PowderSnowCauldron(state) => {
                5347 + state.level
            }
            Blocks::EndPortal => 5350,
            Blocks::EndPortalFrame(state) => {
                5351 + (state.facing as i32) + 4 * (!state.eye() as i32)
            }
            Blocks::EndStone => 5359,
            Blocks::DragonEgg => 5360,
            Blocks::RedstoneLamp(state) => {
                5361 + (!state.lit() as i32)
            }
            Blocks::Cocoa(state) => {
                5363 + (state.facing as i32) + 4 * state.age
            }
            Blocks::SandstoneStairs(state) => {
                5375 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32)
            }
            Blocks::EmeraldOre => 5455,
            Blocks::DeepslateEmeraldOre => 5456,
            Blocks::EnderChest(state) => {
                5457 + (!state.waterlogged() as i32) + 2 * (state.facing as i32)
            }
            Blocks::TripwireHook(state) => {
                5465 + (!state.powered() as i32) + 2 * (state.facing as i32) + 8 * (!state.attached() as i32)
            }
            Blocks::Tripwire(state) => {
                5481 + (!state.west() as i32) + 2 * (!state.south() as i32) + 4 * (!state.powered() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32) + 32 * (!state.disarmed() as i32) + 64 * (!state.attached() as i32)
            }
            Blocks::EmeraldBlock => 5609,
            Blocks::SpruceStairs(state) => {
                5610 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32)
            }
            Blocks::BirchStairs(state) => {
                5690 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32)
            }
            Blocks::JungleStairs(state) => {
                5770 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32)
            }
            Blocks::CommandBlock(state) => {
                5850 + (state.facing as i32) + 6 * (!state.conditional() as i32)
            }
            Blocks::Beacon => 5862,
            Blocks::CobblestoneWall(state) => {
                5863 + (state.west as i32) + 3 * (!state.waterlogged() as i32) + 6 * (!state.up() as i32) + 12 * (state.south as i32) + 36 * (state.north as i32) + 108 * (state.east as i32)
            }
            Blocks::MossyCobblestoneWall(state) => {
                6187 + (state.west as i32) + 3 * (!state.waterlogged() as i32) + 6 * (!state.up() as i32) + 12 * (state.south as i32) + 36 * (state.north as i32) + 108 * (state.east as i32)
            }
            Blocks::FlowerPot => 6511,
            Blocks::PottedOakSapling => 6512,
            Blocks::PottedSpruceSapling => 6513,
            Blocks::PottedBirchSapling => 6514,
            Blocks::PottedJungleSapling => 6515,
            Blocks::PottedAcaciaSapling => 6516,
            Blocks::PottedDarkOakSapling => 6517,
            Blocks::PottedFern => 6518,
            Blocks::PottedDandelion => 6519,
            Blocks::PottedPoppy => 6520,
            Blocks::PottedBlueOrchid => 6521,
            Blocks::PottedAllium => 6522,
            Blocks::PottedAzureBluet => 6523,
            Blocks::PottedRedTulip => 6524,
            Blocks::PottedOrangeTulip => 6525,
            Blocks::PottedWhiteTulip => 6526,
            Blocks::PottedPinkTulip => 6527,
            Blocks::PottedOxeyeDaisy => 6528,
            Blocks::PottedCornflower => 6529,
            Blocks::PottedLilyOfTheValley => 6530,
            Blocks::PottedWitherRose => 6531,
            Blocks::PottedRedMushroom => 6532,
            Blocks::PottedBrownMushroom => 6533,
            Blocks::PottedDeadBush => 6534,
            Blocks::PottedCactus => 6535,
            Blocks::Carrots(state) => {
                6536 + state.age
            }
            Blocks::Potatoes(state) => {
                6544 + state.age
            }
            Blocks::OakButton(state) => {
                6552 + (!state.powered() as i32) + 2 * (state.facing as i32) + 8 * (state.face as i32)
            }
            Blocks::SpruceButton(state) => {
                6576 + (!state.powered() as i32) + 2 * (state.facing as i32) + 8 * (state.face as i32)
            }
            Blocks::BirchButton(state) => {
                6600 + (!state.powered() as i32) + 2 * (state.facing as i32) + 8 * (state.face as i32)
            }
            Blocks::JungleButton(state) => {
                6624 + (!state.powered() as i32) + 2 * (state.facing as i32) + 8 * (state.face as i32)
            }
            Blocks::AcaciaButton(state) => {
                6648 + (!state.powered() as i32) + 2 * (state.facing as i32) + 8 * (state.face as i32)
            }
            Blocks::DarkOakButton(state) => {
                6672 + (!state.powered() as i32) + 2 * (state.facing as i32) + 8 * (state.face as i32)
            }
            Blocks::SkeletonSkull(state) => {
                6696 + state.rotation
            }
            Blocks::SkeletonWallSkull(state) => {
                6712 + (state.facing as i32)
            }
            Blocks::WitherSkeletonSkull(state) => {
                6716 + state.rotation
            }
            Blocks::WitherSkeletonWallSkull(state) => {
                6732 + (state.facing as i32)
            }
            Blocks::ZombieHead(state) => {
                6736 + state.rotation
            }
            Blocks::ZombieWallHead(state) => {
                6752 + (state.facing as i32)
            }
            Blocks::PlayerHead(state) => {
                6756 + state.rotation
            }
            Blocks::PlayerWallHead(state) => {
                6772 + (state.facing as i32)
            }
            Blocks::CreeperHead(state) => {
                6776 + state.rotation
            }
            Blocks::CreeperWallHead(state) => {
                6792 + (state.facing as i32)
            }
            Blocks::DragonHead(state) => {
                6796 + state.rotation
            }
            Blocks::DragonWallHead(state) => {
                6812 + (state.facing as i32)
            }
            Blocks::Anvil(state) => {
                6816 + (state.facing as i32)
            }
            Blocks::ChippedAnvil(state) => {
                6820 + (state.facing as i32)
            }
            Blocks::DamagedAnvil(state) => {
                6824 + (state.facing as i32)
            }
            Blocks::TrappedChest(state) => {
                6828 + (!state.waterlogged() as i32) + 2 * (state.typed as i32) + 6 * (state.facing as i32)
            }
            Blocks::LightWeightedPressurePlate(state) => {
                6852 + state.power
            }
            Blocks::HeavyWeightedPressurePlate(state) => {
                6868 + state.power
            }
            Blocks::Comparator(state) => {
                6884 + (!state.powered() as i32) + 2 * (state.mode as i32) + 4 * (state.facing as i32)
            }
            Blocks::DaylightDetector(state) => {
                6900 + state.power + 16 * (!state.inverted() as i32)
            }
            Blocks::RedstoneBlock => 6932,
            Blocks::NetherQuartzOre => 6933,
            Blocks::Hopper(state) => {
                6934 + (state.facing as i32) + 5 * (!state.enabled() as i32)
            }
            Blocks::QuartzBlock => 6944,
            Blocks::ChiseledQuartzBlock => 6945,
            Blocks::QuartzPillar(state) => {
                6946 + (state.axis as i32)
            }
            Blocks::QuartzStairs(state) => {
                6949 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32)
            }
            Blocks::ActivatorRail(state) => {
                7029 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 12 * (!state.powered() as i32)
            }
            Blocks::Dropper(state) => {
                7053 + (!state.triggered() as i32) + 2 * (state.facing as i32)
            }
            Blocks::WhiteTerracotta => 7065,
            Blocks::OrangeTerracotta => 7066,
            Blocks::MagentaTerracotta => 7067,
            Blocks::LightBlueTerracotta => 7068,
            Blocks::YellowTerracotta => 7069,
            Blocks::LimeTerracotta => 7070,
            Blocks::PinkTerracotta => 7071,
            Blocks::GrayTerracotta => 7072,
            Blocks::LightGrayTerracotta => 7073,
            Blocks::CyanTerracotta => 7074,
            Blocks::PurpleTerracotta => 7075,
            Blocks::BlueTerracotta => 7076,
            Blocks::BrownTerracotta => 7077,
            Blocks::GreenTerracotta => 7078,
            Blocks::RedTerracotta => 7079,
            Blocks::BlackTerracotta => 7080,
            Blocks::WhiteStainedGlassPane(state) => {
                7081 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32)
            }
            Blocks::OrangeStainedGlassPane(state) => {
                7113 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32)
            }
            Blocks::MagentaStainedGlassPane(state) => {
                7145 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32)
            }
            Blocks::LightBlueStainedGlassPane(state) => {
                7177 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32)
            }
            Blocks::YellowStainedGlassPane(state) => {
                7209 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32)
            }
            Blocks::LimeStainedGlassPane(state) => {
                7241 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32)
            }
            Blocks::PinkStainedGlassPane(state) => {
                7273 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32)
            }
            Blocks::GrayStainedGlassPane(state) => {
                7305 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32)
            }
            Blocks::LightGrayStainedGlassPane(state) => {
                7337 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32)
            }
            Blocks::CyanStainedGlassPane(state) => {
                7369 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32)
            }
            Blocks::PurpleStainedGlassPane(state) => {
                7401 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32)
            }
            Blocks::BlueStainedGlassPane(state) => {
                7433 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32)
            }
            Blocks::BrownStainedGlassPane(state) => {
                7465 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32)
            }
            Blocks::GreenStainedGlassPane(state) => {
                7497 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32)
            }
            Blocks::RedStainedGlassPane(state) => {
                7529 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32)
            }
            Blocks::BlackStainedGlassPane(state) => {
                7561 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32)
            }
            Blocks::AcaciaStairs(state) => {
                7593 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32)
            }
            Blocks::DarkOakStairs(state) => {
                7673 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32)
            }
            Blocks::SlimeBlock => 7753,
            Blocks::Barrier => 7754,
            Blocks::Light(state) => {
                7755 + (!state.waterlogged() as i32) + 2 * state.level
            }
            Blocks::IronTrapdoor(state) => {
                7787 + (!state.waterlogged() as i32) + 2 * (!state.powered() as i32) + 4 * (!state.open() as i32) + 8 * (state.half as i32) + 16 * (state.facing as i32)
            }
            Blocks::Prismarine => 7851,
            Blocks::PrismarineBricks => 7852,
            Blocks::DarkPrismarine => 7853,
            Blocks::PrismarineStairs(state) => {
                7854 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32)
            }
            Blocks::PrismarineBrickStairs(state) => {
                7934 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32)
            }
            Blocks::DarkPrismarineStairs(state) => {
                8014 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32)
            }
            Blocks::PrismarineSlab(state) => {
                8094 + (!state.waterlogged() as i32) + 2 * (state.typed as i32)
            }
            Blocks::PrismarineBrickSlab(state) => {
                8100 + (!state.waterlogged() as i32) + 2 * (state.typed as i32)
            }
            Blocks::DarkPrismarineSlab(state) => {
                8106 + (!state.waterlogged() as i32) + 2 * (state.typed as i32)
            }
            Blocks::SeaLantern => 8112,
            Blocks::HayBlock(state) => {
                8113 + (state.axis as i32)
            }
            Blocks::WhiteCarpet => 8116,
            Blocks::OrangeCarpet => 8117,
            Blocks::MagentaCarpet => 8118,
            Blocks::LightBlueCarpet => 8119,
            Blocks::YellowCarpet => 8120,
            Blocks::LimeCarpet => 8121,
            Blocks::PinkCarpet => 8122,
            Blocks::GrayCarpet => 8123,
            Blocks::LightGrayCarpet => 8124,
            Blocks::CyanCarpet => 8125,
            Blocks::PurpleCarpet => 8126,
            Blocks::BlueCarpet => 8127,
            Blocks::BrownCarpet => 8128,
            Blocks::GreenCarpet => 8129,
            Blocks::RedCarpet => 8130,
            Blocks::BlackCarpet => 8131,
            Blocks::Terracotta => 8132,
            Blocks::CoalBlock => 8133,
            Blocks::PackedIce => 8134,
            Blocks::Sunflower(state) => {
                8135 + (state.half as i32)
            }
            Blocks::Lilac(state) => {
                8137 + (state.half as i32)
            }
            Blocks::RoseBush(state) => {
                8139 + (state.half as i32)
            }
            Blocks::Peony(state) => {
                8141 + (state.half as i32)
            }
            Blocks::TallGrass(state) => {
                8143 + (state.half as i32)
            }
            Blocks::LargeFern(state) => {
                8145 + (state.half as i32)
            }
            Blocks::WhiteBanner(state) => {
                8147 + state.rotation
            }
            Blocks::OrangeBanner(state) => {
                8163 + state.rotation
            }
            Blocks::MagentaBanner(state) => {
                8179 + state.rotation
            }
            Blocks::LightBlueBanner(state) => {
                8195 + state.rotation
            }
            Blocks::YellowBanner(state) => {
                8211 + state.rotation
            }
            Blocks::LimeBanner(state) => {
                8227 + state.rotation
            }
            Blocks::PinkBanner(state) => {
                8243 + state.rotation
            }
            Blocks::GrayBanner(state) => {
                8259 + state.rotation
            }
            Blocks::LightGrayBanner(state) => {
                8275 + state.rotation
            }
            Blocks::CyanBanner(state) => {
                8291 + state.rotation
            }
            Blocks::PurpleBanner(state) => {
                8307 + state.rotation
            }
            Blocks::BlueBanner(state) => {
                8323 + state.rotation
            }
            Blocks::BrownBanner(state) => {
                8339 + state.rotation
            }
            Blocks::GreenBanner(state) => {
                8355 + state.rotation
            }
            Blocks::RedBanner(state) => {
                8371 + state.rotation
            }
            Blocks::BlackBanner(state) => {
                8387 + state.rotation
            }
            Blocks::WhiteWallBanner(state) => {
                8403 + (state.facing as i32)
            }
            Blocks::OrangeWallBanner(state) => {
                8407 + (state.facing as i32)
            }
            Blocks::MagentaWallBanner(state) => {
                8411 + (state.facing as i32)
            }
            Blocks::LightBlueWallBanner(state) => {
                8415 + (state.facing as i32)
            }
            Blocks::YellowWallBanner(state) => {
                8419 + (state.facing as i32)
            }
            Blocks::LimeWallBanner(state) => {
                8423 + (state.facing as i32)
            }
            Blocks::PinkWallBanner(state) => {
                8427 + (state.facing as i32)
            }
            Blocks::GrayWallBanner(state) => {
                8431 + (state.facing as i32)
            }
            Blocks::LightGrayWallBanner(state) => {
                8435 + (state.facing as i32)
            }
            Blocks::CyanWallBanner(state) => {
                8439 + (state.facing as i32)
            }
            Blocks::PurpleWallBanner(state) => {
                8443 + (state.facing as i32)
            }
            Blocks::BlueWallBanner(state) => {
                8447 + (state.facing as i32)
            }
            Blocks::BrownWallBanner(state) => {
                8451 + (state.facing as i32)
            }
            Blocks::GreenWallBanner(state) => {
                8455 + (state.facing as i32)
            }
            Blocks::RedWallBanner(state) => {
                8459 + (state.facing as i32)
            }
            Blocks::BlackWallBanner(state) => {
                8463 + (state.facing as i32)
            }
            Blocks::RedSandstone => 8467,
            Blocks::ChiseledRedSandstone => 8468,
            Blocks::CutRedSandstone => 8469,
            Blocks::RedSandstoneStairs(state) => {
                8470 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32)
            }
            Blocks::OakSlab(state) => {
                8550 + (!state.waterlogged() as i32) + 2 * (state.typed as i32)
            }
            Blocks::SpruceSlab(state) => {
                8556 + (!state.waterlogged() as i32) + 2 * (state.typed as i32)
            }
            Blocks::BirchSlab(state) => {
                8562 + (!state.waterlogged() as i32) + 2 * (state.typed as i32)
            }
            Blocks::JungleSlab(state) => {
                8568 + (!state.waterlogged() as i32) + 2 * (state.typed as i32)
            }
            Blocks::AcaciaSlab(state) => {
                8574 + (!state.waterlogged() as i32) + 2 * (state.typed as i32)
            }
            Blocks::DarkOakSlab(state) => {
                8580 + (!state.waterlogged() as i32) + 2 * (state.typed as i32)
            }
            Blocks::StoneSlab(state) => {
                8586 + (!state.waterlogged() as i32) + 2 * (state.typed as i32)
            }
            Blocks::SmoothStoneSlab(state) => {
                8592 + (!state.waterlogged() as i32) + 2 * (state.typed as i32)
            }
            Blocks::SandstoneSlab(state) => {
                8598 + (!state.waterlogged() as i32) + 2 * (state.typed as i32)
            }
            Blocks::CutSandstoneSlab(state) => {
                8604 + (!state.waterlogged() as i32) + 2 * (state.typed as i32)
            }
            Blocks::PetrifiedOakSlab(state) => {
                8610 + (!state.waterlogged() as i32) + 2 * (state.typed as i32)
            }
            Blocks::CobblestoneSlab(state) => {
                8616 + (!state.waterlogged() as i32) + 2 * (state.typed as i32)
            }
            Blocks::BrickSlab(state) => {
                8622 + (!state.waterlogged() as i32) + 2 * (state.typed as i32)
            }
            Blocks::StoneBrickSlab(state) => {
                8628 + (!state.waterlogged() as i32) + 2 * (state.typed as i32)
            }
            Blocks::NetherBrickSlab(state) => {
                8634 + (!state.waterlogged() as i32) + 2 * (state.typed as i32)
            }
            Blocks::QuartzSlab(state) => {
                8640 + (!state.waterlogged() as i32) + 2 * (state.typed as i32)
            }
            Blocks::RedSandstoneSlab(state) => {
                8646 + (!state.waterlogged() as i32) + 2 * (state.typed as i32)
            }
            Blocks::CutRedSandstoneSlab(state) => {
                8652 + (!state.waterlogged() as i32) + 2 * (state.typed as i32)
            }
            Blocks::PurpurSlab(state) => {
                8658 + (!state.waterlogged() as i32) + 2 * (state.typed as i32)
            }
            Blocks::SmoothStone => 8664,
            Blocks::SmoothSandstone => 8665,
            Blocks::SmoothQuartz => 8666,
            Blocks::SmoothRedSandstone => 8667,
            Blocks::SpruceFenceGate(state) => {
                8668 + (!state.powered() as i32) + 2 * (!state.open() as i32) + 4 * (!state.in_wall() as i32) + 8 * (state.facing as i32)
            }
            Blocks::BirchFenceGate(state) => {
                8700 + (!state.powered() as i32) + 2 * (!state.open() as i32) + 4 * (!state.in_wall() as i32) + 8 * (state.facing as i32)
            }
            Blocks::JungleFenceGate(state) => {
                8732 + (!state.powered() as i32) + 2 * (!state.open() as i32) + 4 * (!state.in_wall() as i32) + 8 * (state.facing as i32)
            }
            Blocks::AcaciaFenceGate(state) => {
                8764 + (!state.powered() as i32) + 2 * (!state.open() as i32) + 4 * (!state.in_wall() as i32) + 8 * (state.facing as i32)
            }
            Blocks::DarkOakFenceGate(state) => {
                8796 + (!state.powered() as i32) + 2 * (!state.open() as i32) + 4 * (!state.in_wall() as i32) + 8 * (state.facing as i32)
            }
            Blocks::SpruceFence(state) => {
                8828 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32)
            }
            Blocks::BirchFence(state) => {
                8860 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32)
            }
            Blocks::JungleFence(state) => {
                8892 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32)
            }
            Blocks::AcaciaFence(state) => {
                8924 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32)
            }
            Blocks::DarkOakFence(state) => {
                8956 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32)
            }
            Blocks::SpruceDoor(state) => {
                8988 + (!state.powered() as i32) + 2 * (!state.open() as i32) + 4 * (state.hinge as i32) + 8 * (state.half as i32) + 16 * (state.facing as i32)
            }
            Blocks::BirchDoor(state) => {
                9052 + (!state.powered() as i32) + 2 * (!state.open() as i32) + 4 * (state.hinge as i32) + 8 * (state.half as i32) + 16 * (state.facing as i32)
            }
            Blocks::JungleDoor(state) => {
                9116 + (!state.powered() as i32) + 2 * (!state.open() as i32) + 4 * (state.hinge as i32) + 8 * (state.half as i32) + 16 * (state.facing as i32)
            }
            Blocks::AcaciaDoor(state) => {
                9180 + (!state.powered() as i32) + 2 * (!state.open() as i32) + 4 * (state.hinge as i32) + 8 * (state.half as i32) + 16 * (state.facing as i32)
            }
            Blocks::DarkOakDoor(state) => {
                9244 + (!state.powered() as i32) + 2 * (!state.open() as i32) + 4 * (state.hinge as i32) + 8 * (state.half as i32) + 16 * (state.facing as i32)
            }
            Blocks::EndRod(state) => {
                9308 + (state.facing as i32)
            }
            Blocks::ChorusPlant(state) => {
                9314 + (!state.west() as i32) + 2 * (!state.up() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32) + 32 * (!state.down() as i32)
            }
            Blocks::ChorusFlower(state) => {
                9378 + state.age
            }
            Blocks::PurpurBlock => 9384,
            Blocks::PurpurPillar(state) => {
                9385 + (state.axis as i32)
            }
            Blocks::PurpurStairs(state) => {
                9388 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32)
            }
            Blocks::EndStoneBricks => 9468,
            Blocks::Beetroots(state) => {
                9469 + state.age
            }
            Blocks::DirtPath => 9473,
            Blocks::EndGateway => 9474,
            Blocks::RepeatingCommandBlock(state) => {
                9475 + (state.facing as i32) + 6 * (!state.conditional() as i32)
            }
            Blocks::ChainCommandBlock(state) => {
                9487 + (state.facing as i32) + 6 * (!state.conditional() as i32)
            }
            Blocks::FrostedIce(state) => {
                9499 + state.age
            }
            Blocks::MagmaBlock => 9503,
            Blocks::NetherWartBlock => 9504,
            Blocks::RedNetherBricks => 9505,
            Blocks::BoneBlock(state) => {
                9506 + (state.axis as i32)
            }
            Blocks::StructureVoid => 9509,
            Blocks::Observer(state) => {
                9510 + (!state.powered() as i32) + 2 * (state.facing as i32)
            }
            Blocks::ShulkerBox(state) => {
                9522 + (state.facing as i32)
            }
            Blocks::WhiteShulkerBox(state) => {
                9528 + (state.facing as i32)
            }
            Blocks::OrangeShulkerBox(state) => {
                9534 + (state.facing as i32)
            }
            Blocks::MagentaShulkerBox(state) => {
                9540 + (state.facing as i32)
            }
            Blocks::LightBlueShulkerBox(state) => {
                9546 + (state.facing as i32)
            }
            Blocks::YellowShulkerBox(state) => {
                9552 + (state.facing as i32)
            }
            Blocks::LimeShulkerBox(state) => {
                9558 + (state.facing as i32)
            }
            Blocks::PinkShulkerBox(state) => {
                9564 + (state.facing as i32)
            }
            Blocks::GrayShulkerBox(state) => {
                9570 + (state.facing as i32)
            }
            Blocks::LightGrayShulkerBox(state) => {
                9576 + (state.facing as i32)
            }
            Blocks::CyanShulkerBox(state) => {
                9582 + (state.facing as i32)
            }
            Blocks::PurpleShulkerBox(state) => {
                9588 + (state.facing as i32)
            }
            Blocks::BlueShulkerBox(state) => {
                9594 + (state.facing as i32)
            }
            Blocks::BrownShulkerBox(state) => {
                9600 + (state.facing as i32)
            }
            Blocks::GreenShulkerBox(state) => {
                9606 + (state.facing as i32)
            }
            Blocks::RedShulkerBox(state) => {
                9612 + (state.facing as i32)
            }
            Blocks::BlackShulkerBox(state) => {
                9618 + (state.facing as i32)
            }
            Blocks::WhiteGlazedTerracotta(state) => {
                9624 + (state.facing as i32)
            }
            Blocks::OrangeGlazedTerracotta(state) => {
                9628 + (state.facing as i32)
            }
            Blocks::MagentaGlazedTerracotta(state) => {
                9632 + (state.facing as i32)
            }
            Blocks::LightBlueGlazedTerracotta(state) => {
                9636 + (state.facing as i32)
            }
            Blocks::YellowGlazedTerracotta(state) => {
                9640 + (state.facing as i32)
            }
            Blocks::LimeGlazedTerracotta(state) => {
                9644 + (state.facing as i32)
            }
            Blocks::PinkGlazedTerracotta(state) => {
                9648 + (state.facing as i32)
            }
            Blocks::GrayGlazedTerracotta(state) => {
                9652 + (state.facing as i32)
            }
            Blocks::LightGrayGlazedTerracotta(state) => {
                9656 + (state.facing as i32)
            }
            Blocks::CyanGlazedTerracotta(state) => {
                9660 + (state.facing as i32)
            }
            Blocks::PurpleGlazedTerracotta(state) => {
                9664 + (state.facing as i32)
            }
            Blocks::BlueGlazedTerracotta(state) => {
                9668 + (state.facing as i32)
            }
            Blocks::BrownGlazedTerracotta(state) => {
                9672 + (state.facing as i32)
            }
            Blocks::GreenGlazedTerracotta(state) => {
                9676 + (state.facing as i32)
            }
            Blocks::RedGlazedTerracotta(state) => {
                9680 + (state.facing as i32)
            }
            Blocks::BlackGlazedTerracotta(state) => {
                9684 + (state.facing as i32)
            }
            Blocks::WhiteConcrete => 9688,
            Blocks::OrangeConcrete => 9689,
            Blocks::MagentaConcrete => 9690,
            Blocks::LightBlueConcrete => 9691,
            Blocks::YellowConcrete => 9692,
            Blocks::LimeConcrete => 9693,
            Blocks::PinkConcrete => 9694,
            Blocks::GrayConcrete => 9695,
            Blocks::LightGrayConcrete => 9696,
            Blocks::CyanConcrete => 9697,
            Blocks::PurpleConcrete => 9698,
            Blocks::BlueConcrete => 9699,
            Blocks::BrownConcrete => 9700,
            Blocks::GreenConcrete => 9701,
            Blocks::RedConcrete => 9702,
            Blocks::BlackConcrete => 9703,
            Blocks::WhiteConcretePowder => 9704,
            Blocks::OrangeConcretePowder => 9705,
            Blocks::MagentaConcretePowder => 9706,
            Blocks::LightBlueConcretePowder => 9707,
            Blocks::YellowConcretePowder => 9708,
            Blocks::LimeConcretePowder => 9709,
            Blocks::PinkConcretePowder => 9710,
            Blocks::GrayConcretePowder => 9711,
            Blocks::LightGrayConcretePowder => 9712,
            Blocks::CyanConcretePowder => 9713,
            Blocks::PurpleConcretePowder => 9714,
            Blocks::BlueConcretePowder => 9715,
            Blocks::BrownConcretePowder => 9716,
            Blocks::GreenConcretePowder => 9717,
            Blocks::RedConcretePowder => 9718,
            Blocks::BlackConcretePowder => 9719,
            Blocks::Kelp(state) => {
                9720 + state.age
            }
            Blocks::KelpPlant => 9746,
            Blocks::DriedKelpBlock => 9747,
            Blocks::TurtleEgg(state) => {
                9748 + state.hatch + 3 * state.eggs
            }
            Blocks::DeadTubeCoralBlock => 9760,
            Blocks::DeadBrainCoralBlock => 9761,
            Blocks::DeadBubbleCoralBlock => 9762,
            Blocks::DeadFireCoralBlock => 9763,
            Blocks::DeadHornCoralBlock => 9764,
            Blocks::TubeCoralBlock => 9765,
            Blocks::BrainCoralBlock => 9766,
            Blocks::BubbleCoralBlock => 9767,
            Blocks::FireCoralBlock => 9768,
            Blocks::HornCoralBlock => 9769,
            Blocks::DeadTubeCoral(state) => {
                9770 + (!state.waterlogged() as i32)
            }
            Blocks::DeadBrainCoral(state) => {
                9772 + (!state.waterlogged() as i32)
            }
            Blocks::DeadBubbleCoral(state) => {
                9774 + (!state.waterlogged() as i32)
            }
            Blocks::DeadFireCoral(state) => {
                9776 + (!state.waterlogged() as i32)
            }
            Blocks::DeadHornCoral(state) => {
                9778 + (!state.waterlogged() as i32)
            }
            Blocks::TubeCoral(state) => {
                9780 + (!state.waterlogged() as i32)
            }
            Blocks::BrainCoral(state) => {
                9782 + (!state.waterlogged() as i32)
            }
            Blocks::BubbleCoral(state) => {
                9784 + (!state.waterlogged() as i32)
            }
            Blocks::FireCoral(state) => {
                9786 + (!state.waterlogged() as i32)
            }
            Blocks::HornCoral(state) => {
                9788 + (!state.waterlogged() as i32)
            }
            Blocks::DeadTubeCoralFan(state) => {
                9790 + (!state.waterlogged() as i32)
            }
            Blocks::DeadBrainCoralFan(state) => {
                9792 + (!state.waterlogged() as i32)
            }
            Blocks::DeadBubbleCoralFan(state) => {
                9794 + (!state.waterlogged() as i32)
            }
            Blocks::DeadFireCoralFan(state) => {
                9796 + (!state.waterlogged() as i32)
            }
            Blocks::DeadHornCoralFan(state) => {
                9798 + (!state.waterlogged() as i32)
            }
            Blocks::TubeCoralFan(state) => {
                9800 + (!state.waterlogged() as i32)
            }
            Blocks::BrainCoralFan(state) => {
                9802 + (!state.waterlogged() as i32)
            }
            Blocks::BubbleCoralFan(state) => {
                9804 + (!state.waterlogged() as i32)
            }
            Blocks::FireCoralFan(state) => {
                9806 + (!state.waterlogged() as i32)
            }
            Blocks::HornCoralFan(state) => {
                9808 + (!state.waterlogged() as i32)
            }
            Blocks::DeadTubeCoralWallFan(state) => {
                9810 + (!state.waterlogged() as i32) + 2 * (state.facing as i32)
            }
            Blocks::DeadBrainCoralWallFan(state) => {
                9818 + (!state.waterlogged() as i32) + 2 * (state.facing as i32)
            }
            Blocks::DeadBubbleCoralWallFan(state) => {
                9826 + (!state.waterlogged() as i32) + 2 * (state.facing as i32)
            }
            Blocks::DeadFireCoralWallFan(state) => {
                9834 + (!state.waterlogged() as i32) + 2 * (state.facing as i32)
            }
            Blocks::DeadHornCoralWallFan(state) => {
                9842 + (!state.waterlogged() as i32) + 2 * (state.facing as i32)
            }
            Blocks::TubeCoralWallFan(state) => {
                9850 + (!state.waterlogged() as i32) + 2 * (state.facing as i32)
            }
            Blocks::BrainCoralWallFan(state) => {
                9858 + (!state.waterlogged() as i32) + 2 * (state.facing as i32)
            }
            Blocks::BubbleCoralWallFan(state) => {
                9866 + (!state.waterlogged() as i32) + 2 * (state.facing as i32)
            }
            Blocks::FireCoralWallFan(state) => {
                9874 + (!state.waterlogged() as i32) + 2 * (state.facing as i32)
            }
            Blocks::HornCoralWallFan(state) => {
                9882 + (!state.waterlogged() as i32) + 2 * (state.facing as i32)
            }
            Blocks::SeaPickle(state) => {
                9890 + (!state.waterlogged() as i32) + 2 * state.pickles
            }
            Blocks::BlueIce => 9898,
            Blocks::Conduit(state) => {
                9899 + (!state.waterlogged() as i32)
            }
            Blocks::BambooSapling => 9901,
            Blocks::Bamboo(state) => {
                9902 + state.stage + 2 * (state.leaves as i32) + 6 * state.age
            }
            Blocks::PottedBamboo => 9914,
            Blocks::VoidAir => 9915,
            Blocks::CaveAir => 9916,
            Blocks::BubbleColumn(state) => {
                9917 + (!state.drag() as i32)
            }
            Blocks::PolishedGraniteStairs(state) => {
                9919 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32)
            }
            Blocks::SmoothRedSandstoneStairs(state) => {
                9999 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32)
            }
            Blocks::MossyStoneBrickStairs(state) => {
                10079 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32)
            }
            Blocks::PolishedDioriteStairs(state) => {
                10159 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32)
            }
            Blocks::MossyCobblestoneStairs(state) => {
                10239 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32)
            }
            Blocks::EndStoneBrickStairs(state) => {
                10319 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32)
            }
            Blocks::StoneStairs(state) => {
                10399 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32)
            }
            Blocks::SmoothSandstoneStairs(state) => {
                10479 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32)
            }
            Blocks::SmoothQuartzStairs(state) => {
                10559 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32)
            }
            Blocks::GraniteStairs(state) => {
                10639 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32)
            }
            Blocks::AndesiteStairs(state) => {
                10719 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32)
            }
            Blocks::RedNetherBrickStairs(state) => {
                10799 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32)
            }
            Blocks::PolishedAndesiteStairs(state) => {
                10879 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32)
            }
            Blocks::DioriteStairs(state) => {
                10959 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32)
            }
            Blocks::PolishedGraniteSlab(state) => {
                11039 + (!state.waterlogged() as i32) + 2 * (state.typed as i32)
            }
            Blocks::SmoothRedSandstoneSlab(state) => {
                11045 + (!state.waterlogged() as i32) + 2 * (state.typed as i32)
            }
            Blocks::MossyStoneBrickSlab(state) => {
                11051 + (!state.waterlogged() as i32) + 2 * (state.typed as i32)
            }
            Blocks::PolishedDioriteSlab(state) => {
                11057 + (!state.waterlogged() as i32) + 2 * (state.typed as i32)
            }
            Blocks::MossyCobblestoneSlab(state) => {
                11063 + (!state.waterlogged() as i32) + 2 * (state.typed as i32)
            }
            Blocks::EndStoneBrickSlab(state) => {
                11069 + (!state.waterlogged() as i32) + 2 * (state.typed as i32)
            }
            Blocks::SmoothSandstoneSlab(state) => {
                11075 + (!state.waterlogged() as i32) + 2 * (state.typed as i32)
            }
            Blocks::SmoothQuartzSlab(state) => {
                11081 + (!state.waterlogged() as i32) + 2 * (state.typed as i32)
            }
            Blocks::GraniteSlab(state) => {
                11087 + (!state.waterlogged() as i32) + 2 * (state.typed as i32)
            }
            Blocks::AndesiteSlab(state) => {
                11093 + (!state.waterlogged() as i32) + 2 * (state.typed as i32)
            }
            Blocks::RedNetherBrickSlab(state) => {
                11099 + (!state.waterlogged() as i32) + 2 * (state.typed as i32)
            }
            Blocks::PolishedAndesiteSlab(state) => {
                11105 + (!state.waterlogged() as i32) + 2 * (state.typed as i32)
            }
            Blocks::DioriteSlab(state) => {
                11111 + (!state.waterlogged() as i32) + 2 * (state.typed as i32)
            }
            Blocks::BrickWall(state) => {
                11117 + (state.west as i32) + 3 * (!state.waterlogged() as i32) + 6 * (!state.up() as i32) + 12 * (state.south as i32) + 36 * (state.north as i32) + 108 * (state.east as i32)
            }
            Blocks::PrismarineWall(state) => {
                11441 + (state.west as i32) + 3 * (!state.waterlogged() as i32) + 6 * (!state.up() as i32) + 12 * (state.south as i32) + 36 * (state.north as i32) + 108 * (state.east as i32)
            }
            Blocks::RedSandstoneWall(state) => {
                11765 + (state.west as i32) + 3 * (!state.waterlogged() as i32) + 6 * (!state.up() as i32) + 12 * (state.south as i32) + 36 * (state.north as i32) + 108 * (state.east as i32)
            }
            Blocks::MossyStoneBrickWall(state) => {
                12089 + (state.west as i32) + 3 * (!state.waterlogged() as i32) + 6 * (!state.up() as i32) + 12 * (state.south as i32) + 36 * (state.north as i32) + 108 * (state.east as i32)
            }
            Blocks::GraniteWall(state) => {
                12413 + (state.west as i32) + 3 * (!state.waterlogged() as i32) + 6 * (!state.up() as i32) + 12 * (state.south as i32) + 36 * (state.north as i32) + 108 * (state.east as i32)
            }
            Blocks::StoneBrickWall(state) => {
                12737 + (state.west as i32) + 3 * (!state.waterlogged() as i32) + 6 * (!state.up() as i32) + 12 * (state.south as i32) + 36 * (state.north as i32) + 108 * (state.east as i32)
            }
            Blocks::NetherBrickWall(state) => {
                13061 + (state.west as i32) + 3 * (!state.waterlogged() as i32) + 6 * (!state.up() as i32) + 12 * (state.south as i32) + 36 * (state.north as i32) + 108 * (state.east as i32)
            }
            Blocks::AndesiteWall(state) => {
                13385 + (state.west as i32) + 3 * (!state.waterlogged() as i32) + 6 * (!state.up() as i32) + 12 * (state.south as i32) + 36 * (state.north as i32) + 108 * (state.east as i32)
            }
            Blocks::RedNetherBrickWall(state) => {
                13709 + (state.west as i32) + 3 * (!state.waterlogged() as i32) + 6 * (!state.up() as i32) + 12 * (state.south as i32) + 36 * (state.north as i32) + 108 * (state.east as i32)
            }
            Blocks::SandstoneWall(state) => {
                14033 + (state.west as i32) + 3 * (!state.waterlogged() as i32) + 6 * (!state.up() as i32) + 12 * (state.south as i32) + 36 * (state.north as i32) + 108 * (state.east as i32)
            }
            Blocks::EndStoneBrickWall(state) => {
                14357 + (state.west as i32) + 3 * (!state.waterlogged() as i32) + 6 * (!state.up() as i32) + 12 * (state.south as i32) + 36 * (state.north as i32) + 108 * (state.east as i32)
            }
            Blocks::DioriteWall(state) => {
                14681 + (state.west as i32) + 3 * (!state.waterlogged() as i32) + 6 * (!state.up() as i32) + 12 * (state.south as i32) + 36 * (state.north as i32) + 108 * (state.east as i32)
            }
            Blocks::Scaffolding(state) => {
                15005 + (!state.waterlogged() as i32) + 2 * state.distance + 16 * (!state.bottom() as i32)
            }
            Blocks::Loom(state) => {
                15037 + (state.facing as i32)
            }
            Blocks::Barrel(state) => {
                15041 + (!state.open() as i32) + 2 * (state.facing as i32)
            }
            Blocks::Smoker(state) => {
                15053 + (!state.lit() as i32) + 2 * (state.facing as i32)
            }
            Blocks::BlastFurnace(state) => {
                15061 + (!state.lit() as i32) + 2 * (state.facing as i32)
            }
            Blocks::CartographyTable => 15069,
            Blocks::FletchingTable => 15070,
            Blocks::Grindstone(state) => {
                15071 + (state.facing as i32) + 4 * (state.face as i32)
            }
            Blocks::Lectern(state) => {
                15083 + (!state.powered() as i32) + 2 * (!state.has_book() as i32) + 4 * (state.facing as i32)
            }
            Blocks::SmithingTable => 15099,
            Blocks::Stonecutter(state) => {
                15100 + (state.facing as i32)
            }
            Blocks::Bell(state) => {
                15104 + (!state.powered() as i32) + 2 * (state.facing as i32) + 8 * (state.attachment as i32)
            }
            Blocks::Lantern(state) => {
                15136 + (!state.waterlogged() as i32) + 2 * (!state.hanging() as i32)
            }
            Blocks::SoulLantern(state) => {
                15140 + (!state.waterlogged() as i32) + 2 * (!state.hanging() as i32)
            }
            Blocks::Campfire(state) => {
                15144 + (!state.waterlogged() as i32) + 2 * (!state.signal_fire() as i32) + 4 * (!state.lit() as i32) + 8 * (state.facing as i32)
            }
            Blocks::SoulCampfire(state) => {
                15176 + (!state.waterlogged() as i32) + 2 * (!state.signal_fire() as i32) + 4 * (!state.lit() as i32) + 8 * (state.facing as i32)
            }
            Blocks::SweetBerryBush(state) => {
                15208 + state.age
            }
            Blocks::WarpedStem(state) => {
                15212 + (state.axis as i32)
            }
            Blocks::StrippedWarpedStem(state) => {
                15215 + (state.axis as i32)
            }
            Blocks::WarpedHyphae(state) => {
                15218 + (state.axis as i32)
            }
            Blocks::StrippedWarpedHyphae(state) => {
                15221 + (state.axis as i32)
            }
            Blocks::WarpedNylium => 15224,
            Blocks::WarpedFungus => 15225,
            Blocks::WarpedWartBlock => 15226,
            Blocks::WarpedRoots => 15227,
            Blocks::NetherSprouts => 15228,
            Blocks::CrimsonStem(state) => {
                15229 + (state.axis as i32)
            }
            Blocks::StrippedCrimsonStem(state) => {
                15232 + (state.axis as i32)
            }
            Blocks::CrimsonHyphae(state) => {
                15235 + (state.axis as i32)
            }
            Blocks::StrippedCrimsonHyphae(state) => {
                15238 + (state.axis as i32)
            }
            Blocks::CrimsonNylium => 15241,
            Blocks::CrimsonFungus => 15242,
            Blocks::Shroomlight => 15243,
            Blocks::WeepingVines(state) => {
                15244 + state.age
            }
            Blocks::WeepingVinesPlant => 15270,
            Blocks::TwistingVines(state) => {
                15271 + state.age
            }
            Blocks::TwistingVinesPlant => 15297,
            Blocks::CrimsonRoots => 15298,
            Blocks::CrimsonPlanks => 15299,
            Blocks::WarpedPlanks => 15300,
            Blocks::CrimsonSlab(state) => {
                15301 + (!state.waterlogged() as i32) + 2 * (state.typed as i32)
            }
            Blocks::WarpedSlab(state) => {
                15307 + (!state.waterlogged() as i32) + 2 * (state.typed as i32)
            }
            Blocks::CrimsonPressurePlate(state) => {
                15313 + (!state.powered() as i32)
            }
            Blocks::WarpedPressurePlate(state) => {
                15315 + (!state.powered() as i32)
            }
            Blocks::CrimsonFence(state) => {
                15317 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32)
            }
            Blocks::WarpedFence(state) => {
                15349 + (!state.west() as i32) + 2 * (!state.waterlogged() as i32) + 4 * (!state.south() as i32) + 8 * (!state.north() as i32) + 16 * (!state.east() as i32)
            }
            Blocks::CrimsonTrapdoor(state) => {
                15381 + (!state.waterlogged() as i32) + 2 * (!state.powered() as i32) + 4 * (!state.open() as i32) + 8 * (state.half as i32) + 16 * (state.facing as i32)
            }
            Blocks::WarpedTrapdoor(state) => {
                15445 + (!state.waterlogged() as i32) + 2 * (!state.powered() as i32) + 4 * (!state.open() as i32) + 8 * (state.half as i32) + 16 * (state.facing as i32)
            }
            Blocks::CrimsonFenceGate(state) => {
                15509 + (!state.powered() as i32) + 2 * (!state.open() as i32) + 4 * (!state.in_wall() as i32) + 8 * (state.facing as i32)
            }
            Blocks::WarpedFenceGate(state) => {
                15541 + (!state.powered() as i32) + 2 * (!state.open() as i32) + 4 * (!state.in_wall() as i32) + 8 * (state.facing as i32)
            }
            Blocks::CrimsonStairs(state) => {
                15573 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32)
            }
            Blocks::WarpedStairs(state) => {
                15653 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32)
            }
            Blocks::CrimsonButton(state) => {
                15733 + (!state.powered() as i32) + 2 * (state.facing as i32) + 8 * (state.face as i32)
            }
            Blocks::WarpedButton(state) => {
                15757 + (!state.powered() as i32) + 2 * (state.facing as i32) + 8 * (state.face as i32)
            }
            Blocks::CrimsonDoor(state) => {
                15781 + (!state.powered() as i32) + 2 * (!state.open() as i32) + 4 * (state.hinge as i32) + 8 * (state.half as i32) + 16 * (state.facing as i32)
            }
            Blocks::WarpedDoor(state) => {
                15845 + (!state.powered() as i32) + 2 * (!state.open() as i32) + 4 * (state.hinge as i32) + 8 * (state.half as i32) + 16 * (state.facing as i32)
            }
            Blocks::CrimsonSign(state) => {
                15909 + (!state.waterlogged() as i32) + 2 * state.rotation
            }
            Blocks::WarpedSign(state) => {
                15941 + (!state.waterlogged() as i32) + 2 * state.rotation
            }
            Blocks::CrimsonWallSign(state) => {
                15973 + (!state.waterlogged() as i32) + 2 * (state.facing as i32)
            }
            Blocks::WarpedWallSign(state) => {
                15981 + (!state.waterlogged() as i32) + 2 * (state.facing as i32)
            }
            Blocks::StructureBlock(state) => {
                15989 + (state.mode as i32)
            }
            Blocks::Jigsaw(state) => {
                15993 + (state.orientation as i32)
            }
            Blocks::Composter(state) => {
                16005 + state.level
            }
            Blocks::Target(state) => {
                16014 + state.power
            }
            Blocks::BeeNest(state) => {
                16030 + state.honey_level + 6 * (state.facing as i32)
            }
            Blocks::Beehive(state) => {
                16054 + state.honey_level + 6 * (state.facing as i32)
            }
            Blocks::HoneyBlock => 16078,
            Blocks::HoneycombBlock => 16079,
            Blocks::NetheriteBlock => 16080,
            Blocks::AncientDebris => 16081,
            Blocks::CryingObsidian => 16082,
            Blocks::RespawnAnchor(state) => {
                16083 + state.charges
            }
            Blocks::PottedCrimsonFungus => 16088,
            Blocks::PottedWarpedFungus => 16089,
            Blocks::PottedCrimsonRoots => 16090,
            Blocks::PottedWarpedRoots => 16091,
            Blocks::Lodestone => 16092,
            Blocks::Blackstone => 16093,
            Blocks::BlackstoneStairs(state) => {
                16094 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32)
            }
            Blocks::BlackstoneWall(state) => {
                16174 + (state.west as i32) + 3 * (!state.waterlogged() as i32) + 6 * (!state.up() as i32) + 12 * (state.south as i32) + 36 * (state.north as i32) + 108 * (state.east as i32)
            }
            Blocks::BlackstoneSlab(state) => {
                16498 + (!state.waterlogged() as i32) + 2 * (state.typed as i32)
            }
            Blocks::PolishedBlackstone => 16504,
            Blocks::PolishedBlackstoneBricks => 16505,
            Blocks::CrackedPolishedBlackstoneBricks => 16506,
            Blocks::ChiseledPolishedBlackstone => 16507,
            Blocks::PolishedBlackstoneBrickSlab(state) => {
                16508 + (!state.waterlogged() as i32) + 2 * (state.typed as i32)
            }
            Blocks::PolishedBlackstoneBrickStairs(state) => {
                16514 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32)
            }
            Blocks::PolishedBlackstoneBrickWall(state) => {
                16594 + (state.west as i32) + 3 * (!state.waterlogged() as i32) + 6 * (!state.up() as i32) + 12 * (state.south as i32) + 36 * (state.north as i32) + 108 * (state.east as i32)
            }
            Blocks::GildedBlackstone => 16918,
            Blocks::PolishedBlackstoneStairs(state) => {
                16919 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32)
            }
            Blocks::PolishedBlackstoneSlab(state) => {
                16999 + (!state.waterlogged() as i32) + 2 * (state.typed as i32)
            }
            Blocks::PolishedBlackstonePressurePlate(state) => {
                17005 + (!state.powered() as i32)
            }
            Blocks::PolishedBlackstoneButton(state) => {
                17007 + (!state.powered() as i32) + 2 * (state.facing as i32) + 8 * (state.face as i32)
            }
            Blocks::PolishedBlackstoneWall(state) => {
                17031 + (state.west as i32) + 3 * (!state.waterlogged() as i32) + 6 * (!state.up() as i32) + 12 * (state.south as i32) + 36 * (state.north as i32) + 108 * (state.east as i32)
            }
            Blocks::ChiseledNetherBricks => 17355,
            Blocks::CrackedNetherBricks => 17356,
            Blocks::QuartzBricks => 17357,
            Blocks::Candle(state) => {
                17358 + (!state.waterlogged() as i32) + 2 * (!state.lit() as i32) + 4 * state.candles
            }
            Blocks::WhiteCandle(state) => {
                17374 + (!state.waterlogged() as i32) + 2 * (!state.lit() as i32) + 4 * state.candles
            }
            Blocks::OrangeCandle(state) => {
                17390 + (!state.waterlogged() as i32) + 2 * (!state.lit() as i32) + 4 * state.candles
            }
            Blocks::MagentaCandle(state) => {
                17406 + (!state.waterlogged() as i32) + 2 * (!state.lit() as i32) + 4 * state.candles
            }
            Blocks::LightBlueCandle(state) => {
                17422 + (!state.waterlogged() as i32) + 2 * (!state.lit() as i32) + 4 * state.candles
            }
            Blocks::YellowCandle(state) => {
                17438 + (!state.waterlogged() as i32) + 2 * (!state.lit() as i32) + 4 * state.candles
            }
            Blocks::LimeCandle(state) => {
                17454 + (!state.waterlogged() as i32) + 2 * (!state.lit() as i32) + 4 * state.candles
            }
            Blocks::PinkCandle(state) => {
                17470 + (!state.waterlogged() as i32) + 2 * (!state.lit() as i32) + 4 * state.candles
            }
            Blocks::GrayCandle(state) => {
                17486 + (!state.waterlogged() as i32) + 2 * (!state.lit() as i32) + 4 * state.candles
            }
            Blocks::LightGrayCandle(state) => {
                17502 + (!state.waterlogged() as i32) + 2 * (!state.lit() as i32) + 4 * state.candles
            }
            Blocks::CyanCandle(state) => {
                17518 + (!state.waterlogged() as i32) + 2 * (!state.lit() as i32) + 4 * state.candles
            }
            Blocks::PurpleCandle(state) => {
                17534 + (!state.waterlogged() as i32) + 2 * (!state.lit() as i32) + 4 * state.candles
            }
            Blocks::BlueCandle(state) => {
                17550 + (!state.waterlogged() as i32) + 2 * (!state.lit() as i32) + 4 * state.candles
            }
            Blocks::BrownCandle(state) => {
                17566 + (!state.waterlogged() as i32) + 2 * (!state.lit() as i32) + 4 * state.candles
            }
            Blocks::GreenCandle(state) => {
                17582 + (!state.waterlogged() as i32) + 2 * (!state.lit() as i32) + 4 * state.candles
            }
            Blocks::RedCandle(state) => {
                17598 + (!state.waterlogged() as i32) + 2 * (!state.lit() as i32) + 4 * state.candles
            }
            Blocks::BlackCandle(state) => {
                17614 + (!state.waterlogged() as i32) + 2 * (!state.lit() as i32) + 4 * state.candles
            }
            Blocks::CandleCake(state) => {
                17630 + (!state.lit() as i32)
            }
            Blocks::WhiteCandleCake(state) => {
                17632 + (!state.lit() as i32)
            }
            Blocks::OrangeCandleCake(state) => {
                17634 + (!state.lit() as i32)
            }
            Blocks::MagentaCandleCake(state) => {
                17636 + (!state.lit() as i32)
            }
            Blocks::LightBlueCandleCake(state) => {
                17638 + (!state.lit() as i32)
            }
            Blocks::YellowCandleCake(state) => {
                17640 + (!state.lit() as i32)
            }
            Blocks::LimeCandleCake(state) => {
                17642 + (!state.lit() as i32)
            }
            Blocks::PinkCandleCake(state) => {
                17644 + (!state.lit() as i32)
            }
            Blocks::GrayCandleCake(state) => {
                17646 + (!state.lit() as i32)
            }
            Blocks::LightGrayCandleCake(state) => {
                17648 + (!state.lit() as i32)
            }
            Blocks::CyanCandleCake(state) => {
                17650 + (!state.lit() as i32)
            }
            Blocks::PurpleCandleCake(state) => {
                17652 + (!state.lit() as i32)
            }
            Blocks::BlueCandleCake(state) => {
                17654 + (!state.lit() as i32)
            }
            Blocks::BrownCandleCake(state) => {
                17656 + (!state.lit() as i32)
            }
            Blocks::GreenCandleCake(state) => {
                17658 + (!state.lit() as i32)
            }
            Blocks::RedCandleCake(state) => {
                17660 + (!state.lit() as i32)
            }
            Blocks::BlackCandleCake(state) => {
                17662 + (!state.lit() as i32)
            }
            Blocks::AmethystBlock => 17664,
            Blocks::BuddingAmethyst => 17665,
            Blocks::AmethystCluster(state) => {
                17666 + (!state.waterlogged() as i32) + 2 * (state.facing as i32)
            }
            Blocks::LargeAmethystBud(state) => {
                17678 + (!state.waterlogged() as i32) + 2 * (state.facing as i32)
            }
            Blocks::MediumAmethystBud(state) => {
                17690 + (!state.waterlogged() as i32) + 2 * (state.facing as i32)
            }
            Blocks::SmallAmethystBud(state) => {
                17702 + (!state.waterlogged() as i32) + 2 * (state.facing as i32)
            }
            Blocks::Tuff => 17714,
            Blocks::Calcite => 17715,
            Blocks::TintedGlass => 17716,
            Blocks::PowderSnow => 17717,
            Blocks::SculkSensor(state) => {
                17718 + (!state.waterlogged() as i32) + 2 * (state.sculk_sensor_phase as i32) + 6 * state.power
            }
            Blocks::OxidizedCopper => 17814,
            Blocks::WeatheredCopper => 17815,
            Blocks::ExposedCopper => 17816,
            Blocks::CopperBlock => 17817,
            Blocks::CopperOre => 17818,
            Blocks::DeepslateCopperOre => 17819,
            Blocks::OxidizedCutCopper => 17820,
            Blocks::WeatheredCutCopper => 17821,
            Blocks::ExposedCutCopper => 17822,
            Blocks::CutCopper => 17823,
            Blocks::OxidizedCutCopperStairs(state) => {
                17824 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32)
            }
            Blocks::WeatheredCutCopperStairs(state) => {
                17904 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32)
            }
            Blocks::ExposedCutCopperStairs(state) => {
                17984 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32)
            }
            Blocks::CutCopperStairs(state) => {
                18064 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32)
            }
            Blocks::OxidizedCutCopperSlab(state) => {
                18144 + (!state.waterlogged() as i32) + 2 * (state.typed as i32)
            }
            Blocks::WeatheredCutCopperSlab(state) => {
                18150 + (!state.waterlogged() as i32) + 2 * (state.typed as i32)
            }
            Blocks::ExposedCutCopperSlab(state) => {
                18156 + (!state.waterlogged() as i32) + 2 * (state.typed as i32)
            }
            Blocks::CutCopperSlab(state) => {
                18162 + (!state.waterlogged() as i32) + 2 * (state.typed as i32)
            }
            Blocks::WaxedCopperBlock => 18168,
            Blocks::WaxedWeatheredCopper => 18169,
            Blocks::WaxedExposedCopper => 18170,
            Blocks::WaxedOxidizedCopper => 18171,
            Blocks::WaxedOxidizedCutCopper => 18172,
            Blocks::WaxedWeatheredCutCopper => 18173,
            Blocks::WaxedExposedCutCopper => 18174,
            Blocks::WaxedCutCopper => 18175,
            Blocks::WaxedOxidizedCutCopperStairs(state) => {
                18176 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32)
            }
            Blocks::WaxedWeatheredCutCopperStairs(state) => {
                18256 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32)
            }
            Blocks::WaxedExposedCutCopperStairs(state) => {
                18336 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32)
            }
            Blocks::WaxedCutCopperStairs(state) => {
                18416 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32)
            }
            Blocks::WaxedOxidizedCutCopperSlab(state) => {
                18496 + (!state.waterlogged() as i32) + 2 * (state.typed as i32)
            }
            Blocks::WaxedWeatheredCutCopperSlab(state) => {
                18502 + (!state.waterlogged() as i32) + 2 * (state.typed as i32)
            }
            Blocks::WaxedExposedCutCopperSlab(state) => {
                18508 + (!state.waterlogged() as i32) + 2 * (state.typed as i32)
            }
            Blocks::WaxedCutCopperSlab(state) => {
                18514 + (!state.waterlogged() as i32) + 2 * (state.typed as i32)
            }
            Blocks::LightningRod(state) => {
                18520 + (!state.waterlogged() as i32) + 2 * (!state.powered() as i32) + 4 * (state.facing as i32)
            }
            Blocks::PointedDripstone(state) => {
                18544 + (!state.waterlogged() as i32) + 2 * (state.vertical_direction as i32) + 4 * (state.thickness as i32)
            }
            Blocks::DripstoneBlock => 18564,
            Blocks::CaveVines(state) => {
                18565 + (!state.berries() as i32) + 2 * state.age
            }
            Blocks::CaveVinesPlant(state) => {
                18617 + (!state.berries() as i32)
            }
            Blocks::SporeBlossom => 18619,
            Blocks::Azalea => 18620,
            Blocks::FloweringAzalea => 18621,
            Blocks::MossCarpet => 18622,
            Blocks::MossBlock => 18623,
            Blocks::BigDripleaf(state) => {
                18624 + (!state.waterlogged() as i32) + 2 * (state.tilt as i32) + 8 * (state.facing as i32)
            }
            Blocks::BigDripleafStem(state) => {
                18656 + (!state.waterlogged() as i32) + 2 * (state.facing as i32)
            }
            Blocks::SmallDripleaf(state) => {
                18664 + (!state.waterlogged() as i32) + 2 * (state.half as i32) + 4 * (state.facing as i32)
            }
            Blocks::HangingRoots(state) => {
                18680 + (!state.waterlogged() as i32)
            }
            Blocks::RootedDirt => 18682,
            Blocks::Deepslate(state) => {
                18683 + (state.axis as i32)
            }
            Blocks::CobbledDeepslate => 18686,
            Blocks::CobbledDeepslateStairs(state) => {
                18687 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32)
            }
            Blocks::CobbledDeepslateSlab(state) => {
                18767 + (!state.waterlogged() as i32) + 2 * (state.typed as i32)
            }
            Blocks::CobbledDeepslateWall(state) => {
                18773 + (state.west as i32) + 3 * (!state.waterlogged() as i32) + 6 * (!state.up() as i32) + 12 * (state.south as i32) + 36 * (state.north as i32) + 108 * (state.east as i32)
            }
            Blocks::PolishedDeepslate => 19097,
            Blocks::PolishedDeepslateStairs(state) => {
                19098 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32)
            }
            Blocks::PolishedDeepslateSlab(state) => {
                19178 + (!state.waterlogged() as i32) + 2 * (state.typed as i32)
            }
            Blocks::PolishedDeepslateWall(state) => {
                19184 + (state.west as i32) + 3 * (!state.waterlogged() as i32) + 6 * (!state.up() as i32) + 12 * (state.south as i32) + 36 * (state.north as i32) + 108 * (state.east as i32)
            }
            Blocks::DeepslateTiles => 19508,
            Blocks::DeepslateTileStairs(state) => {
                19509 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32)
            }
            Blocks::DeepslateTileSlab(state) => {
                19589 + (!state.waterlogged() as i32) + 2 * (state.typed as i32)
            }
            Blocks::DeepslateTileWall(state) => {
                19595 + (state.west as i32) + 3 * (!state.waterlogged() as i32) + 6 * (!state.up() as i32) + 12 * (state.south as i32) + 36 * (state.north as i32) + 108 * (state.east as i32)
            }
            Blocks::DeepslateBricks => 19919,
            Blocks::DeepslateBrickStairs(state) => {
                19920 + (!state.waterlogged() as i32) + 2 * (state.shape as i32) + 10 * (state.half as i32) + 20 * (state.facing as i32)
            }
            Blocks::DeepslateBrickSlab(state) => {
                20000 + (!state.waterlogged() as i32) + 2 * (state.typed as i32)
            }
            Blocks::DeepslateBrickWall(state) => {
                20006 + (state.west as i32) + 3 * (!state.waterlogged() as i32) + 6 * (!state.up() as i32) + 12 * (state.south as i32) + 36 * (state.north as i32) + 108 * (state.east as i32)
            }
            Blocks::ChiseledDeepslate => 20330,
            Blocks::CrackedDeepslateBricks => 20331,
            Blocks::CrackedDeepslateTiles => 20332,
            Blocks::InfestedDeepslate(state) => {
                20333 + (state.axis as i32)
            }
            Blocks::SmoothBasalt => 20336,
            Blocks::RawIronBlock => 20337,
            Blocks::RawCopperBlock => 20338,
            Blocks::RawGoldBlock => 20339,
            Blocks::PottedAzaleaBush => 20340,
            Blocks::PottedFloweringAzaleaBush => 20341,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]pub enum ParseBlockError {
    UnknownBlock,
    UnknownProperty,
    InvalidProperty,
    InvalidToken,
}
impl ::std::error::Error for ParseBlockError {}
impl ::std::fmt::Display for ParseBlockError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "{:?}", self)
    }
}
impl From<std::str::ParseBoolError> for ParseBlockError {
    fn from(_: std::str::ParseBoolError) -> Self {
        ParseBlockError::InvalidProperty
    }
}
impl From<std::num::ParseIntError> for ParseBlockError {
    fn from(_: std::num::ParseIntError) -> Self {
        ParseBlockError::InvalidProperty
    }
}
impl FromStr for Blocks {
    type Err = ParseBlockError;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let (_domain, stripped) = if s.contains(':') { s.split_once(':').unwrap() } else { ("", s) };
        let (name, stripped) = if let Some(i) = stripped.rfind(']') {
            let _ = stripped.find('[').ok_or(ParseBlockError::InvalidToken)?;
            stripped.split_at(i).0.split_once('[').unwrap()
        } else {
            (stripped, "")
        };
        let props: AHashMap<&str, &str> = stripped.split(',')
            .map(|x| x.split_once('=')).filter(|x| x.is_some()).map(|x| x.unwrap()).collect();
        Ok(match name {
            "air" => Blocks::Air,
            "stone" => Blocks::Stone,
            "granite" => Blocks::Granite,
            "polished_granite" => Blocks::PolishedGranite,
            "diorite" => Blocks::Diorite,
            "polished_diorite" => Blocks::PolishedDiorite,
            "andesite" => Blocks::Andesite,
            "polished_andesite" => Blocks::PolishedAndesite,
            "grass_block" => {
                let mut block_state = GrassBlockState::default();
                if let Some(prop) = props.get("snowy") {
                    block_state.with_snowy(bool::from_str(prop)?);
                }
                Blocks::GrassBlock(block_state)
            }
            "dirt" => Blocks::Dirt,
            "coarse_dirt" => Blocks::CoarseDirt,
            "podzol" => {
                let mut block_state = PodzolState::default();
                if let Some(prop) = props.get("snowy") {
                    block_state.with_snowy(bool::from_str(prop)?);
                }
                Blocks::Podzol(block_state)
            }
            "cobblestone" => Blocks::Cobblestone,
            "oak_planks" => Blocks::OakPlanks,
            "spruce_planks" => Blocks::SprucePlanks,
            "birch_planks" => Blocks::BirchPlanks,
            "jungle_planks" => Blocks::JunglePlanks,
            "acacia_planks" => Blocks::AcaciaPlanks,
            "dark_oak_planks" => Blocks::DarkOakPlanks,
            "oak_sapling" => {
                let mut block_state = OakSaplingState::default();
                if let Some(prop) = props.get("stage") {
                    block_state.with_stage(i32::from_str(prop)?);
                }
                Blocks::OakSapling(block_state)
            }
            "spruce_sapling" => {
                let mut block_state = SpruceSaplingState::default();
                if let Some(prop) = props.get("stage") {
                    block_state.with_stage(i32::from_str(prop)?);
                }
                Blocks::SpruceSapling(block_state)
            }
            "birch_sapling" => {
                let mut block_state = BirchSaplingState::default();
                if let Some(prop) = props.get("stage") {
                    block_state.with_stage(i32::from_str(prop)?);
                }
                Blocks::BirchSapling(block_state)
            }
            "jungle_sapling" => {
                let mut block_state = JungleSaplingState::default();
                if let Some(prop) = props.get("stage") {
                    block_state.with_stage(i32::from_str(prop)?);
                }
                Blocks::JungleSapling(block_state)
            }
            "acacia_sapling" => {
                let mut block_state = AcaciaSaplingState::default();
                if let Some(prop) = props.get("stage") {
                    block_state.with_stage(i32::from_str(prop)?);
                }
                Blocks::AcaciaSapling(block_state)
            }
            "dark_oak_sapling" => {
                let mut block_state = DarkOakSaplingState::default();
                if let Some(prop) = props.get("stage") {
                    block_state.with_stage(i32::from_str(prop)?);
                }
                Blocks::DarkOakSapling(block_state)
            }
            "bedrock" => Blocks::Bedrock,
            "water" => {
                let mut block_state = WaterState::default();
                if let Some(prop) = props.get("level") {
                    block_state.with_level(i32::from_str(prop)?);
                }
                Blocks::Water(block_state)
            }
            "lava" => {
                let mut block_state = LavaState::default();
                if let Some(prop) = props.get("level") {
                    block_state.with_level(i32::from_str(prop)?);
                }
                Blocks::Lava(block_state)
            }
            "sand" => Blocks::Sand,
            "red_sand" => Blocks::RedSand,
            "gravel" => Blocks::Gravel,
            "gold_ore" => Blocks::GoldOre,
            "deepslate_gold_ore" => Blocks::DeepslateGoldOre,
            "iron_ore" => Blocks::IronOre,
            "deepslate_iron_ore" => Blocks::DeepslateIronOre,
            "coal_ore" => Blocks::CoalOre,
            "deepslate_coal_ore" => Blocks::DeepslateCoalOre,
            "nether_gold_ore" => Blocks::NetherGoldOre,
            "oak_log" => {
                let mut block_state = OakLogState::default();
                if let Some(prop) = props.get("axis") {
                    block_state.with_axis(Axis::from_str(prop)?);
                }
                Blocks::OakLog(block_state)
            }
            "spruce_log" => {
                let mut block_state = SpruceLogState::default();
                if let Some(prop) = props.get("axis") {
                    block_state.with_axis(Axis::from_str(prop)?);
                }
                Blocks::SpruceLog(block_state)
            }
            "birch_log" => {
                let mut block_state = BirchLogState::default();
                if let Some(prop) = props.get("axis") {
                    block_state.with_axis(Axis::from_str(prop)?);
                }
                Blocks::BirchLog(block_state)
            }
            "jungle_log" => {
                let mut block_state = JungleLogState::default();
                if let Some(prop) = props.get("axis") {
                    block_state.with_axis(Axis::from_str(prop)?);
                }
                Blocks::JungleLog(block_state)
            }
            "acacia_log" => {
                let mut block_state = AcaciaLogState::default();
                if let Some(prop) = props.get("axis") {
                    block_state.with_axis(Axis::from_str(prop)?);
                }
                Blocks::AcaciaLog(block_state)
            }
            "dark_oak_log" => {
                let mut block_state = DarkOakLogState::default();
                if let Some(prop) = props.get("axis") {
                    block_state.with_axis(Axis::from_str(prop)?);
                }
                Blocks::DarkOakLog(block_state)
            }
            "stripped_spruce_log" => {
                let mut block_state = StrippedSpruceLogState::default();
                if let Some(prop) = props.get("axis") {
                    block_state.with_axis(Axis::from_str(prop)?);
                }
                Blocks::StrippedSpruceLog(block_state)
            }
            "stripped_birch_log" => {
                let mut block_state = StrippedBirchLogState::default();
                if let Some(prop) = props.get("axis") {
                    block_state.with_axis(Axis::from_str(prop)?);
                }
                Blocks::StrippedBirchLog(block_state)
            }
            "stripped_jungle_log" => {
                let mut block_state = StrippedJungleLogState::default();
                if let Some(prop) = props.get("axis") {
                    block_state.with_axis(Axis::from_str(prop)?);
                }
                Blocks::StrippedJungleLog(block_state)
            }
            "stripped_acacia_log" => {
                let mut block_state = StrippedAcaciaLogState::default();
                if let Some(prop) = props.get("axis") {
                    block_state.with_axis(Axis::from_str(prop)?);
                }
                Blocks::StrippedAcaciaLog(block_state)
            }
            "stripped_dark_oak_log" => {
                let mut block_state = StrippedDarkOakLogState::default();
                if let Some(prop) = props.get("axis") {
                    block_state.with_axis(Axis::from_str(prop)?);
                }
                Blocks::StrippedDarkOakLog(block_state)
            }
            "stripped_oak_log" => {
                let mut block_state = StrippedOakLogState::default();
                if let Some(prop) = props.get("axis") {
                    block_state.with_axis(Axis::from_str(prop)?);
                }
                Blocks::StrippedOakLog(block_state)
            }
            "oak_wood" => {
                let mut block_state = OakWoodState::default();
                if let Some(prop) = props.get("axis") {
                    block_state.with_axis(Axis::from_str(prop)?);
                }
                Blocks::OakWood(block_state)
            }
            "spruce_wood" => {
                let mut block_state = SpruceWoodState::default();
                if let Some(prop) = props.get("axis") {
                    block_state.with_axis(Axis::from_str(prop)?);
                }
                Blocks::SpruceWood(block_state)
            }
            "birch_wood" => {
                let mut block_state = BirchWoodState::default();
                if let Some(prop) = props.get("axis") {
                    block_state.with_axis(Axis::from_str(prop)?);
                }
                Blocks::BirchWood(block_state)
            }
            "jungle_wood" => {
                let mut block_state = JungleWoodState::default();
                if let Some(prop) = props.get("axis") {
                    block_state.with_axis(Axis::from_str(prop)?);
                }
                Blocks::JungleWood(block_state)
            }
            "acacia_wood" => {
                let mut block_state = AcaciaWoodState::default();
                if let Some(prop) = props.get("axis") {
                    block_state.with_axis(Axis::from_str(prop)?);
                }
                Blocks::AcaciaWood(block_state)
            }
            "dark_oak_wood" => {
                let mut block_state = DarkOakWoodState::default();
                if let Some(prop) = props.get("axis") {
                    block_state.with_axis(Axis::from_str(prop)?);
                }
                Blocks::DarkOakWood(block_state)
            }
            "stripped_oak_wood" => {
                let mut block_state = StrippedOakWoodState::default();
                if let Some(prop) = props.get("axis") {
                    block_state.with_axis(Axis::from_str(prop)?);
                }
                Blocks::StrippedOakWood(block_state)
            }
            "stripped_spruce_wood" => {
                let mut block_state = StrippedSpruceWoodState::default();
                if let Some(prop) = props.get("axis") {
                    block_state.with_axis(Axis::from_str(prop)?);
                }
                Blocks::StrippedSpruceWood(block_state)
            }
            "stripped_birch_wood" => {
                let mut block_state = StrippedBirchWoodState::default();
                if let Some(prop) = props.get("axis") {
                    block_state.with_axis(Axis::from_str(prop)?);
                }
                Blocks::StrippedBirchWood(block_state)
            }
            "stripped_jungle_wood" => {
                let mut block_state = StrippedJungleWoodState::default();
                if let Some(prop) = props.get("axis") {
                    block_state.with_axis(Axis::from_str(prop)?);
                }
                Blocks::StrippedJungleWood(block_state)
            }
            "stripped_acacia_wood" => {
                let mut block_state = StrippedAcaciaWoodState::default();
                if let Some(prop) = props.get("axis") {
                    block_state.with_axis(Axis::from_str(prop)?);
                }
                Blocks::StrippedAcaciaWood(block_state)
            }
            "stripped_dark_oak_wood" => {
                let mut block_state = StrippedDarkOakWoodState::default();
                if let Some(prop) = props.get("axis") {
                    block_state.with_axis(Axis::from_str(prop)?);
                }
                Blocks::StrippedDarkOakWood(block_state)
            }
            "oak_leaves" => {
                let mut block_state = OakLeavesState::default();
                if let Some(prop) = props.get("distance") {
                    block_state.with_distance(i32::from_str(prop)?);
                }
                if let Some(prop) = props.get("persistent") {
                    block_state.with_persistent(bool::from_str(prop)?);
                }
                Blocks::OakLeaves(block_state)
            }
            "spruce_leaves" => {
                let mut block_state = SpruceLeavesState::default();
                if let Some(prop) = props.get("distance") {
                    block_state.with_distance(i32::from_str(prop)?);
                }
                if let Some(prop) = props.get("persistent") {
                    block_state.with_persistent(bool::from_str(prop)?);
                }
                Blocks::SpruceLeaves(block_state)
            }
            "birch_leaves" => {
                let mut block_state = BirchLeavesState::default();
                if let Some(prop) = props.get("distance") {
                    block_state.with_distance(i32::from_str(prop)?);
                }
                if let Some(prop) = props.get("persistent") {
                    block_state.with_persistent(bool::from_str(prop)?);
                }
                Blocks::BirchLeaves(block_state)
            }
            "jungle_leaves" => {
                let mut block_state = JungleLeavesState::default();
                if let Some(prop) = props.get("distance") {
                    block_state.with_distance(i32::from_str(prop)?);
                }
                if let Some(prop) = props.get("persistent") {
                    block_state.with_persistent(bool::from_str(prop)?);
                }
                Blocks::JungleLeaves(block_state)
            }
            "acacia_leaves" => {
                let mut block_state = AcaciaLeavesState::default();
                if let Some(prop) = props.get("distance") {
                    block_state.with_distance(i32::from_str(prop)?);
                }
                if let Some(prop) = props.get("persistent") {
                    block_state.with_persistent(bool::from_str(prop)?);
                }
                Blocks::AcaciaLeaves(block_state)
            }
            "dark_oak_leaves" => {
                let mut block_state = DarkOakLeavesState::default();
                if let Some(prop) = props.get("distance") {
                    block_state.with_distance(i32::from_str(prop)?);
                }
                if let Some(prop) = props.get("persistent") {
                    block_state.with_persistent(bool::from_str(prop)?);
                }
                Blocks::DarkOakLeaves(block_state)
            }
            "azalea_leaves" => {
                let mut block_state = AzaleaLeavesState::default();
                if let Some(prop) = props.get("distance") {
                    block_state.with_distance(i32::from_str(prop)?);
                }
                if let Some(prop) = props.get("persistent") {
                    block_state.with_persistent(bool::from_str(prop)?);
                }
                Blocks::AzaleaLeaves(block_state)
            }
            "flowering_azalea_leaves" => {
                let mut block_state = FloweringAzaleaLeavesState::default();
                if let Some(prop) = props.get("distance") {
                    block_state.with_distance(i32::from_str(prop)?);
                }
                if let Some(prop) = props.get("persistent") {
                    block_state.with_persistent(bool::from_str(prop)?);
                }
                Blocks::FloweringAzaleaLeaves(block_state)
            }
            "sponge" => Blocks::Sponge,
            "wet_sponge" => Blocks::WetSponge,
            "glass" => Blocks::Glass,
            "lapis_ore" => Blocks::LapisOre,
            "deepslate_lapis_ore" => Blocks::DeepslateLapisOre,
            "lapis_block" => Blocks::LapisBlock,
            "dispenser" => {
                let mut block_state = DispenserState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(AllFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("triggered") {
                    block_state.with_triggered(bool::from_str(prop)?);
                }
                Blocks::Dispenser(block_state)
            }
            "sandstone" => Blocks::Sandstone,
            "chiseled_sandstone" => Blocks::ChiseledSandstone,
            "cut_sandstone" => Blocks::CutSandstone,
            "note_block" => {
                let mut block_state = NoteBlockState::default();
                if let Some(prop) = props.get("instrument") {
                    block_state.with_instrument(Instrument::from_str(prop)?);
                }
                if let Some(prop) = props.get("note") {
                    block_state.with_note(i32::from_str(prop)?);
                }
                if let Some(prop) = props.get("powered") {
                    block_state.with_powered(bool::from_str(prop)?);
                }
                Blocks::NoteBlock(block_state)
            }
            "white_bed" => {
                let mut block_state = WhiteBedState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("occupied") {
                    block_state.with_occupied(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("part") {
                    block_state.with_part(Part::from_str(prop)?);
                }
                Blocks::WhiteBed(block_state)
            }
            "orange_bed" => {
                let mut block_state = OrangeBedState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("occupied") {
                    block_state.with_occupied(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("part") {
                    block_state.with_part(Part::from_str(prop)?);
                }
                Blocks::OrangeBed(block_state)
            }
            "magenta_bed" => {
                let mut block_state = MagentaBedState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("occupied") {
                    block_state.with_occupied(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("part") {
                    block_state.with_part(Part::from_str(prop)?);
                }
                Blocks::MagentaBed(block_state)
            }
            "light_blue_bed" => {
                let mut block_state = LightBlueBedState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("occupied") {
                    block_state.with_occupied(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("part") {
                    block_state.with_part(Part::from_str(prop)?);
                }
                Blocks::LightBlueBed(block_state)
            }
            "yellow_bed" => {
                let mut block_state = YellowBedState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("occupied") {
                    block_state.with_occupied(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("part") {
                    block_state.with_part(Part::from_str(prop)?);
                }
                Blocks::YellowBed(block_state)
            }
            "lime_bed" => {
                let mut block_state = LimeBedState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("occupied") {
                    block_state.with_occupied(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("part") {
                    block_state.with_part(Part::from_str(prop)?);
                }
                Blocks::LimeBed(block_state)
            }
            "pink_bed" => {
                let mut block_state = PinkBedState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("occupied") {
                    block_state.with_occupied(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("part") {
                    block_state.with_part(Part::from_str(prop)?);
                }
                Blocks::PinkBed(block_state)
            }
            "gray_bed" => {
                let mut block_state = GrayBedState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("occupied") {
                    block_state.with_occupied(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("part") {
                    block_state.with_part(Part::from_str(prop)?);
                }
                Blocks::GrayBed(block_state)
            }
            "light_gray_bed" => {
                let mut block_state = LightGrayBedState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("occupied") {
                    block_state.with_occupied(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("part") {
                    block_state.with_part(Part::from_str(prop)?);
                }
                Blocks::LightGrayBed(block_state)
            }
            "cyan_bed" => {
                let mut block_state = CyanBedState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("occupied") {
                    block_state.with_occupied(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("part") {
                    block_state.with_part(Part::from_str(prop)?);
                }
                Blocks::CyanBed(block_state)
            }
            "purple_bed" => {
                let mut block_state = PurpleBedState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("occupied") {
                    block_state.with_occupied(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("part") {
                    block_state.with_part(Part::from_str(prop)?);
                }
                Blocks::PurpleBed(block_state)
            }
            "blue_bed" => {
                let mut block_state = BlueBedState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("occupied") {
                    block_state.with_occupied(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("part") {
                    block_state.with_part(Part::from_str(prop)?);
                }
                Blocks::BlueBed(block_state)
            }
            "brown_bed" => {
                let mut block_state = BrownBedState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("occupied") {
                    block_state.with_occupied(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("part") {
                    block_state.with_part(Part::from_str(prop)?);
                }
                Blocks::BrownBed(block_state)
            }
            "green_bed" => {
                let mut block_state = GreenBedState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("occupied") {
                    block_state.with_occupied(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("part") {
                    block_state.with_part(Part::from_str(prop)?);
                }
                Blocks::GreenBed(block_state)
            }
            "red_bed" => {
                let mut block_state = RedBedState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("occupied") {
                    block_state.with_occupied(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("part") {
                    block_state.with_part(Part::from_str(prop)?);
                }
                Blocks::RedBed(block_state)
            }
            "black_bed" => {
                let mut block_state = BlackBedState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("occupied") {
                    block_state.with_occupied(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("part") {
                    block_state.with_part(Part::from_str(prop)?);
                }
                Blocks::BlackBed(block_state)
            }
            "powered_rail" => {
                let mut block_state = PoweredRailState::default();
                if let Some(prop) = props.get("powered") {
                    block_state.with_powered(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("shape") {
                    block_state.with_shape(StraightRailShape::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::PoweredRail(block_state)
            }
            "detector_rail" => {
                let mut block_state = DetectorRailState::default();
                if let Some(prop) = props.get("powered") {
                    block_state.with_powered(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("shape") {
                    block_state.with_shape(StraightRailShape::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::DetectorRail(block_state)
            }
            "sticky_piston" => {
                let mut block_state = StickyPistonState::default();
                if let Some(prop) = props.get("extended") {
                    block_state.with_extended(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(AllFacing::from_str(prop)?);
                }
                Blocks::StickyPiston(block_state)
            }
            "cobweb" => Blocks::Cobweb,
            "grass" => Blocks::Grass,
            "fern" => Blocks::Fern,
            "dead_bush" => Blocks::DeadBush,
            "seagrass" => Blocks::Seagrass,
            "tall_seagrass" => {
                let mut block_state = TallSeagrassState::default();
                if let Some(prop) = props.get("half") {
                    block_state.with_half(DoubleBlockHalf::from_str(prop)?);
                }
                Blocks::TallSeagrass(block_state)
            }
            "piston" => {
                let mut block_state = PistonState::default();
                if let Some(prop) = props.get("extended") {
                    block_state.with_extended(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(AllFacing::from_str(prop)?);
                }
                Blocks::Piston(block_state)
            }
            "piston_head" => {
                let mut block_state = PistonHeadState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(AllFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("short") {
                    block_state.with_short(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("typed") {
                    block_state.with_typed(PistonType::from_str(prop)?);
                }
                Blocks::PistonHead(block_state)
            }
            "white_wool" => Blocks::WhiteWool,
            "orange_wool" => Blocks::OrangeWool,
            "magenta_wool" => Blocks::MagentaWool,
            "light_blue_wool" => Blocks::LightBlueWool,
            "yellow_wool" => Blocks::YellowWool,
            "lime_wool" => Blocks::LimeWool,
            "pink_wool" => Blocks::PinkWool,
            "gray_wool" => Blocks::GrayWool,
            "light_gray_wool" => Blocks::LightGrayWool,
            "cyan_wool" => Blocks::CyanWool,
            "purple_wool" => Blocks::PurpleWool,
            "blue_wool" => Blocks::BlueWool,
            "brown_wool" => Blocks::BrownWool,
            "green_wool" => Blocks::GreenWool,
            "red_wool" => Blocks::RedWool,
            "black_wool" => Blocks::BlackWool,
            "moving_piston" => {
                let mut block_state = MovingPistonState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(AllFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("typed") {
                    block_state.with_typed(PistonType::from_str(prop)?);
                }
                Blocks::MovingPiston(block_state)
            }
            "dandelion" => Blocks::Dandelion,
            "poppy" => Blocks::Poppy,
            "blue_orchid" => Blocks::BlueOrchid,
            "allium" => Blocks::Allium,
            "azure_bluet" => Blocks::AzureBluet,
            "red_tulip" => Blocks::RedTulip,
            "orange_tulip" => Blocks::OrangeTulip,
            "white_tulip" => Blocks::WhiteTulip,
            "pink_tulip" => Blocks::PinkTulip,
            "oxeye_daisy" => Blocks::OxeyeDaisy,
            "cornflower" => Blocks::Cornflower,
            "wither_rose" => Blocks::WitherRose,
            "lily_of_the_valley" => Blocks::LilyOfTheValley,
            "brown_mushroom" => Blocks::BrownMushroom,
            "red_mushroom" => Blocks::RedMushroom,
            "gold_block" => Blocks::GoldBlock,
            "iron_block" => Blocks::IronBlock,
            "bricks" => Blocks::Bricks,
            "tnt" => {
                let mut block_state = TntState::default();
                if let Some(prop) = props.get("unstable") {
                    block_state.with_unstable(bool::from_str(prop)?);
                }
                Blocks::Tnt(block_state)
            }
            "bookshelf" => Blocks::Bookshelf,
            "mossy_cobblestone" => Blocks::MossyCobblestone,
            "obsidian" => Blocks::Obsidian,
            "torch" => Blocks::Torch,
            "wall_torch" => {
                let mut block_state = WallTorchState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                Blocks::WallTorch(block_state)
            }
            "fire" => {
                let mut block_state = FireState::default();
                if let Some(prop) = props.get("age") {
                    block_state.with_age(i32::from_str(prop)?);
                }
                if let Some(prop) = props.get("east") {
                    block_state.with_east(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("north") {
                    block_state.with_north(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("south") {
                    block_state.with_south(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("up") {
                    block_state.with_up(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("west") {
                    block_state.with_west(bool::from_str(prop)?);
                }
                Blocks::Fire(block_state)
            }
            "soul_fire" => Blocks::SoulFire,
            "spawner" => Blocks::Spawner,
            "oak_stairs" => {
                let mut block_state = OakStairsState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("half") {
                    block_state.with_half(SingleBlockHalf::from_str(prop)?);
                }
                if let Some(prop) = props.get("shape") {
                    block_state.with_shape(StairShape::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::OakStairs(block_state)
            }
            "chest" => {
                let mut block_state = ChestState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("typed") {
                    block_state.with_typed(ChestType::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::Chest(block_state)
            }
            "redstone_wire" => {
                let mut block_state = RedstoneWireState::default();
                if let Some(prop) = props.get("east") {
                    block_state.with_east(RedstoneType::from_str(prop)?);
                }
                if let Some(prop) = props.get("north") {
                    block_state.with_north(RedstoneType::from_str(prop)?);
                }
                if let Some(prop) = props.get("power") {
                    block_state.with_power(i32::from_str(prop)?);
                }
                if let Some(prop) = props.get("south") {
                    block_state.with_south(RedstoneType::from_str(prop)?);
                }
                if let Some(prop) = props.get("west") {
                    block_state.with_west(RedstoneType::from_str(prop)?);
                }
                Blocks::RedstoneWire(block_state)
            }
            "diamond_ore" => Blocks::DiamondOre,
            "deepslate_diamond_ore" => Blocks::DeepslateDiamondOre,
            "diamond_block" => Blocks::DiamondBlock,
            "crafting_table" => Blocks::CraftingTable,
            "wheat" => {
                let mut block_state = WheatState::default();
                if let Some(prop) = props.get("age") {
                    block_state.with_age(i32::from_str(prop)?);
                }
                Blocks::Wheat(block_state)
            }
            "farmland" => {
                let mut block_state = FarmlandState::default();
                if let Some(prop) = props.get("moisture") {
                    block_state.with_moisture(i32::from_str(prop)?);
                }
                Blocks::Farmland(block_state)
            }
            "furnace" => {
                let mut block_state = FurnaceState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("lit") {
                    block_state.with_lit(bool::from_str(prop)?);
                }
                Blocks::Furnace(block_state)
            }
            "oak_sign" => {
                let mut block_state = OakSignState::default();
                if let Some(prop) = props.get("rotation") {
                    block_state.with_rotation(i32::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::OakSign(block_state)
            }
            "spruce_sign" => {
                let mut block_state = SpruceSignState::default();
                if let Some(prop) = props.get("rotation") {
                    block_state.with_rotation(i32::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::SpruceSign(block_state)
            }
            "birch_sign" => {
                let mut block_state = BirchSignState::default();
                if let Some(prop) = props.get("rotation") {
                    block_state.with_rotation(i32::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::BirchSign(block_state)
            }
            "acacia_sign" => {
                let mut block_state = AcaciaSignState::default();
                if let Some(prop) = props.get("rotation") {
                    block_state.with_rotation(i32::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::AcaciaSign(block_state)
            }
            "jungle_sign" => {
                let mut block_state = JungleSignState::default();
                if let Some(prop) = props.get("rotation") {
                    block_state.with_rotation(i32::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::JungleSign(block_state)
            }
            "dark_oak_sign" => {
                let mut block_state = DarkOakSignState::default();
                if let Some(prop) = props.get("rotation") {
                    block_state.with_rotation(i32::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::DarkOakSign(block_state)
            }
            "oak_door" => {
                let mut block_state = OakDoorState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("half") {
                    block_state.with_half(DoubleBlockHalf::from_str(prop)?);
                }
                if let Some(prop) = props.get("hinge") {
                    block_state.with_hinge(Hinge::from_str(prop)?);
                }
                if let Some(prop) = props.get("open") {
                    block_state.with_open(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("powered") {
                    block_state.with_powered(bool::from_str(prop)?);
                }
                Blocks::OakDoor(block_state)
            }
            "ladder" => {
                let mut block_state = LadderState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::Ladder(block_state)
            }
            "rail" => {
                let mut block_state = RailState::default();
                if let Some(prop) = props.get("shape") {
                    block_state.with_shape(RailShape::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::Rail(block_state)
            }
            "cobblestone_stairs" => {
                let mut block_state = CobblestoneStairsState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("half") {
                    block_state.with_half(SingleBlockHalf::from_str(prop)?);
                }
                if let Some(prop) = props.get("shape") {
                    block_state.with_shape(StairShape::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::CobblestoneStairs(block_state)
            }
            "oak_wall_sign" => {
                let mut block_state = OakWallSignState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::OakWallSign(block_state)
            }
            "spruce_wall_sign" => {
                let mut block_state = SpruceWallSignState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::SpruceWallSign(block_state)
            }
            "birch_wall_sign" => {
                let mut block_state = BirchWallSignState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::BirchWallSign(block_state)
            }
            "acacia_wall_sign" => {
                let mut block_state = AcaciaWallSignState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::AcaciaWallSign(block_state)
            }
            "jungle_wall_sign" => {
                let mut block_state = JungleWallSignState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::JungleWallSign(block_state)
            }
            "dark_oak_wall_sign" => {
                let mut block_state = DarkOakWallSignState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::DarkOakWallSign(block_state)
            }
            "lever" => {
                let mut block_state = LeverState::default();
                if let Some(prop) = props.get("face") {
                    block_state.with_face(Face::from_str(prop)?);
                }
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("powered") {
                    block_state.with_powered(bool::from_str(prop)?);
                }
                Blocks::Lever(block_state)
            }
            "stone_pressure_plate" => {
                let mut block_state = StonePressurePlateState::default();
                if let Some(prop) = props.get("powered") {
                    block_state.with_powered(bool::from_str(prop)?);
                }
                Blocks::StonePressurePlate(block_state)
            }
            "iron_door" => {
                let mut block_state = IronDoorState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("half") {
                    block_state.with_half(DoubleBlockHalf::from_str(prop)?);
                }
                if let Some(prop) = props.get("hinge") {
                    block_state.with_hinge(Hinge::from_str(prop)?);
                }
                if let Some(prop) = props.get("open") {
                    block_state.with_open(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("powered") {
                    block_state.with_powered(bool::from_str(prop)?);
                }
                Blocks::IronDoor(block_state)
            }
            "oak_pressure_plate" => {
                let mut block_state = OakPressurePlateState::default();
                if let Some(prop) = props.get("powered") {
                    block_state.with_powered(bool::from_str(prop)?);
                }
                Blocks::OakPressurePlate(block_state)
            }
            "spruce_pressure_plate" => {
                let mut block_state = SprucePressurePlateState::default();
                if let Some(prop) = props.get("powered") {
                    block_state.with_powered(bool::from_str(prop)?);
                }
                Blocks::SprucePressurePlate(block_state)
            }
            "birch_pressure_plate" => {
                let mut block_state = BirchPressurePlateState::default();
                if let Some(prop) = props.get("powered") {
                    block_state.with_powered(bool::from_str(prop)?);
                }
                Blocks::BirchPressurePlate(block_state)
            }
            "jungle_pressure_plate" => {
                let mut block_state = JunglePressurePlateState::default();
                if let Some(prop) = props.get("powered") {
                    block_state.with_powered(bool::from_str(prop)?);
                }
                Blocks::JunglePressurePlate(block_state)
            }
            "acacia_pressure_plate" => {
                let mut block_state = AcaciaPressurePlateState::default();
                if let Some(prop) = props.get("powered") {
                    block_state.with_powered(bool::from_str(prop)?);
                }
                Blocks::AcaciaPressurePlate(block_state)
            }
            "dark_oak_pressure_plate" => {
                let mut block_state = DarkOakPressurePlateState::default();
                if let Some(prop) = props.get("powered") {
                    block_state.with_powered(bool::from_str(prop)?);
                }
                Blocks::DarkOakPressurePlate(block_state)
            }
            "redstone_ore" => {
                let mut block_state = RedstoneOreState::default();
                if let Some(prop) = props.get("lit") {
                    block_state.with_lit(bool::from_str(prop)?);
                }
                Blocks::RedstoneOre(block_state)
            }
            "deepslate_redstone_ore" => {
                let mut block_state = DeepslateRedstoneOreState::default();
                if let Some(prop) = props.get("lit") {
                    block_state.with_lit(bool::from_str(prop)?);
                }
                Blocks::DeepslateRedstoneOre(block_state)
            }
            "redstone_torch" => {
                let mut block_state = RedstoneTorchState::default();
                if let Some(prop) = props.get("lit") {
                    block_state.with_lit(bool::from_str(prop)?);
                }
                Blocks::RedstoneTorch(block_state)
            }
            "redstone_wall_torch" => {
                let mut block_state = RedstoneWallTorchState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("lit") {
                    block_state.with_lit(bool::from_str(prop)?);
                }
                Blocks::RedstoneWallTorch(block_state)
            }
            "stone_button" => {
                let mut block_state = StoneButtonState::default();
                if let Some(prop) = props.get("face") {
                    block_state.with_face(Face::from_str(prop)?);
                }
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("powered") {
                    block_state.with_powered(bool::from_str(prop)?);
                }
                Blocks::StoneButton(block_state)
            }
            "snow" => {
                let mut block_state = SnowState::default();
                if let Some(prop) = props.get("layers") {
                    block_state.with_layers(i32::from_str(prop)?);
                }
                Blocks::Snow(block_state)
            }
            "ice" => Blocks::Ice,
            "snow_block" => Blocks::SnowBlock,
            "cactus" => {
                let mut block_state = CactusState::default();
                if let Some(prop) = props.get("age") {
                    block_state.with_age(i32::from_str(prop)?);
                }
                Blocks::Cactus(block_state)
            }
            "clay" => Blocks::Clay,
            "sugar_cane" => {
                let mut block_state = SugarCaneState::default();
                if let Some(prop) = props.get("age") {
                    block_state.with_age(i32::from_str(prop)?);
                }
                Blocks::SugarCane(block_state)
            }
            "jukebox" => {
                let mut block_state = JukeboxState::default();
                if let Some(prop) = props.get("has_record") {
                    block_state.with_has_record(bool::from_str(prop)?);
                }
                Blocks::Jukebox(block_state)
            }
            "oak_fence" => {
                let mut block_state = OakFenceState::default();
                if let Some(prop) = props.get("east") {
                    block_state.with_east(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("north") {
                    block_state.with_north(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("south") {
                    block_state.with_south(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("west") {
                    block_state.with_west(bool::from_str(prop)?);
                }
                Blocks::OakFence(block_state)
            }
            "pumpkin" => Blocks::Pumpkin,
            "netherrack" => Blocks::Netherrack,
            "soul_sand" => Blocks::SoulSand,
            "soul_soil" => Blocks::SoulSoil,
            "basalt" => {
                let mut block_state = BasaltState::default();
                if let Some(prop) = props.get("axis") {
                    block_state.with_axis(Axis::from_str(prop)?);
                }
                Blocks::Basalt(block_state)
            }
            "polished_basalt" => {
                let mut block_state = PolishedBasaltState::default();
                if let Some(prop) = props.get("axis") {
                    block_state.with_axis(Axis::from_str(prop)?);
                }
                Blocks::PolishedBasalt(block_state)
            }
            "soul_torch" => Blocks::SoulTorch,
            "soul_wall_torch" => {
                let mut block_state = SoulWallTorchState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                Blocks::SoulWallTorch(block_state)
            }
            "glowstone" => Blocks::Glowstone,
            "nether_portal" => {
                let mut block_state = NetherPortalState::default();
                if let Some(prop) = props.get("axis") {
                    block_state.with_axis(PortalAxis::from_str(prop)?);
                }
                Blocks::NetherPortal(block_state)
            }
            "carved_pumpkin" => {
                let mut block_state = CarvedPumpkinState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                Blocks::CarvedPumpkin(block_state)
            }
            "jack_o_lantern" => {
                let mut block_state = JackOLanternState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                Blocks::JackOLantern(block_state)
            }
            "cake" => {
                let mut block_state = CakeState::default();
                if let Some(prop) = props.get("bites") {
                    block_state.with_bites(i32::from_str(prop)?);
                }
                Blocks::Cake(block_state)
            }
            "repeater" => {
                let mut block_state = RepeaterState::default();
                if let Some(prop) = props.get("delay") {
                    block_state.with_delay(i32::from_str(prop)?);
                }
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("locked") {
                    block_state.with_locked(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("powered") {
                    block_state.with_powered(bool::from_str(prop)?);
                }
                Blocks::Repeater(block_state)
            }
            "white_stained_glass" => Blocks::WhiteStainedGlass,
            "orange_stained_glass" => Blocks::OrangeStainedGlass,
            "magenta_stained_glass" => Blocks::MagentaStainedGlass,
            "light_blue_stained_glass" => Blocks::LightBlueStainedGlass,
            "yellow_stained_glass" => Blocks::YellowStainedGlass,
            "lime_stained_glass" => Blocks::LimeStainedGlass,
            "pink_stained_glass" => Blocks::PinkStainedGlass,
            "gray_stained_glass" => Blocks::GrayStainedGlass,
            "light_gray_stained_glass" => Blocks::LightGrayStainedGlass,
            "cyan_stained_glass" => Blocks::CyanStainedGlass,
            "purple_stained_glass" => Blocks::PurpleStainedGlass,
            "blue_stained_glass" => Blocks::BlueStainedGlass,
            "brown_stained_glass" => Blocks::BrownStainedGlass,
            "green_stained_glass" => Blocks::GreenStainedGlass,
            "red_stained_glass" => Blocks::RedStainedGlass,
            "black_stained_glass" => Blocks::BlackStainedGlass,
            "oak_trapdoor" => {
                let mut block_state = OakTrapdoorState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("half") {
                    block_state.with_half(SingleBlockHalf::from_str(prop)?);
                }
                if let Some(prop) = props.get("open") {
                    block_state.with_open(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("powered") {
                    block_state.with_powered(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::OakTrapdoor(block_state)
            }
            "spruce_trapdoor" => {
                let mut block_state = SpruceTrapdoorState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("half") {
                    block_state.with_half(SingleBlockHalf::from_str(prop)?);
                }
                if let Some(prop) = props.get("open") {
                    block_state.with_open(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("powered") {
                    block_state.with_powered(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::SpruceTrapdoor(block_state)
            }
            "birch_trapdoor" => {
                let mut block_state = BirchTrapdoorState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("half") {
                    block_state.with_half(SingleBlockHalf::from_str(prop)?);
                }
                if let Some(prop) = props.get("open") {
                    block_state.with_open(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("powered") {
                    block_state.with_powered(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::BirchTrapdoor(block_state)
            }
            "jungle_trapdoor" => {
                let mut block_state = JungleTrapdoorState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("half") {
                    block_state.with_half(SingleBlockHalf::from_str(prop)?);
                }
                if let Some(prop) = props.get("open") {
                    block_state.with_open(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("powered") {
                    block_state.with_powered(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::JungleTrapdoor(block_state)
            }
            "acacia_trapdoor" => {
                let mut block_state = AcaciaTrapdoorState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("half") {
                    block_state.with_half(SingleBlockHalf::from_str(prop)?);
                }
                if let Some(prop) = props.get("open") {
                    block_state.with_open(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("powered") {
                    block_state.with_powered(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::AcaciaTrapdoor(block_state)
            }
            "dark_oak_trapdoor" => {
                let mut block_state = DarkOakTrapdoorState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("half") {
                    block_state.with_half(SingleBlockHalf::from_str(prop)?);
                }
                if let Some(prop) = props.get("open") {
                    block_state.with_open(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("powered") {
                    block_state.with_powered(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::DarkOakTrapdoor(block_state)
            }
            "stone_bricks" => Blocks::StoneBricks,
            "mossy_stone_bricks" => Blocks::MossyStoneBricks,
            "cracked_stone_bricks" => Blocks::CrackedStoneBricks,
            "chiseled_stone_bricks" => Blocks::ChiseledStoneBricks,
            "infested_stone" => Blocks::InfestedStone,
            "infested_cobblestone" => Blocks::InfestedCobblestone,
            "infested_stone_bricks" => Blocks::InfestedStoneBricks,
            "infested_mossy_stone_bricks" => Blocks::InfestedMossyStoneBricks,
            "infested_cracked_stone_bricks" => Blocks::InfestedCrackedStoneBricks,
            "infested_chiseled_stone_bricks" => Blocks::InfestedChiseledStoneBricks,
            "brown_mushroom_block" => {
                let mut block_state = BrownMushroomBlockState::default();
                if let Some(prop) = props.get("down") {
                    block_state.with_down(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("east") {
                    block_state.with_east(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("north") {
                    block_state.with_north(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("south") {
                    block_state.with_south(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("up") {
                    block_state.with_up(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("west") {
                    block_state.with_west(bool::from_str(prop)?);
                }
                Blocks::BrownMushroomBlock(block_state)
            }
            "red_mushroom_block" => {
                let mut block_state = RedMushroomBlockState::default();
                if let Some(prop) = props.get("down") {
                    block_state.with_down(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("east") {
                    block_state.with_east(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("north") {
                    block_state.with_north(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("south") {
                    block_state.with_south(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("up") {
                    block_state.with_up(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("west") {
                    block_state.with_west(bool::from_str(prop)?);
                }
                Blocks::RedMushroomBlock(block_state)
            }
            "mushroom_stem" => {
                let mut block_state = MushroomStemState::default();
                if let Some(prop) = props.get("down") {
                    block_state.with_down(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("east") {
                    block_state.with_east(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("north") {
                    block_state.with_north(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("south") {
                    block_state.with_south(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("up") {
                    block_state.with_up(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("west") {
                    block_state.with_west(bool::from_str(prop)?);
                }
                Blocks::MushroomStem(block_state)
            }
            "iron_bars" => {
                let mut block_state = IronBarsState::default();
                if let Some(prop) = props.get("east") {
                    block_state.with_east(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("north") {
                    block_state.with_north(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("south") {
                    block_state.with_south(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("west") {
                    block_state.with_west(bool::from_str(prop)?);
                }
                Blocks::IronBars(block_state)
            }
            "chain" => {
                let mut block_state = ChainState::default();
                if let Some(prop) = props.get("axis") {
                    block_state.with_axis(Axis::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::Chain(block_state)
            }
            "glass_pane" => {
                let mut block_state = GlassPaneState::default();
                if let Some(prop) = props.get("east") {
                    block_state.with_east(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("north") {
                    block_state.with_north(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("south") {
                    block_state.with_south(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("west") {
                    block_state.with_west(bool::from_str(prop)?);
                }
                Blocks::GlassPane(block_state)
            }
            "melon" => Blocks::Melon,
            "attached_pumpkin_stem" => {
                let mut block_state = AttachedPumpkinStemState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                Blocks::AttachedPumpkinStem(block_state)
            }
            "attached_melon_stem" => {
                let mut block_state = AttachedMelonStemState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                Blocks::AttachedMelonStem(block_state)
            }
            "pumpkin_stem" => {
                let mut block_state = PumpkinStemState::default();
                if let Some(prop) = props.get("age") {
                    block_state.with_age(i32::from_str(prop)?);
                }
                Blocks::PumpkinStem(block_state)
            }
            "melon_stem" => {
                let mut block_state = MelonStemState::default();
                if let Some(prop) = props.get("age") {
                    block_state.with_age(i32::from_str(prop)?);
                }
                Blocks::MelonStem(block_state)
            }
            "vine" => {
                let mut block_state = VineState::default();
                if let Some(prop) = props.get("east") {
                    block_state.with_east(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("north") {
                    block_state.with_north(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("south") {
                    block_state.with_south(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("up") {
                    block_state.with_up(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("west") {
                    block_state.with_west(bool::from_str(prop)?);
                }
                Blocks::Vine(block_state)
            }
            "glow_lichen" => {
                let mut block_state = GlowLichenState::default();
                if let Some(prop) = props.get("down") {
                    block_state.with_down(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("east") {
                    block_state.with_east(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("north") {
                    block_state.with_north(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("south") {
                    block_state.with_south(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("up") {
                    block_state.with_up(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("west") {
                    block_state.with_west(bool::from_str(prop)?);
                }
                Blocks::GlowLichen(block_state)
            }
            "oak_fence_gate" => {
                let mut block_state = OakFenceGateState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("in_wall") {
                    block_state.with_in_wall(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("open") {
                    block_state.with_open(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("powered") {
                    block_state.with_powered(bool::from_str(prop)?);
                }
                Blocks::OakFenceGate(block_state)
            }
            "brick_stairs" => {
                let mut block_state = BrickStairsState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("half") {
                    block_state.with_half(SingleBlockHalf::from_str(prop)?);
                }
                if let Some(prop) = props.get("shape") {
                    block_state.with_shape(StairShape::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::BrickStairs(block_state)
            }
            "stone_brick_stairs" => {
                let mut block_state = StoneBrickStairsState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("half") {
                    block_state.with_half(SingleBlockHalf::from_str(prop)?);
                }
                if let Some(prop) = props.get("shape") {
                    block_state.with_shape(StairShape::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::StoneBrickStairs(block_state)
            }
            "mycelium" => {
                let mut block_state = MyceliumState::default();
                if let Some(prop) = props.get("snowy") {
                    block_state.with_snowy(bool::from_str(prop)?);
                }
                Blocks::Mycelium(block_state)
            }
            "lily_pad" => Blocks::LilyPad,
            "nether_bricks" => Blocks::NetherBricks,
            "nether_brick_fence" => {
                let mut block_state = NetherBrickFenceState::default();
                if let Some(prop) = props.get("east") {
                    block_state.with_east(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("north") {
                    block_state.with_north(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("south") {
                    block_state.with_south(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("west") {
                    block_state.with_west(bool::from_str(prop)?);
                }
                Blocks::NetherBrickFence(block_state)
            }
            "nether_brick_stairs" => {
                let mut block_state = NetherBrickStairsState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("half") {
                    block_state.with_half(SingleBlockHalf::from_str(prop)?);
                }
                if let Some(prop) = props.get("shape") {
                    block_state.with_shape(StairShape::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::NetherBrickStairs(block_state)
            }
            "nether_wart" => {
                let mut block_state = NetherWartState::default();
                if let Some(prop) = props.get("age") {
                    block_state.with_age(i32::from_str(prop)?);
                }
                Blocks::NetherWart(block_state)
            }
            "enchanting_table" => Blocks::EnchantingTable,
            "brewing_stand" => {
                let mut block_state = BrewingStandState::default();
                if let Some(prop) = props.get("has_bottle_0") {
                    block_state.with_has_bottle_0(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("has_bottle_1") {
                    block_state.with_has_bottle_1(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("has_bottle_2") {
                    block_state.with_has_bottle_2(bool::from_str(prop)?);
                }
                Blocks::BrewingStand(block_state)
            }
            "cauldron" => Blocks::Cauldron,
            "water_cauldron" => {
                let mut block_state = WaterCauldronState::default();
                if let Some(prop) = props.get("level") {
                    block_state.with_level(i32::from_str(prop)?);
                }
                Blocks::WaterCauldron(block_state)
            }
            "lava_cauldron" => Blocks::LavaCauldron,
            "powder_snow_cauldron" => {
                let mut block_state = PowderSnowCauldronState::default();
                if let Some(prop) = props.get("level") {
                    block_state.with_level(i32::from_str(prop)?);
                }
                Blocks::PowderSnowCauldron(block_state)
            }
            "end_portal" => Blocks::EndPortal,
            "end_portal_frame" => {
                let mut block_state = EndPortalFrameState::default();
                if let Some(prop) = props.get("eye") {
                    block_state.with_eye(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                Blocks::EndPortalFrame(block_state)
            }
            "end_stone" => Blocks::EndStone,
            "dragon_egg" => Blocks::DragonEgg,
            "redstone_lamp" => {
                let mut block_state = RedstoneLampState::default();
                if let Some(prop) = props.get("lit") {
                    block_state.with_lit(bool::from_str(prop)?);
                }
                Blocks::RedstoneLamp(block_state)
            }
            "cocoa" => {
                let mut block_state = CocoaState::default();
                if let Some(prop) = props.get("age") {
                    block_state.with_age(i32::from_str(prop)?);
                }
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                Blocks::Cocoa(block_state)
            }
            "sandstone_stairs" => {
                let mut block_state = SandstoneStairsState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("half") {
                    block_state.with_half(SingleBlockHalf::from_str(prop)?);
                }
                if let Some(prop) = props.get("shape") {
                    block_state.with_shape(StairShape::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::SandstoneStairs(block_state)
            }
            "emerald_ore" => Blocks::EmeraldOre,
            "deepslate_emerald_ore" => Blocks::DeepslateEmeraldOre,
            "ender_chest" => {
                let mut block_state = EnderChestState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::EnderChest(block_state)
            }
            "tripwire_hook" => {
                let mut block_state = TripwireHookState::default();
                if let Some(prop) = props.get("attached") {
                    block_state.with_attached(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("powered") {
                    block_state.with_powered(bool::from_str(prop)?);
                }
                Blocks::TripwireHook(block_state)
            }
            "tripwire" => {
                let mut block_state = TripwireState::default();
                if let Some(prop) = props.get("attached") {
                    block_state.with_attached(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("disarmed") {
                    block_state.with_disarmed(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("east") {
                    block_state.with_east(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("north") {
                    block_state.with_north(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("powered") {
                    block_state.with_powered(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("south") {
                    block_state.with_south(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("west") {
                    block_state.with_west(bool::from_str(prop)?);
                }
                Blocks::Tripwire(block_state)
            }
            "emerald_block" => Blocks::EmeraldBlock,
            "spruce_stairs" => {
                let mut block_state = SpruceStairsState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("half") {
                    block_state.with_half(SingleBlockHalf::from_str(prop)?);
                }
                if let Some(prop) = props.get("shape") {
                    block_state.with_shape(StairShape::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::SpruceStairs(block_state)
            }
            "birch_stairs" => {
                let mut block_state = BirchStairsState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("half") {
                    block_state.with_half(SingleBlockHalf::from_str(prop)?);
                }
                if let Some(prop) = props.get("shape") {
                    block_state.with_shape(StairShape::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::BirchStairs(block_state)
            }
            "jungle_stairs" => {
                let mut block_state = JungleStairsState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("half") {
                    block_state.with_half(SingleBlockHalf::from_str(prop)?);
                }
                if let Some(prop) = props.get("shape") {
                    block_state.with_shape(StairShape::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::JungleStairs(block_state)
            }
            "command_block" => {
                let mut block_state = CommandBlockState::default();
                if let Some(prop) = props.get("conditional") {
                    block_state.with_conditional(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(AllFacing::from_str(prop)?);
                }
                Blocks::CommandBlock(block_state)
            }
            "beacon" => Blocks::Beacon,
            "cobblestone_wall" => {
                let mut block_state = CobblestoneWallState::default();
                if let Some(prop) = props.get("east") {
                    block_state.with_east(WallType::from_str(prop)?);
                }
                if let Some(prop) = props.get("north") {
                    block_state.with_north(WallType::from_str(prop)?);
                }
                if let Some(prop) = props.get("south") {
                    block_state.with_south(WallType::from_str(prop)?);
                }
                if let Some(prop) = props.get("up") {
                    block_state.with_up(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("west") {
                    block_state.with_west(WallType::from_str(prop)?);
                }
                Blocks::CobblestoneWall(block_state)
            }
            "mossy_cobblestone_wall" => {
                let mut block_state = MossyCobblestoneWallState::default();
                if let Some(prop) = props.get("east") {
                    block_state.with_east(WallType::from_str(prop)?);
                }
                if let Some(prop) = props.get("north") {
                    block_state.with_north(WallType::from_str(prop)?);
                }
                if let Some(prop) = props.get("south") {
                    block_state.with_south(WallType::from_str(prop)?);
                }
                if let Some(prop) = props.get("up") {
                    block_state.with_up(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("west") {
                    block_state.with_west(WallType::from_str(prop)?);
                }
                Blocks::MossyCobblestoneWall(block_state)
            }
            "flower_pot" => Blocks::FlowerPot,
            "potted_oak_sapling" => Blocks::PottedOakSapling,
            "potted_spruce_sapling" => Blocks::PottedSpruceSapling,
            "potted_birch_sapling" => Blocks::PottedBirchSapling,
            "potted_jungle_sapling" => Blocks::PottedJungleSapling,
            "potted_acacia_sapling" => Blocks::PottedAcaciaSapling,
            "potted_dark_oak_sapling" => Blocks::PottedDarkOakSapling,
            "potted_fern" => Blocks::PottedFern,
            "potted_dandelion" => Blocks::PottedDandelion,
            "potted_poppy" => Blocks::PottedPoppy,
            "potted_blue_orchid" => Blocks::PottedBlueOrchid,
            "potted_allium" => Blocks::PottedAllium,
            "potted_azure_bluet" => Blocks::PottedAzureBluet,
            "potted_red_tulip" => Blocks::PottedRedTulip,
            "potted_orange_tulip" => Blocks::PottedOrangeTulip,
            "potted_white_tulip" => Blocks::PottedWhiteTulip,
            "potted_pink_tulip" => Blocks::PottedPinkTulip,
            "potted_oxeye_daisy" => Blocks::PottedOxeyeDaisy,
            "potted_cornflower" => Blocks::PottedCornflower,
            "potted_lily_of_the_valley" => Blocks::PottedLilyOfTheValley,
            "potted_wither_rose" => Blocks::PottedWitherRose,
            "potted_red_mushroom" => Blocks::PottedRedMushroom,
            "potted_brown_mushroom" => Blocks::PottedBrownMushroom,
            "potted_dead_bush" => Blocks::PottedDeadBush,
            "potted_cactus" => Blocks::PottedCactus,
            "carrots" => {
                let mut block_state = CarrotsState::default();
                if let Some(prop) = props.get("age") {
                    block_state.with_age(i32::from_str(prop)?);
                }
                Blocks::Carrots(block_state)
            }
            "potatoes" => {
                let mut block_state = PotatoesState::default();
                if let Some(prop) = props.get("age") {
                    block_state.with_age(i32::from_str(prop)?);
                }
                Blocks::Potatoes(block_state)
            }
            "oak_button" => {
                let mut block_state = OakButtonState::default();
                if let Some(prop) = props.get("face") {
                    block_state.with_face(Face::from_str(prop)?);
                }
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("powered") {
                    block_state.with_powered(bool::from_str(prop)?);
                }
                Blocks::OakButton(block_state)
            }
            "spruce_button" => {
                let mut block_state = SpruceButtonState::default();
                if let Some(prop) = props.get("face") {
                    block_state.with_face(Face::from_str(prop)?);
                }
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("powered") {
                    block_state.with_powered(bool::from_str(prop)?);
                }
                Blocks::SpruceButton(block_state)
            }
            "birch_button" => {
                let mut block_state = BirchButtonState::default();
                if let Some(prop) = props.get("face") {
                    block_state.with_face(Face::from_str(prop)?);
                }
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("powered") {
                    block_state.with_powered(bool::from_str(prop)?);
                }
                Blocks::BirchButton(block_state)
            }
            "jungle_button" => {
                let mut block_state = JungleButtonState::default();
                if let Some(prop) = props.get("face") {
                    block_state.with_face(Face::from_str(prop)?);
                }
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("powered") {
                    block_state.with_powered(bool::from_str(prop)?);
                }
                Blocks::JungleButton(block_state)
            }
            "acacia_button" => {
                let mut block_state = AcaciaButtonState::default();
                if let Some(prop) = props.get("face") {
                    block_state.with_face(Face::from_str(prop)?);
                }
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("powered") {
                    block_state.with_powered(bool::from_str(prop)?);
                }
                Blocks::AcaciaButton(block_state)
            }
            "dark_oak_button" => {
                let mut block_state = DarkOakButtonState::default();
                if let Some(prop) = props.get("face") {
                    block_state.with_face(Face::from_str(prop)?);
                }
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("powered") {
                    block_state.with_powered(bool::from_str(prop)?);
                }
                Blocks::DarkOakButton(block_state)
            }
            "skeleton_skull" => {
                let mut block_state = SkeletonSkullState::default();
                if let Some(prop) = props.get("rotation") {
                    block_state.with_rotation(i32::from_str(prop)?);
                }
                Blocks::SkeletonSkull(block_state)
            }
            "skeleton_wall_skull" => {
                let mut block_state = SkeletonWallSkullState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                Blocks::SkeletonWallSkull(block_state)
            }
            "wither_skeleton_skull" => {
                let mut block_state = WitherSkeletonSkullState::default();
                if let Some(prop) = props.get("rotation") {
                    block_state.with_rotation(i32::from_str(prop)?);
                }
                Blocks::WitherSkeletonSkull(block_state)
            }
            "wither_skeleton_wall_skull" => {
                let mut block_state = WitherSkeletonWallSkullState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                Blocks::WitherSkeletonWallSkull(block_state)
            }
            "zombie_head" => {
                let mut block_state = ZombieHeadState::default();
                if let Some(prop) = props.get("rotation") {
                    block_state.with_rotation(i32::from_str(prop)?);
                }
                Blocks::ZombieHead(block_state)
            }
            "zombie_wall_head" => {
                let mut block_state = ZombieWallHeadState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                Blocks::ZombieWallHead(block_state)
            }
            "player_head" => {
                let mut block_state = PlayerHeadState::default();
                if let Some(prop) = props.get("rotation") {
                    block_state.with_rotation(i32::from_str(prop)?);
                }
                Blocks::PlayerHead(block_state)
            }
            "player_wall_head" => {
                let mut block_state = PlayerWallHeadState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                Blocks::PlayerWallHead(block_state)
            }
            "creeper_head" => {
                let mut block_state = CreeperHeadState::default();
                if let Some(prop) = props.get("rotation") {
                    block_state.with_rotation(i32::from_str(prop)?);
                }
                Blocks::CreeperHead(block_state)
            }
            "creeper_wall_head" => {
                let mut block_state = CreeperWallHeadState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                Blocks::CreeperWallHead(block_state)
            }
            "dragon_head" => {
                let mut block_state = DragonHeadState::default();
                if let Some(prop) = props.get("rotation") {
                    block_state.with_rotation(i32::from_str(prop)?);
                }
                Blocks::DragonHead(block_state)
            }
            "dragon_wall_head" => {
                let mut block_state = DragonWallHeadState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                Blocks::DragonWallHead(block_state)
            }
            "anvil" => {
                let mut block_state = AnvilState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                Blocks::Anvil(block_state)
            }
            "chipped_anvil" => {
                let mut block_state = ChippedAnvilState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                Blocks::ChippedAnvil(block_state)
            }
            "damaged_anvil" => {
                let mut block_state = DamagedAnvilState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                Blocks::DamagedAnvil(block_state)
            }
            "trapped_chest" => {
                let mut block_state = TrappedChestState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("typed") {
                    block_state.with_typed(ChestType::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::TrappedChest(block_state)
            }
            "light_weighted_pressure_plate" => {
                let mut block_state = LightWeightedPressurePlateState::default();
                if let Some(prop) = props.get("power") {
                    block_state.with_power(i32::from_str(prop)?);
                }
                Blocks::LightWeightedPressurePlate(block_state)
            }
            "heavy_weighted_pressure_plate" => {
                let mut block_state = HeavyWeightedPressurePlateState::default();
                if let Some(prop) = props.get("power") {
                    block_state.with_power(i32::from_str(prop)?);
                }
                Blocks::HeavyWeightedPressurePlate(block_state)
            }
            "comparator" => {
                let mut block_state = ComparatorState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("mode") {
                    block_state.with_mode(ComparatorMode::from_str(prop)?);
                }
                if let Some(prop) = props.get("powered") {
                    block_state.with_powered(bool::from_str(prop)?);
                }
                Blocks::Comparator(block_state)
            }
            "daylight_detector" => {
                let mut block_state = DaylightDetectorState::default();
                if let Some(prop) = props.get("inverted") {
                    block_state.with_inverted(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("power") {
                    block_state.with_power(i32::from_str(prop)?);
                }
                Blocks::DaylightDetector(block_state)
            }
            "redstone_block" => Blocks::RedstoneBlock,
            "nether_quartz_ore" => Blocks::NetherQuartzOre,
            "hopper" => {
                let mut block_state = HopperState::default();
                if let Some(prop) = props.get("enabled") {
                    block_state.with_enabled(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HopperFacing::from_str(prop)?);
                }
                Blocks::Hopper(block_state)
            }
            "quartz_block" => Blocks::QuartzBlock,
            "chiseled_quartz_block" => Blocks::ChiseledQuartzBlock,
            "quartz_pillar" => {
                let mut block_state = QuartzPillarState::default();
                if let Some(prop) = props.get("axis") {
                    block_state.with_axis(Axis::from_str(prop)?);
                }
                Blocks::QuartzPillar(block_state)
            }
            "quartz_stairs" => {
                let mut block_state = QuartzStairsState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("half") {
                    block_state.with_half(SingleBlockHalf::from_str(prop)?);
                }
                if let Some(prop) = props.get("shape") {
                    block_state.with_shape(StairShape::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::QuartzStairs(block_state)
            }
            "activator_rail" => {
                let mut block_state = ActivatorRailState::default();
                if let Some(prop) = props.get("powered") {
                    block_state.with_powered(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("shape") {
                    block_state.with_shape(StraightRailShape::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::ActivatorRail(block_state)
            }
            "dropper" => {
                let mut block_state = DropperState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(AllFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("triggered") {
                    block_state.with_triggered(bool::from_str(prop)?);
                }
                Blocks::Dropper(block_state)
            }
            "white_terracotta" => Blocks::WhiteTerracotta,
            "orange_terracotta" => Blocks::OrangeTerracotta,
            "magenta_terracotta" => Blocks::MagentaTerracotta,
            "light_blue_terracotta" => Blocks::LightBlueTerracotta,
            "yellow_terracotta" => Blocks::YellowTerracotta,
            "lime_terracotta" => Blocks::LimeTerracotta,
            "pink_terracotta" => Blocks::PinkTerracotta,
            "gray_terracotta" => Blocks::GrayTerracotta,
            "light_gray_terracotta" => Blocks::LightGrayTerracotta,
            "cyan_terracotta" => Blocks::CyanTerracotta,
            "purple_terracotta" => Blocks::PurpleTerracotta,
            "blue_terracotta" => Blocks::BlueTerracotta,
            "brown_terracotta" => Blocks::BrownTerracotta,
            "green_terracotta" => Blocks::GreenTerracotta,
            "red_terracotta" => Blocks::RedTerracotta,
            "black_terracotta" => Blocks::BlackTerracotta,
            "white_stained_glass_pane" => {
                let mut block_state = WhiteStainedGlassPaneState::default();
                if let Some(prop) = props.get("east") {
                    block_state.with_east(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("north") {
                    block_state.with_north(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("south") {
                    block_state.with_south(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("west") {
                    block_state.with_west(bool::from_str(prop)?);
                }
                Blocks::WhiteStainedGlassPane(block_state)
            }
            "orange_stained_glass_pane" => {
                let mut block_state = OrangeStainedGlassPaneState::default();
                if let Some(prop) = props.get("east") {
                    block_state.with_east(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("north") {
                    block_state.with_north(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("south") {
                    block_state.with_south(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("west") {
                    block_state.with_west(bool::from_str(prop)?);
                }
                Blocks::OrangeStainedGlassPane(block_state)
            }
            "magenta_stained_glass_pane" => {
                let mut block_state = MagentaStainedGlassPaneState::default();
                if let Some(prop) = props.get("east") {
                    block_state.with_east(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("north") {
                    block_state.with_north(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("south") {
                    block_state.with_south(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("west") {
                    block_state.with_west(bool::from_str(prop)?);
                }
                Blocks::MagentaStainedGlassPane(block_state)
            }
            "light_blue_stained_glass_pane" => {
                let mut block_state = LightBlueStainedGlassPaneState::default();
                if let Some(prop) = props.get("east") {
                    block_state.with_east(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("north") {
                    block_state.with_north(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("south") {
                    block_state.with_south(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("west") {
                    block_state.with_west(bool::from_str(prop)?);
                }
                Blocks::LightBlueStainedGlassPane(block_state)
            }
            "yellow_stained_glass_pane" => {
                let mut block_state = YellowStainedGlassPaneState::default();
                if let Some(prop) = props.get("east") {
                    block_state.with_east(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("north") {
                    block_state.with_north(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("south") {
                    block_state.with_south(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("west") {
                    block_state.with_west(bool::from_str(prop)?);
                }
                Blocks::YellowStainedGlassPane(block_state)
            }
            "lime_stained_glass_pane" => {
                let mut block_state = LimeStainedGlassPaneState::default();
                if let Some(prop) = props.get("east") {
                    block_state.with_east(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("north") {
                    block_state.with_north(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("south") {
                    block_state.with_south(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("west") {
                    block_state.with_west(bool::from_str(prop)?);
                }
                Blocks::LimeStainedGlassPane(block_state)
            }
            "pink_stained_glass_pane" => {
                let mut block_state = PinkStainedGlassPaneState::default();
                if let Some(prop) = props.get("east") {
                    block_state.with_east(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("north") {
                    block_state.with_north(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("south") {
                    block_state.with_south(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("west") {
                    block_state.with_west(bool::from_str(prop)?);
                }
                Blocks::PinkStainedGlassPane(block_state)
            }
            "gray_stained_glass_pane" => {
                let mut block_state = GrayStainedGlassPaneState::default();
                if let Some(prop) = props.get("east") {
                    block_state.with_east(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("north") {
                    block_state.with_north(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("south") {
                    block_state.with_south(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("west") {
                    block_state.with_west(bool::from_str(prop)?);
                }
                Blocks::GrayStainedGlassPane(block_state)
            }
            "light_gray_stained_glass_pane" => {
                let mut block_state = LightGrayStainedGlassPaneState::default();
                if let Some(prop) = props.get("east") {
                    block_state.with_east(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("north") {
                    block_state.with_north(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("south") {
                    block_state.with_south(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("west") {
                    block_state.with_west(bool::from_str(prop)?);
                }
                Blocks::LightGrayStainedGlassPane(block_state)
            }
            "cyan_stained_glass_pane" => {
                let mut block_state = CyanStainedGlassPaneState::default();
                if let Some(prop) = props.get("east") {
                    block_state.with_east(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("north") {
                    block_state.with_north(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("south") {
                    block_state.with_south(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("west") {
                    block_state.with_west(bool::from_str(prop)?);
                }
                Blocks::CyanStainedGlassPane(block_state)
            }
            "purple_stained_glass_pane" => {
                let mut block_state = PurpleStainedGlassPaneState::default();
                if let Some(prop) = props.get("east") {
                    block_state.with_east(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("north") {
                    block_state.with_north(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("south") {
                    block_state.with_south(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("west") {
                    block_state.with_west(bool::from_str(prop)?);
                }
                Blocks::PurpleStainedGlassPane(block_state)
            }
            "blue_stained_glass_pane" => {
                let mut block_state = BlueStainedGlassPaneState::default();
                if let Some(prop) = props.get("east") {
                    block_state.with_east(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("north") {
                    block_state.with_north(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("south") {
                    block_state.with_south(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("west") {
                    block_state.with_west(bool::from_str(prop)?);
                }
                Blocks::BlueStainedGlassPane(block_state)
            }
            "brown_stained_glass_pane" => {
                let mut block_state = BrownStainedGlassPaneState::default();
                if let Some(prop) = props.get("east") {
                    block_state.with_east(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("north") {
                    block_state.with_north(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("south") {
                    block_state.with_south(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("west") {
                    block_state.with_west(bool::from_str(prop)?);
                }
                Blocks::BrownStainedGlassPane(block_state)
            }
            "green_stained_glass_pane" => {
                let mut block_state = GreenStainedGlassPaneState::default();
                if let Some(prop) = props.get("east") {
                    block_state.with_east(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("north") {
                    block_state.with_north(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("south") {
                    block_state.with_south(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("west") {
                    block_state.with_west(bool::from_str(prop)?);
                }
                Blocks::GreenStainedGlassPane(block_state)
            }
            "red_stained_glass_pane" => {
                let mut block_state = RedStainedGlassPaneState::default();
                if let Some(prop) = props.get("east") {
                    block_state.with_east(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("north") {
                    block_state.with_north(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("south") {
                    block_state.with_south(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("west") {
                    block_state.with_west(bool::from_str(prop)?);
                }
                Blocks::RedStainedGlassPane(block_state)
            }
            "black_stained_glass_pane" => {
                let mut block_state = BlackStainedGlassPaneState::default();
                if let Some(prop) = props.get("east") {
                    block_state.with_east(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("north") {
                    block_state.with_north(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("south") {
                    block_state.with_south(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("west") {
                    block_state.with_west(bool::from_str(prop)?);
                }
                Blocks::BlackStainedGlassPane(block_state)
            }
            "acacia_stairs" => {
                let mut block_state = AcaciaStairsState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("half") {
                    block_state.with_half(SingleBlockHalf::from_str(prop)?);
                }
                if let Some(prop) = props.get("shape") {
                    block_state.with_shape(StairShape::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::AcaciaStairs(block_state)
            }
            "dark_oak_stairs" => {
                let mut block_state = DarkOakStairsState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("half") {
                    block_state.with_half(SingleBlockHalf::from_str(prop)?);
                }
                if let Some(prop) = props.get("shape") {
                    block_state.with_shape(StairShape::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::DarkOakStairs(block_state)
            }
            "slime_block" => Blocks::SlimeBlock,
            "barrier" => Blocks::Barrier,
            "light" => {
                let mut block_state = LightState::default();
                if let Some(prop) = props.get("level") {
                    block_state.with_level(i32::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::Light(block_state)
            }
            "iron_trapdoor" => {
                let mut block_state = IronTrapdoorState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("half") {
                    block_state.with_half(SingleBlockHalf::from_str(prop)?);
                }
                if let Some(prop) = props.get("open") {
                    block_state.with_open(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("powered") {
                    block_state.with_powered(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::IronTrapdoor(block_state)
            }
            "prismarine" => Blocks::Prismarine,
            "prismarine_bricks" => Blocks::PrismarineBricks,
            "dark_prismarine" => Blocks::DarkPrismarine,
            "prismarine_stairs" => {
                let mut block_state = PrismarineStairsState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("half") {
                    block_state.with_half(SingleBlockHalf::from_str(prop)?);
                }
                if let Some(prop) = props.get("shape") {
                    block_state.with_shape(StairShape::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::PrismarineStairs(block_state)
            }
            "prismarine_brick_stairs" => {
                let mut block_state = PrismarineBrickStairsState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("half") {
                    block_state.with_half(SingleBlockHalf::from_str(prop)?);
                }
                if let Some(prop) = props.get("shape") {
                    block_state.with_shape(StairShape::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::PrismarineBrickStairs(block_state)
            }
            "dark_prismarine_stairs" => {
                let mut block_state = DarkPrismarineStairsState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("half") {
                    block_state.with_half(SingleBlockHalf::from_str(prop)?);
                }
                if let Some(prop) = props.get("shape") {
                    block_state.with_shape(StairShape::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::DarkPrismarineStairs(block_state)
            }
            "prismarine_slab" => {
                let mut block_state = PrismarineSlabState::default();
                if let Some(prop) = props.get("typed") {
                    block_state.with_typed(SlabType::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::PrismarineSlab(block_state)
            }
            "prismarine_brick_slab" => {
                let mut block_state = PrismarineBrickSlabState::default();
                if let Some(prop) = props.get("typed") {
                    block_state.with_typed(SlabType::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::PrismarineBrickSlab(block_state)
            }
            "dark_prismarine_slab" => {
                let mut block_state = DarkPrismarineSlabState::default();
                if let Some(prop) = props.get("typed") {
                    block_state.with_typed(SlabType::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::DarkPrismarineSlab(block_state)
            }
            "sea_lantern" => Blocks::SeaLantern,
            "hay_block" => {
                let mut block_state = HayBlockState::default();
                if let Some(prop) = props.get("axis") {
                    block_state.with_axis(Axis::from_str(prop)?);
                }
                Blocks::HayBlock(block_state)
            }
            "white_carpet" => Blocks::WhiteCarpet,
            "orange_carpet" => Blocks::OrangeCarpet,
            "magenta_carpet" => Blocks::MagentaCarpet,
            "light_blue_carpet" => Blocks::LightBlueCarpet,
            "yellow_carpet" => Blocks::YellowCarpet,
            "lime_carpet" => Blocks::LimeCarpet,
            "pink_carpet" => Blocks::PinkCarpet,
            "gray_carpet" => Blocks::GrayCarpet,
            "light_gray_carpet" => Blocks::LightGrayCarpet,
            "cyan_carpet" => Blocks::CyanCarpet,
            "purple_carpet" => Blocks::PurpleCarpet,
            "blue_carpet" => Blocks::BlueCarpet,
            "brown_carpet" => Blocks::BrownCarpet,
            "green_carpet" => Blocks::GreenCarpet,
            "red_carpet" => Blocks::RedCarpet,
            "black_carpet" => Blocks::BlackCarpet,
            "terracotta" => Blocks::Terracotta,
            "coal_block" => Blocks::CoalBlock,
            "packed_ice" => Blocks::PackedIce,
            "sunflower" => {
                let mut block_state = SunflowerState::default();
                if let Some(prop) = props.get("half") {
                    block_state.with_half(DoubleBlockHalf::from_str(prop)?);
                }
                Blocks::Sunflower(block_state)
            }
            "lilac" => {
                let mut block_state = LilacState::default();
                if let Some(prop) = props.get("half") {
                    block_state.with_half(DoubleBlockHalf::from_str(prop)?);
                }
                Blocks::Lilac(block_state)
            }
            "rose_bush" => {
                let mut block_state = RoseBushState::default();
                if let Some(prop) = props.get("half") {
                    block_state.with_half(DoubleBlockHalf::from_str(prop)?);
                }
                Blocks::RoseBush(block_state)
            }
            "peony" => {
                let mut block_state = PeonyState::default();
                if let Some(prop) = props.get("half") {
                    block_state.with_half(DoubleBlockHalf::from_str(prop)?);
                }
                Blocks::Peony(block_state)
            }
            "tall_grass" => {
                let mut block_state = TallGrassState::default();
                if let Some(prop) = props.get("half") {
                    block_state.with_half(DoubleBlockHalf::from_str(prop)?);
                }
                Blocks::TallGrass(block_state)
            }
            "large_fern" => {
                let mut block_state = LargeFernState::default();
                if let Some(prop) = props.get("half") {
                    block_state.with_half(DoubleBlockHalf::from_str(prop)?);
                }
                Blocks::LargeFern(block_state)
            }
            "white_banner" => {
                let mut block_state = WhiteBannerState::default();
                if let Some(prop) = props.get("rotation") {
                    block_state.with_rotation(i32::from_str(prop)?);
                }
                Blocks::WhiteBanner(block_state)
            }
            "orange_banner" => {
                let mut block_state = OrangeBannerState::default();
                if let Some(prop) = props.get("rotation") {
                    block_state.with_rotation(i32::from_str(prop)?);
                }
                Blocks::OrangeBanner(block_state)
            }
            "magenta_banner" => {
                let mut block_state = MagentaBannerState::default();
                if let Some(prop) = props.get("rotation") {
                    block_state.with_rotation(i32::from_str(prop)?);
                }
                Blocks::MagentaBanner(block_state)
            }
            "light_blue_banner" => {
                let mut block_state = LightBlueBannerState::default();
                if let Some(prop) = props.get("rotation") {
                    block_state.with_rotation(i32::from_str(prop)?);
                }
                Blocks::LightBlueBanner(block_state)
            }
            "yellow_banner" => {
                let mut block_state = YellowBannerState::default();
                if let Some(prop) = props.get("rotation") {
                    block_state.with_rotation(i32::from_str(prop)?);
                }
                Blocks::YellowBanner(block_state)
            }
            "lime_banner" => {
                let mut block_state = LimeBannerState::default();
                if let Some(prop) = props.get("rotation") {
                    block_state.with_rotation(i32::from_str(prop)?);
                }
                Blocks::LimeBanner(block_state)
            }
            "pink_banner" => {
                let mut block_state = PinkBannerState::default();
                if let Some(prop) = props.get("rotation") {
                    block_state.with_rotation(i32::from_str(prop)?);
                }
                Blocks::PinkBanner(block_state)
            }
            "gray_banner" => {
                let mut block_state = GrayBannerState::default();
                if let Some(prop) = props.get("rotation") {
                    block_state.with_rotation(i32::from_str(prop)?);
                }
                Blocks::GrayBanner(block_state)
            }
            "light_gray_banner" => {
                let mut block_state = LightGrayBannerState::default();
                if let Some(prop) = props.get("rotation") {
                    block_state.with_rotation(i32::from_str(prop)?);
                }
                Blocks::LightGrayBanner(block_state)
            }
            "cyan_banner" => {
                let mut block_state = CyanBannerState::default();
                if let Some(prop) = props.get("rotation") {
                    block_state.with_rotation(i32::from_str(prop)?);
                }
                Blocks::CyanBanner(block_state)
            }
            "purple_banner" => {
                let mut block_state = PurpleBannerState::default();
                if let Some(prop) = props.get("rotation") {
                    block_state.with_rotation(i32::from_str(prop)?);
                }
                Blocks::PurpleBanner(block_state)
            }
            "blue_banner" => {
                let mut block_state = BlueBannerState::default();
                if let Some(prop) = props.get("rotation") {
                    block_state.with_rotation(i32::from_str(prop)?);
                }
                Blocks::BlueBanner(block_state)
            }
            "brown_banner" => {
                let mut block_state = BrownBannerState::default();
                if let Some(prop) = props.get("rotation") {
                    block_state.with_rotation(i32::from_str(prop)?);
                }
                Blocks::BrownBanner(block_state)
            }
            "green_banner" => {
                let mut block_state = GreenBannerState::default();
                if let Some(prop) = props.get("rotation") {
                    block_state.with_rotation(i32::from_str(prop)?);
                }
                Blocks::GreenBanner(block_state)
            }
            "red_banner" => {
                let mut block_state = RedBannerState::default();
                if let Some(prop) = props.get("rotation") {
                    block_state.with_rotation(i32::from_str(prop)?);
                }
                Blocks::RedBanner(block_state)
            }
            "black_banner" => {
                let mut block_state = BlackBannerState::default();
                if let Some(prop) = props.get("rotation") {
                    block_state.with_rotation(i32::from_str(prop)?);
                }
                Blocks::BlackBanner(block_state)
            }
            "white_wall_banner" => {
                let mut block_state = WhiteWallBannerState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                Blocks::WhiteWallBanner(block_state)
            }
            "orange_wall_banner" => {
                let mut block_state = OrangeWallBannerState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                Blocks::OrangeWallBanner(block_state)
            }
            "magenta_wall_banner" => {
                let mut block_state = MagentaWallBannerState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                Blocks::MagentaWallBanner(block_state)
            }
            "light_blue_wall_banner" => {
                let mut block_state = LightBlueWallBannerState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                Blocks::LightBlueWallBanner(block_state)
            }
            "yellow_wall_banner" => {
                let mut block_state = YellowWallBannerState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                Blocks::YellowWallBanner(block_state)
            }
            "lime_wall_banner" => {
                let mut block_state = LimeWallBannerState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                Blocks::LimeWallBanner(block_state)
            }
            "pink_wall_banner" => {
                let mut block_state = PinkWallBannerState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                Blocks::PinkWallBanner(block_state)
            }
            "gray_wall_banner" => {
                let mut block_state = GrayWallBannerState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                Blocks::GrayWallBanner(block_state)
            }
            "light_gray_wall_banner" => {
                let mut block_state = LightGrayWallBannerState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                Blocks::LightGrayWallBanner(block_state)
            }
            "cyan_wall_banner" => {
                let mut block_state = CyanWallBannerState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                Blocks::CyanWallBanner(block_state)
            }
            "purple_wall_banner" => {
                let mut block_state = PurpleWallBannerState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                Blocks::PurpleWallBanner(block_state)
            }
            "blue_wall_banner" => {
                let mut block_state = BlueWallBannerState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                Blocks::BlueWallBanner(block_state)
            }
            "brown_wall_banner" => {
                let mut block_state = BrownWallBannerState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                Blocks::BrownWallBanner(block_state)
            }
            "green_wall_banner" => {
                let mut block_state = GreenWallBannerState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                Blocks::GreenWallBanner(block_state)
            }
            "red_wall_banner" => {
                let mut block_state = RedWallBannerState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                Blocks::RedWallBanner(block_state)
            }
            "black_wall_banner" => {
                let mut block_state = BlackWallBannerState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                Blocks::BlackWallBanner(block_state)
            }
            "red_sandstone" => Blocks::RedSandstone,
            "chiseled_red_sandstone" => Blocks::ChiseledRedSandstone,
            "cut_red_sandstone" => Blocks::CutRedSandstone,
            "red_sandstone_stairs" => {
                let mut block_state = RedSandstoneStairsState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("half") {
                    block_state.with_half(SingleBlockHalf::from_str(prop)?);
                }
                if let Some(prop) = props.get("shape") {
                    block_state.with_shape(StairShape::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::RedSandstoneStairs(block_state)
            }
            "oak_slab" => {
                let mut block_state = OakSlabState::default();
                if let Some(prop) = props.get("typed") {
                    block_state.with_typed(SlabType::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::OakSlab(block_state)
            }
            "spruce_slab" => {
                let mut block_state = SpruceSlabState::default();
                if let Some(prop) = props.get("typed") {
                    block_state.with_typed(SlabType::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::SpruceSlab(block_state)
            }
            "birch_slab" => {
                let mut block_state = BirchSlabState::default();
                if let Some(prop) = props.get("typed") {
                    block_state.with_typed(SlabType::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::BirchSlab(block_state)
            }
            "jungle_slab" => {
                let mut block_state = JungleSlabState::default();
                if let Some(prop) = props.get("typed") {
                    block_state.with_typed(SlabType::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::JungleSlab(block_state)
            }
            "acacia_slab" => {
                let mut block_state = AcaciaSlabState::default();
                if let Some(prop) = props.get("typed") {
                    block_state.with_typed(SlabType::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::AcaciaSlab(block_state)
            }
            "dark_oak_slab" => {
                let mut block_state = DarkOakSlabState::default();
                if let Some(prop) = props.get("typed") {
                    block_state.with_typed(SlabType::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::DarkOakSlab(block_state)
            }
            "stone_slab" => {
                let mut block_state = StoneSlabState::default();
                if let Some(prop) = props.get("typed") {
                    block_state.with_typed(SlabType::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::StoneSlab(block_state)
            }
            "smooth_stone_slab" => {
                let mut block_state = SmoothStoneSlabState::default();
                if let Some(prop) = props.get("typed") {
                    block_state.with_typed(SlabType::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::SmoothStoneSlab(block_state)
            }
            "sandstone_slab" => {
                let mut block_state = SandstoneSlabState::default();
                if let Some(prop) = props.get("typed") {
                    block_state.with_typed(SlabType::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::SandstoneSlab(block_state)
            }
            "cut_sandstone_slab" => {
                let mut block_state = CutSandstoneSlabState::default();
                if let Some(prop) = props.get("typed") {
                    block_state.with_typed(SlabType::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::CutSandstoneSlab(block_state)
            }
            "petrified_oak_slab" => {
                let mut block_state = PetrifiedOakSlabState::default();
                if let Some(prop) = props.get("typed") {
                    block_state.with_typed(SlabType::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::PetrifiedOakSlab(block_state)
            }
            "cobblestone_slab" => {
                let mut block_state = CobblestoneSlabState::default();
                if let Some(prop) = props.get("typed") {
                    block_state.with_typed(SlabType::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::CobblestoneSlab(block_state)
            }
            "brick_slab" => {
                let mut block_state = BrickSlabState::default();
                if let Some(prop) = props.get("typed") {
                    block_state.with_typed(SlabType::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::BrickSlab(block_state)
            }
            "stone_brick_slab" => {
                let mut block_state = StoneBrickSlabState::default();
                if let Some(prop) = props.get("typed") {
                    block_state.with_typed(SlabType::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::StoneBrickSlab(block_state)
            }
            "nether_brick_slab" => {
                let mut block_state = NetherBrickSlabState::default();
                if let Some(prop) = props.get("typed") {
                    block_state.with_typed(SlabType::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::NetherBrickSlab(block_state)
            }
            "quartz_slab" => {
                let mut block_state = QuartzSlabState::default();
                if let Some(prop) = props.get("typed") {
                    block_state.with_typed(SlabType::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::QuartzSlab(block_state)
            }
            "red_sandstone_slab" => {
                let mut block_state = RedSandstoneSlabState::default();
                if let Some(prop) = props.get("typed") {
                    block_state.with_typed(SlabType::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::RedSandstoneSlab(block_state)
            }
            "cut_red_sandstone_slab" => {
                let mut block_state = CutRedSandstoneSlabState::default();
                if let Some(prop) = props.get("typed") {
                    block_state.with_typed(SlabType::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::CutRedSandstoneSlab(block_state)
            }
            "purpur_slab" => {
                let mut block_state = PurpurSlabState::default();
                if let Some(prop) = props.get("typed") {
                    block_state.with_typed(SlabType::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::PurpurSlab(block_state)
            }
            "smooth_stone" => Blocks::SmoothStone,
            "smooth_sandstone" => Blocks::SmoothSandstone,
            "smooth_quartz" => Blocks::SmoothQuartz,
            "smooth_red_sandstone" => Blocks::SmoothRedSandstone,
            "spruce_fence_gate" => {
                let mut block_state = SpruceFenceGateState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("in_wall") {
                    block_state.with_in_wall(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("open") {
                    block_state.with_open(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("powered") {
                    block_state.with_powered(bool::from_str(prop)?);
                }
                Blocks::SpruceFenceGate(block_state)
            }
            "birch_fence_gate" => {
                let mut block_state = BirchFenceGateState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("in_wall") {
                    block_state.with_in_wall(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("open") {
                    block_state.with_open(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("powered") {
                    block_state.with_powered(bool::from_str(prop)?);
                }
                Blocks::BirchFenceGate(block_state)
            }
            "jungle_fence_gate" => {
                let mut block_state = JungleFenceGateState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("in_wall") {
                    block_state.with_in_wall(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("open") {
                    block_state.with_open(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("powered") {
                    block_state.with_powered(bool::from_str(prop)?);
                }
                Blocks::JungleFenceGate(block_state)
            }
            "acacia_fence_gate" => {
                let mut block_state = AcaciaFenceGateState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("in_wall") {
                    block_state.with_in_wall(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("open") {
                    block_state.with_open(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("powered") {
                    block_state.with_powered(bool::from_str(prop)?);
                }
                Blocks::AcaciaFenceGate(block_state)
            }
            "dark_oak_fence_gate" => {
                let mut block_state = DarkOakFenceGateState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("in_wall") {
                    block_state.with_in_wall(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("open") {
                    block_state.with_open(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("powered") {
                    block_state.with_powered(bool::from_str(prop)?);
                }
                Blocks::DarkOakFenceGate(block_state)
            }
            "spruce_fence" => {
                let mut block_state = SpruceFenceState::default();
                if let Some(prop) = props.get("east") {
                    block_state.with_east(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("north") {
                    block_state.with_north(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("south") {
                    block_state.with_south(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("west") {
                    block_state.with_west(bool::from_str(prop)?);
                }
                Blocks::SpruceFence(block_state)
            }
            "birch_fence" => {
                let mut block_state = BirchFenceState::default();
                if let Some(prop) = props.get("east") {
                    block_state.with_east(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("north") {
                    block_state.with_north(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("south") {
                    block_state.with_south(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("west") {
                    block_state.with_west(bool::from_str(prop)?);
                }
                Blocks::BirchFence(block_state)
            }
            "jungle_fence" => {
                let mut block_state = JungleFenceState::default();
                if let Some(prop) = props.get("east") {
                    block_state.with_east(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("north") {
                    block_state.with_north(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("south") {
                    block_state.with_south(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("west") {
                    block_state.with_west(bool::from_str(prop)?);
                }
                Blocks::JungleFence(block_state)
            }
            "acacia_fence" => {
                let mut block_state = AcaciaFenceState::default();
                if let Some(prop) = props.get("east") {
                    block_state.with_east(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("north") {
                    block_state.with_north(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("south") {
                    block_state.with_south(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("west") {
                    block_state.with_west(bool::from_str(prop)?);
                }
                Blocks::AcaciaFence(block_state)
            }
            "dark_oak_fence" => {
                let mut block_state = DarkOakFenceState::default();
                if let Some(prop) = props.get("east") {
                    block_state.with_east(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("north") {
                    block_state.with_north(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("south") {
                    block_state.with_south(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("west") {
                    block_state.with_west(bool::from_str(prop)?);
                }
                Blocks::DarkOakFence(block_state)
            }
            "spruce_door" => {
                let mut block_state = SpruceDoorState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("half") {
                    block_state.with_half(DoubleBlockHalf::from_str(prop)?);
                }
                if let Some(prop) = props.get("hinge") {
                    block_state.with_hinge(Hinge::from_str(prop)?);
                }
                if let Some(prop) = props.get("open") {
                    block_state.with_open(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("powered") {
                    block_state.with_powered(bool::from_str(prop)?);
                }
                Blocks::SpruceDoor(block_state)
            }
            "birch_door" => {
                let mut block_state = BirchDoorState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("half") {
                    block_state.with_half(DoubleBlockHalf::from_str(prop)?);
                }
                if let Some(prop) = props.get("hinge") {
                    block_state.with_hinge(Hinge::from_str(prop)?);
                }
                if let Some(prop) = props.get("open") {
                    block_state.with_open(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("powered") {
                    block_state.with_powered(bool::from_str(prop)?);
                }
                Blocks::BirchDoor(block_state)
            }
            "jungle_door" => {
                let mut block_state = JungleDoorState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("half") {
                    block_state.with_half(DoubleBlockHalf::from_str(prop)?);
                }
                if let Some(prop) = props.get("hinge") {
                    block_state.with_hinge(Hinge::from_str(prop)?);
                }
                if let Some(prop) = props.get("open") {
                    block_state.with_open(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("powered") {
                    block_state.with_powered(bool::from_str(prop)?);
                }
                Blocks::JungleDoor(block_state)
            }
            "acacia_door" => {
                let mut block_state = AcaciaDoorState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("half") {
                    block_state.with_half(DoubleBlockHalf::from_str(prop)?);
                }
                if let Some(prop) = props.get("hinge") {
                    block_state.with_hinge(Hinge::from_str(prop)?);
                }
                if let Some(prop) = props.get("open") {
                    block_state.with_open(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("powered") {
                    block_state.with_powered(bool::from_str(prop)?);
                }
                Blocks::AcaciaDoor(block_state)
            }
            "dark_oak_door" => {
                let mut block_state = DarkOakDoorState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("half") {
                    block_state.with_half(DoubleBlockHalf::from_str(prop)?);
                }
                if let Some(prop) = props.get("hinge") {
                    block_state.with_hinge(Hinge::from_str(prop)?);
                }
                if let Some(prop) = props.get("open") {
                    block_state.with_open(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("powered") {
                    block_state.with_powered(bool::from_str(prop)?);
                }
                Blocks::DarkOakDoor(block_state)
            }
            "end_rod" => {
                let mut block_state = EndRodState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(AllFacing::from_str(prop)?);
                }
                Blocks::EndRod(block_state)
            }
            "chorus_plant" => {
                let mut block_state = ChorusPlantState::default();
                if let Some(prop) = props.get("down") {
                    block_state.with_down(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("east") {
                    block_state.with_east(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("north") {
                    block_state.with_north(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("south") {
                    block_state.with_south(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("up") {
                    block_state.with_up(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("west") {
                    block_state.with_west(bool::from_str(prop)?);
                }
                Blocks::ChorusPlant(block_state)
            }
            "chorus_flower" => {
                let mut block_state = ChorusFlowerState::default();
                if let Some(prop) = props.get("age") {
                    block_state.with_age(i32::from_str(prop)?);
                }
                Blocks::ChorusFlower(block_state)
            }
            "purpur_block" => Blocks::PurpurBlock,
            "purpur_pillar" => {
                let mut block_state = PurpurPillarState::default();
                if let Some(prop) = props.get("axis") {
                    block_state.with_axis(Axis::from_str(prop)?);
                }
                Blocks::PurpurPillar(block_state)
            }
            "purpur_stairs" => {
                let mut block_state = PurpurStairsState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("half") {
                    block_state.with_half(SingleBlockHalf::from_str(prop)?);
                }
                if let Some(prop) = props.get("shape") {
                    block_state.with_shape(StairShape::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::PurpurStairs(block_state)
            }
            "end_stone_bricks" => Blocks::EndStoneBricks,
            "beetroots" => {
                let mut block_state = BeetrootsState::default();
                if let Some(prop) = props.get("age") {
                    block_state.with_age(i32::from_str(prop)?);
                }
                Blocks::Beetroots(block_state)
            }
            "dirt_path" => Blocks::DirtPath,
            "end_gateway" => Blocks::EndGateway,
            "repeating_command_block" => {
                let mut block_state = RepeatingCommandBlockState::default();
                if let Some(prop) = props.get("conditional") {
                    block_state.with_conditional(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(AllFacing::from_str(prop)?);
                }
                Blocks::RepeatingCommandBlock(block_state)
            }
            "chain_command_block" => {
                let mut block_state = ChainCommandBlockState::default();
                if let Some(prop) = props.get("conditional") {
                    block_state.with_conditional(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(AllFacing::from_str(prop)?);
                }
                Blocks::ChainCommandBlock(block_state)
            }
            "frosted_ice" => {
                let mut block_state = FrostedIceState::default();
                if let Some(prop) = props.get("age") {
                    block_state.with_age(i32::from_str(prop)?);
                }
                Blocks::FrostedIce(block_state)
            }
            "magma_block" => Blocks::MagmaBlock,
            "nether_wart_block" => Blocks::NetherWartBlock,
            "red_nether_bricks" => Blocks::RedNetherBricks,
            "bone_block" => {
                let mut block_state = BoneBlockState::default();
                if let Some(prop) = props.get("axis") {
                    block_state.with_axis(Axis::from_str(prop)?);
                }
                Blocks::BoneBlock(block_state)
            }
            "structure_void" => Blocks::StructureVoid,
            "observer" => {
                let mut block_state = ObserverState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(AllFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("powered") {
                    block_state.with_powered(bool::from_str(prop)?);
                }
                Blocks::Observer(block_state)
            }
            "shulker_box" => {
                let mut block_state = ShulkerBoxState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(AllFacing::from_str(prop)?);
                }
                Blocks::ShulkerBox(block_state)
            }
            "white_shulker_box" => {
                let mut block_state = WhiteShulkerBoxState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(AllFacing::from_str(prop)?);
                }
                Blocks::WhiteShulkerBox(block_state)
            }
            "orange_shulker_box" => {
                let mut block_state = OrangeShulkerBoxState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(AllFacing::from_str(prop)?);
                }
                Blocks::OrangeShulkerBox(block_state)
            }
            "magenta_shulker_box" => {
                let mut block_state = MagentaShulkerBoxState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(AllFacing::from_str(prop)?);
                }
                Blocks::MagentaShulkerBox(block_state)
            }
            "light_blue_shulker_box" => {
                let mut block_state = LightBlueShulkerBoxState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(AllFacing::from_str(prop)?);
                }
                Blocks::LightBlueShulkerBox(block_state)
            }
            "yellow_shulker_box" => {
                let mut block_state = YellowShulkerBoxState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(AllFacing::from_str(prop)?);
                }
                Blocks::YellowShulkerBox(block_state)
            }
            "lime_shulker_box" => {
                let mut block_state = LimeShulkerBoxState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(AllFacing::from_str(prop)?);
                }
                Blocks::LimeShulkerBox(block_state)
            }
            "pink_shulker_box" => {
                let mut block_state = PinkShulkerBoxState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(AllFacing::from_str(prop)?);
                }
                Blocks::PinkShulkerBox(block_state)
            }
            "gray_shulker_box" => {
                let mut block_state = GrayShulkerBoxState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(AllFacing::from_str(prop)?);
                }
                Blocks::GrayShulkerBox(block_state)
            }
            "light_gray_shulker_box" => {
                let mut block_state = LightGrayShulkerBoxState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(AllFacing::from_str(prop)?);
                }
                Blocks::LightGrayShulkerBox(block_state)
            }
            "cyan_shulker_box" => {
                let mut block_state = CyanShulkerBoxState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(AllFacing::from_str(prop)?);
                }
                Blocks::CyanShulkerBox(block_state)
            }
            "purple_shulker_box" => {
                let mut block_state = PurpleShulkerBoxState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(AllFacing::from_str(prop)?);
                }
                Blocks::PurpleShulkerBox(block_state)
            }
            "blue_shulker_box" => {
                let mut block_state = BlueShulkerBoxState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(AllFacing::from_str(prop)?);
                }
                Blocks::BlueShulkerBox(block_state)
            }
            "brown_shulker_box" => {
                let mut block_state = BrownShulkerBoxState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(AllFacing::from_str(prop)?);
                }
                Blocks::BrownShulkerBox(block_state)
            }
            "green_shulker_box" => {
                let mut block_state = GreenShulkerBoxState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(AllFacing::from_str(prop)?);
                }
                Blocks::GreenShulkerBox(block_state)
            }
            "red_shulker_box" => {
                let mut block_state = RedShulkerBoxState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(AllFacing::from_str(prop)?);
                }
                Blocks::RedShulkerBox(block_state)
            }
            "black_shulker_box" => {
                let mut block_state = BlackShulkerBoxState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(AllFacing::from_str(prop)?);
                }
                Blocks::BlackShulkerBox(block_state)
            }
            "white_glazed_terracotta" => {
                let mut block_state = WhiteGlazedTerracottaState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                Blocks::WhiteGlazedTerracotta(block_state)
            }
            "orange_glazed_terracotta" => {
                let mut block_state = OrangeGlazedTerracottaState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                Blocks::OrangeGlazedTerracotta(block_state)
            }
            "magenta_glazed_terracotta" => {
                let mut block_state = MagentaGlazedTerracottaState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                Blocks::MagentaGlazedTerracotta(block_state)
            }
            "light_blue_glazed_terracotta" => {
                let mut block_state = LightBlueGlazedTerracottaState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                Blocks::LightBlueGlazedTerracotta(block_state)
            }
            "yellow_glazed_terracotta" => {
                let mut block_state = YellowGlazedTerracottaState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                Blocks::YellowGlazedTerracotta(block_state)
            }
            "lime_glazed_terracotta" => {
                let mut block_state = LimeGlazedTerracottaState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                Blocks::LimeGlazedTerracotta(block_state)
            }
            "pink_glazed_terracotta" => {
                let mut block_state = PinkGlazedTerracottaState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                Blocks::PinkGlazedTerracotta(block_state)
            }
            "gray_glazed_terracotta" => {
                let mut block_state = GrayGlazedTerracottaState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                Blocks::GrayGlazedTerracotta(block_state)
            }
            "light_gray_glazed_terracotta" => {
                let mut block_state = LightGrayGlazedTerracottaState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                Blocks::LightGrayGlazedTerracotta(block_state)
            }
            "cyan_glazed_terracotta" => {
                let mut block_state = CyanGlazedTerracottaState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                Blocks::CyanGlazedTerracotta(block_state)
            }
            "purple_glazed_terracotta" => {
                let mut block_state = PurpleGlazedTerracottaState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                Blocks::PurpleGlazedTerracotta(block_state)
            }
            "blue_glazed_terracotta" => {
                let mut block_state = BlueGlazedTerracottaState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                Blocks::BlueGlazedTerracotta(block_state)
            }
            "brown_glazed_terracotta" => {
                let mut block_state = BrownGlazedTerracottaState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                Blocks::BrownGlazedTerracotta(block_state)
            }
            "green_glazed_terracotta" => {
                let mut block_state = GreenGlazedTerracottaState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                Blocks::GreenGlazedTerracotta(block_state)
            }
            "red_glazed_terracotta" => {
                let mut block_state = RedGlazedTerracottaState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                Blocks::RedGlazedTerracotta(block_state)
            }
            "black_glazed_terracotta" => {
                let mut block_state = BlackGlazedTerracottaState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                Blocks::BlackGlazedTerracotta(block_state)
            }
            "white_concrete" => Blocks::WhiteConcrete,
            "orange_concrete" => Blocks::OrangeConcrete,
            "magenta_concrete" => Blocks::MagentaConcrete,
            "light_blue_concrete" => Blocks::LightBlueConcrete,
            "yellow_concrete" => Blocks::YellowConcrete,
            "lime_concrete" => Blocks::LimeConcrete,
            "pink_concrete" => Blocks::PinkConcrete,
            "gray_concrete" => Blocks::GrayConcrete,
            "light_gray_concrete" => Blocks::LightGrayConcrete,
            "cyan_concrete" => Blocks::CyanConcrete,
            "purple_concrete" => Blocks::PurpleConcrete,
            "blue_concrete" => Blocks::BlueConcrete,
            "brown_concrete" => Blocks::BrownConcrete,
            "green_concrete" => Blocks::GreenConcrete,
            "red_concrete" => Blocks::RedConcrete,
            "black_concrete" => Blocks::BlackConcrete,
            "white_concrete_powder" => Blocks::WhiteConcretePowder,
            "orange_concrete_powder" => Blocks::OrangeConcretePowder,
            "magenta_concrete_powder" => Blocks::MagentaConcretePowder,
            "light_blue_concrete_powder" => Blocks::LightBlueConcretePowder,
            "yellow_concrete_powder" => Blocks::YellowConcretePowder,
            "lime_concrete_powder" => Blocks::LimeConcretePowder,
            "pink_concrete_powder" => Blocks::PinkConcretePowder,
            "gray_concrete_powder" => Blocks::GrayConcretePowder,
            "light_gray_concrete_powder" => Blocks::LightGrayConcretePowder,
            "cyan_concrete_powder" => Blocks::CyanConcretePowder,
            "purple_concrete_powder" => Blocks::PurpleConcretePowder,
            "blue_concrete_powder" => Blocks::BlueConcretePowder,
            "brown_concrete_powder" => Blocks::BrownConcretePowder,
            "green_concrete_powder" => Blocks::GreenConcretePowder,
            "red_concrete_powder" => Blocks::RedConcretePowder,
            "black_concrete_powder" => Blocks::BlackConcretePowder,
            "kelp" => {
                let mut block_state = KelpState::default();
                if let Some(prop) = props.get("age") {
                    block_state.with_age(i32::from_str(prop)?);
                }
                Blocks::Kelp(block_state)
            }
            "kelp_plant" => Blocks::KelpPlant,
            "dried_kelp_block" => Blocks::DriedKelpBlock,
            "turtle_egg" => {
                let mut block_state = TurtleEggState::default();
                if let Some(prop) = props.get("eggs") {
                    block_state.with_eggs(i32::from_str(prop)?);
                }
                if let Some(prop) = props.get("hatch") {
                    block_state.with_hatch(i32::from_str(prop)?);
                }
                Blocks::TurtleEgg(block_state)
            }
            "dead_tube_coral_block" => Blocks::DeadTubeCoralBlock,
            "dead_brain_coral_block" => Blocks::DeadBrainCoralBlock,
            "dead_bubble_coral_block" => Blocks::DeadBubbleCoralBlock,
            "dead_fire_coral_block" => Blocks::DeadFireCoralBlock,
            "dead_horn_coral_block" => Blocks::DeadHornCoralBlock,
            "tube_coral_block" => Blocks::TubeCoralBlock,
            "brain_coral_block" => Blocks::BrainCoralBlock,
            "bubble_coral_block" => Blocks::BubbleCoralBlock,
            "fire_coral_block" => Blocks::FireCoralBlock,
            "horn_coral_block" => Blocks::HornCoralBlock,
            "dead_tube_coral" => {
                let mut block_state = DeadTubeCoralState::default();
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::DeadTubeCoral(block_state)
            }
            "dead_brain_coral" => {
                let mut block_state = DeadBrainCoralState::default();
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::DeadBrainCoral(block_state)
            }
            "dead_bubble_coral" => {
                let mut block_state = DeadBubbleCoralState::default();
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::DeadBubbleCoral(block_state)
            }
            "dead_fire_coral" => {
                let mut block_state = DeadFireCoralState::default();
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::DeadFireCoral(block_state)
            }
            "dead_horn_coral" => {
                let mut block_state = DeadHornCoralState::default();
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::DeadHornCoral(block_state)
            }
            "tube_coral" => {
                let mut block_state = TubeCoralState::default();
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::TubeCoral(block_state)
            }
            "brain_coral" => {
                let mut block_state = BrainCoralState::default();
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::BrainCoral(block_state)
            }
            "bubble_coral" => {
                let mut block_state = BubbleCoralState::default();
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::BubbleCoral(block_state)
            }
            "fire_coral" => {
                let mut block_state = FireCoralState::default();
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::FireCoral(block_state)
            }
            "horn_coral" => {
                let mut block_state = HornCoralState::default();
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::HornCoral(block_state)
            }
            "dead_tube_coral_fan" => {
                let mut block_state = DeadTubeCoralFanState::default();
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::DeadTubeCoralFan(block_state)
            }
            "dead_brain_coral_fan" => {
                let mut block_state = DeadBrainCoralFanState::default();
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::DeadBrainCoralFan(block_state)
            }
            "dead_bubble_coral_fan" => {
                let mut block_state = DeadBubbleCoralFanState::default();
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::DeadBubbleCoralFan(block_state)
            }
            "dead_fire_coral_fan" => {
                let mut block_state = DeadFireCoralFanState::default();
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::DeadFireCoralFan(block_state)
            }
            "dead_horn_coral_fan" => {
                let mut block_state = DeadHornCoralFanState::default();
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::DeadHornCoralFan(block_state)
            }
            "tube_coral_fan" => {
                let mut block_state = TubeCoralFanState::default();
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::TubeCoralFan(block_state)
            }
            "brain_coral_fan" => {
                let mut block_state = BrainCoralFanState::default();
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::BrainCoralFan(block_state)
            }
            "bubble_coral_fan" => {
                let mut block_state = BubbleCoralFanState::default();
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::BubbleCoralFan(block_state)
            }
            "fire_coral_fan" => {
                let mut block_state = FireCoralFanState::default();
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::FireCoralFan(block_state)
            }
            "horn_coral_fan" => {
                let mut block_state = HornCoralFanState::default();
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::HornCoralFan(block_state)
            }
            "dead_tube_coral_wall_fan" => {
                let mut block_state = DeadTubeCoralWallFanState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::DeadTubeCoralWallFan(block_state)
            }
            "dead_brain_coral_wall_fan" => {
                let mut block_state = DeadBrainCoralWallFanState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::DeadBrainCoralWallFan(block_state)
            }
            "dead_bubble_coral_wall_fan" => {
                let mut block_state = DeadBubbleCoralWallFanState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::DeadBubbleCoralWallFan(block_state)
            }
            "dead_fire_coral_wall_fan" => {
                let mut block_state = DeadFireCoralWallFanState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::DeadFireCoralWallFan(block_state)
            }
            "dead_horn_coral_wall_fan" => {
                let mut block_state = DeadHornCoralWallFanState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::DeadHornCoralWallFan(block_state)
            }
            "tube_coral_wall_fan" => {
                let mut block_state = TubeCoralWallFanState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::TubeCoralWallFan(block_state)
            }
            "brain_coral_wall_fan" => {
                let mut block_state = BrainCoralWallFanState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::BrainCoralWallFan(block_state)
            }
            "bubble_coral_wall_fan" => {
                let mut block_state = BubbleCoralWallFanState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::BubbleCoralWallFan(block_state)
            }
            "fire_coral_wall_fan" => {
                let mut block_state = FireCoralWallFanState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::FireCoralWallFan(block_state)
            }
            "horn_coral_wall_fan" => {
                let mut block_state = HornCoralWallFanState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::HornCoralWallFan(block_state)
            }
            "sea_pickle" => {
                let mut block_state = SeaPickleState::default();
                if let Some(prop) = props.get("pickles") {
                    block_state.with_pickles(i32::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::SeaPickle(block_state)
            }
            "blue_ice" => Blocks::BlueIce,
            "conduit" => {
                let mut block_state = ConduitState::default();
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::Conduit(block_state)
            }
            "bamboo_sapling" => Blocks::BambooSapling,
            "bamboo" => {
                let mut block_state = BambooState::default();
                if let Some(prop) = props.get("age") {
                    block_state.with_age(i32::from_str(prop)?);
                }
                if let Some(prop) = props.get("leaves") {
                    block_state.with_leaves(Leaves::from_str(prop)?);
                }
                if let Some(prop) = props.get("stage") {
                    block_state.with_stage(i32::from_str(prop)?);
                }
                Blocks::Bamboo(block_state)
            }
            "potted_bamboo" => Blocks::PottedBamboo,
            "void_air" => Blocks::VoidAir,
            "cave_air" => Blocks::CaveAir,
            "bubble_column" => {
                let mut block_state = BubbleColumnState::default();
                if let Some(prop) = props.get("drag") {
                    block_state.with_drag(bool::from_str(prop)?);
                }
                Blocks::BubbleColumn(block_state)
            }
            "polished_granite_stairs" => {
                let mut block_state = PolishedGraniteStairsState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("half") {
                    block_state.with_half(SingleBlockHalf::from_str(prop)?);
                }
                if let Some(prop) = props.get("shape") {
                    block_state.with_shape(StairShape::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::PolishedGraniteStairs(block_state)
            }
            "smooth_red_sandstone_stairs" => {
                let mut block_state = SmoothRedSandstoneStairsState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("half") {
                    block_state.with_half(SingleBlockHalf::from_str(prop)?);
                }
                if let Some(prop) = props.get("shape") {
                    block_state.with_shape(StairShape::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::SmoothRedSandstoneStairs(block_state)
            }
            "mossy_stone_brick_stairs" => {
                let mut block_state = MossyStoneBrickStairsState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("half") {
                    block_state.with_half(SingleBlockHalf::from_str(prop)?);
                }
                if let Some(prop) = props.get("shape") {
                    block_state.with_shape(StairShape::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::MossyStoneBrickStairs(block_state)
            }
            "polished_diorite_stairs" => {
                let mut block_state = PolishedDioriteStairsState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("half") {
                    block_state.with_half(SingleBlockHalf::from_str(prop)?);
                }
                if let Some(prop) = props.get("shape") {
                    block_state.with_shape(StairShape::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::PolishedDioriteStairs(block_state)
            }
            "mossy_cobblestone_stairs" => {
                let mut block_state = MossyCobblestoneStairsState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("half") {
                    block_state.with_half(SingleBlockHalf::from_str(prop)?);
                }
                if let Some(prop) = props.get("shape") {
                    block_state.with_shape(StairShape::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::MossyCobblestoneStairs(block_state)
            }
            "end_stone_brick_stairs" => {
                let mut block_state = EndStoneBrickStairsState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("half") {
                    block_state.with_half(SingleBlockHalf::from_str(prop)?);
                }
                if let Some(prop) = props.get("shape") {
                    block_state.with_shape(StairShape::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::EndStoneBrickStairs(block_state)
            }
            "stone_stairs" => {
                let mut block_state = StoneStairsState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("half") {
                    block_state.with_half(SingleBlockHalf::from_str(prop)?);
                }
                if let Some(prop) = props.get("shape") {
                    block_state.with_shape(StairShape::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::StoneStairs(block_state)
            }
            "smooth_sandstone_stairs" => {
                let mut block_state = SmoothSandstoneStairsState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("half") {
                    block_state.with_half(SingleBlockHalf::from_str(prop)?);
                }
                if let Some(prop) = props.get("shape") {
                    block_state.with_shape(StairShape::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::SmoothSandstoneStairs(block_state)
            }
            "smooth_quartz_stairs" => {
                let mut block_state = SmoothQuartzStairsState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("half") {
                    block_state.with_half(SingleBlockHalf::from_str(prop)?);
                }
                if let Some(prop) = props.get("shape") {
                    block_state.with_shape(StairShape::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::SmoothQuartzStairs(block_state)
            }
            "granite_stairs" => {
                let mut block_state = GraniteStairsState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("half") {
                    block_state.with_half(SingleBlockHalf::from_str(prop)?);
                }
                if let Some(prop) = props.get("shape") {
                    block_state.with_shape(StairShape::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::GraniteStairs(block_state)
            }
            "andesite_stairs" => {
                let mut block_state = AndesiteStairsState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("half") {
                    block_state.with_half(SingleBlockHalf::from_str(prop)?);
                }
                if let Some(prop) = props.get("shape") {
                    block_state.with_shape(StairShape::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::AndesiteStairs(block_state)
            }
            "red_nether_brick_stairs" => {
                let mut block_state = RedNetherBrickStairsState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("half") {
                    block_state.with_half(SingleBlockHalf::from_str(prop)?);
                }
                if let Some(prop) = props.get("shape") {
                    block_state.with_shape(StairShape::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::RedNetherBrickStairs(block_state)
            }
            "polished_andesite_stairs" => {
                let mut block_state = PolishedAndesiteStairsState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("half") {
                    block_state.with_half(SingleBlockHalf::from_str(prop)?);
                }
                if let Some(prop) = props.get("shape") {
                    block_state.with_shape(StairShape::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::PolishedAndesiteStairs(block_state)
            }
            "diorite_stairs" => {
                let mut block_state = DioriteStairsState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("half") {
                    block_state.with_half(SingleBlockHalf::from_str(prop)?);
                }
                if let Some(prop) = props.get("shape") {
                    block_state.with_shape(StairShape::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::DioriteStairs(block_state)
            }
            "polished_granite_slab" => {
                let mut block_state = PolishedGraniteSlabState::default();
                if let Some(prop) = props.get("typed") {
                    block_state.with_typed(SlabType::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::PolishedGraniteSlab(block_state)
            }
            "smooth_red_sandstone_slab" => {
                let mut block_state = SmoothRedSandstoneSlabState::default();
                if let Some(prop) = props.get("typed") {
                    block_state.with_typed(SlabType::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::SmoothRedSandstoneSlab(block_state)
            }
            "mossy_stone_brick_slab" => {
                let mut block_state = MossyStoneBrickSlabState::default();
                if let Some(prop) = props.get("typed") {
                    block_state.with_typed(SlabType::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::MossyStoneBrickSlab(block_state)
            }
            "polished_diorite_slab" => {
                let mut block_state = PolishedDioriteSlabState::default();
                if let Some(prop) = props.get("typed") {
                    block_state.with_typed(SlabType::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::PolishedDioriteSlab(block_state)
            }
            "mossy_cobblestone_slab" => {
                let mut block_state = MossyCobblestoneSlabState::default();
                if let Some(prop) = props.get("typed") {
                    block_state.with_typed(SlabType::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::MossyCobblestoneSlab(block_state)
            }
            "end_stone_brick_slab" => {
                let mut block_state = EndStoneBrickSlabState::default();
                if let Some(prop) = props.get("typed") {
                    block_state.with_typed(SlabType::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::EndStoneBrickSlab(block_state)
            }
            "smooth_sandstone_slab" => {
                let mut block_state = SmoothSandstoneSlabState::default();
                if let Some(prop) = props.get("typed") {
                    block_state.with_typed(SlabType::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::SmoothSandstoneSlab(block_state)
            }
            "smooth_quartz_slab" => {
                let mut block_state = SmoothQuartzSlabState::default();
                if let Some(prop) = props.get("typed") {
                    block_state.with_typed(SlabType::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::SmoothQuartzSlab(block_state)
            }
            "granite_slab" => {
                let mut block_state = GraniteSlabState::default();
                if let Some(prop) = props.get("typed") {
                    block_state.with_typed(SlabType::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::GraniteSlab(block_state)
            }
            "andesite_slab" => {
                let mut block_state = AndesiteSlabState::default();
                if let Some(prop) = props.get("typed") {
                    block_state.with_typed(SlabType::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::AndesiteSlab(block_state)
            }
            "red_nether_brick_slab" => {
                let mut block_state = RedNetherBrickSlabState::default();
                if let Some(prop) = props.get("typed") {
                    block_state.with_typed(SlabType::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::RedNetherBrickSlab(block_state)
            }
            "polished_andesite_slab" => {
                let mut block_state = PolishedAndesiteSlabState::default();
                if let Some(prop) = props.get("typed") {
                    block_state.with_typed(SlabType::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::PolishedAndesiteSlab(block_state)
            }
            "diorite_slab" => {
                let mut block_state = DioriteSlabState::default();
                if let Some(prop) = props.get("typed") {
                    block_state.with_typed(SlabType::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::DioriteSlab(block_state)
            }
            "brick_wall" => {
                let mut block_state = BrickWallState::default();
                if let Some(prop) = props.get("east") {
                    block_state.with_east(WallType::from_str(prop)?);
                }
                if let Some(prop) = props.get("north") {
                    block_state.with_north(WallType::from_str(prop)?);
                }
                if let Some(prop) = props.get("south") {
                    block_state.with_south(WallType::from_str(prop)?);
                }
                if let Some(prop) = props.get("up") {
                    block_state.with_up(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("west") {
                    block_state.with_west(WallType::from_str(prop)?);
                }
                Blocks::BrickWall(block_state)
            }
            "prismarine_wall" => {
                let mut block_state = PrismarineWallState::default();
                if let Some(prop) = props.get("east") {
                    block_state.with_east(WallType::from_str(prop)?);
                }
                if let Some(prop) = props.get("north") {
                    block_state.with_north(WallType::from_str(prop)?);
                }
                if let Some(prop) = props.get("south") {
                    block_state.with_south(WallType::from_str(prop)?);
                }
                if let Some(prop) = props.get("up") {
                    block_state.with_up(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("west") {
                    block_state.with_west(WallType::from_str(prop)?);
                }
                Blocks::PrismarineWall(block_state)
            }
            "red_sandstone_wall" => {
                let mut block_state = RedSandstoneWallState::default();
                if let Some(prop) = props.get("east") {
                    block_state.with_east(WallType::from_str(prop)?);
                }
                if let Some(prop) = props.get("north") {
                    block_state.with_north(WallType::from_str(prop)?);
                }
                if let Some(prop) = props.get("south") {
                    block_state.with_south(WallType::from_str(prop)?);
                }
                if let Some(prop) = props.get("up") {
                    block_state.with_up(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("west") {
                    block_state.with_west(WallType::from_str(prop)?);
                }
                Blocks::RedSandstoneWall(block_state)
            }
            "mossy_stone_brick_wall" => {
                let mut block_state = MossyStoneBrickWallState::default();
                if let Some(prop) = props.get("east") {
                    block_state.with_east(WallType::from_str(prop)?);
                }
                if let Some(prop) = props.get("north") {
                    block_state.with_north(WallType::from_str(prop)?);
                }
                if let Some(prop) = props.get("south") {
                    block_state.with_south(WallType::from_str(prop)?);
                }
                if let Some(prop) = props.get("up") {
                    block_state.with_up(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("west") {
                    block_state.with_west(WallType::from_str(prop)?);
                }
                Blocks::MossyStoneBrickWall(block_state)
            }
            "granite_wall" => {
                let mut block_state = GraniteWallState::default();
                if let Some(prop) = props.get("east") {
                    block_state.with_east(WallType::from_str(prop)?);
                }
                if let Some(prop) = props.get("north") {
                    block_state.with_north(WallType::from_str(prop)?);
                }
                if let Some(prop) = props.get("south") {
                    block_state.with_south(WallType::from_str(prop)?);
                }
                if let Some(prop) = props.get("up") {
                    block_state.with_up(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("west") {
                    block_state.with_west(WallType::from_str(prop)?);
                }
                Blocks::GraniteWall(block_state)
            }
            "stone_brick_wall" => {
                let mut block_state = StoneBrickWallState::default();
                if let Some(prop) = props.get("east") {
                    block_state.with_east(WallType::from_str(prop)?);
                }
                if let Some(prop) = props.get("north") {
                    block_state.with_north(WallType::from_str(prop)?);
                }
                if let Some(prop) = props.get("south") {
                    block_state.with_south(WallType::from_str(prop)?);
                }
                if let Some(prop) = props.get("up") {
                    block_state.with_up(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("west") {
                    block_state.with_west(WallType::from_str(prop)?);
                }
                Blocks::StoneBrickWall(block_state)
            }
            "nether_brick_wall" => {
                let mut block_state = NetherBrickWallState::default();
                if let Some(prop) = props.get("east") {
                    block_state.with_east(WallType::from_str(prop)?);
                }
                if let Some(prop) = props.get("north") {
                    block_state.with_north(WallType::from_str(prop)?);
                }
                if let Some(prop) = props.get("south") {
                    block_state.with_south(WallType::from_str(prop)?);
                }
                if let Some(prop) = props.get("up") {
                    block_state.with_up(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("west") {
                    block_state.with_west(WallType::from_str(prop)?);
                }
                Blocks::NetherBrickWall(block_state)
            }
            "andesite_wall" => {
                let mut block_state = AndesiteWallState::default();
                if let Some(prop) = props.get("east") {
                    block_state.with_east(WallType::from_str(prop)?);
                }
                if let Some(prop) = props.get("north") {
                    block_state.with_north(WallType::from_str(prop)?);
                }
                if let Some(prop) = props.get("south") {
                    block_state.with_south(WallType::from_str(prop)?);
                }
                if let Some(prop) = props.get("up") {
                    block_state.with_up(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("west") {
                    block_state.with_west(WallType::from_str(prop)?);
                }
                Blocks::AndesiteWall(block_state)
            }
            "red_nether_brick_wall" => {
                let mut block_state = RedNetherBrickWallState::default();
                if let Some(prop) = props.get("east") {
                    block_state.with_east(WallType::from_str(prop)?);
                }
                if let Some(prop) = props.get("north") {
                    block_state.with_north(WallType::from_str(prop)?);
                }
                if let Some(prop) = props.get("south") {
                    block_state.with_south(WallType::from_str(prop)?);
                }
                if let Some(prop) = props.get("up") {
                    block_state.with_up(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("west") {
                    block_state.with_west(WallType::from_str(prop)?);
                }
                Blocks::RedNetherBrickWall(block_state)
            }
            "sandstone_wall" => {
                let mut block_state = SandstoneWallState::default();
                if let Some(prop) = props.get("east") {
                    block_state.with_east(WallType::from_str(prop)?);
                }
                if let Some(prop) = props.get("north") {
                    block_state.with_north(WallType::from_str(prop)?);
                }
                if let Some(prop) = props.get("south") {
                    block_state.with_south(WallType::from_str(prop)?);
                }
                if let Some(prop) = props.get("up") {
                    block_state.with_up(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("west") {
                    block_state.with_west(WallType::from_str(prop)?);
                }
                Blocks::SandstoneWall(block_state)
            }
            "end_stone_brick_wall" => {
                let mut block_state = EndStoneBrickWallState::default();
                if let Some(prop) = props.get("east") {
                    block_state.with_east(WallType::from_str(prop)?);
                }
                if let Some(prop) = props.get("north") {
                    block_state.with_north(WallType::from_str(prop)?);
                }
                if let Some(prop) = props.get("south") {
                    block_state.with_south(WallType::from_str(prop)?);
                }
                if let Some(prop) = props.get("up") {
                    block_state.with_up(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("west") {
                    block_state.with_west(WallType::from_str(prop)?);
                }
                Blocks::EndStoneBrickWall(block_state)
            }
            "diorite_wall" => {
                let mut block_state = DioriteWallState::default();
                if let Some(prop) = props.get("east") {
                    block_state.with_east(WallType::from_str(prop)?);
                }
                if let Some(prop) = props.get("north") {
                    block_state.with_north(WallType::from_str(prop)?);
                }
                if let Some(prop) = props.get("south") {
                    block_state.with_south(WallType::from_str(prop)?);
                }
                if let Some(prop) = props.get("up") {
                    block_state.with_up(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("west") {
                    block_state.with_west(WallType::from_str(prop)?);
                }
                Blocks::DioriteWall(block_state)
            }
            "scaffolding" => {
                let mut block_state = ScaffoldingState::default();
                if let Some(prop) = props.get("bottom") {
                    block_state.with_bottom(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("distance") {
                    block_state.with_distance(i32::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::Scaffolding(block_state)
            }
            "loom" => {
                let mut block_state = LoomState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                Blocks::Loom(block_state)
            }
            "barrel" => {
                let mut block_state = BarrelState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(AllFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("open") {
                    block_state.with_open(bool::from_str(prop)?);
                }
                Blocks::Barrel(block_state)
            }
            "smoker" => {
                let mut block_state = SmokerState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("lit") {
                    block_state.with_lit(bool::from_str(prop)?);
                }
                Blocks::Smoker(block_state)
            }
            "blast_furnace" => {
                let mut block_state = BlastFurnaceState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("lit") {
                    block_state.with_lit(bool::from_str(prop)?);
                }
                Blocks::BlastFurnace(block_state)
            }
            "cartography_table" => Blocks::CartographyTable,
            "fletching_table" => Blocks::FletchingTable,
            "grindstone" => {
                let mut block_state = GrindstoneState::default();
                if let Some(prop) = props.get("face") {
                    block_state.with_face(Face::from_str(prop)?);
                }
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                Blocks::Grindstone(block_state)
            }
            "lectern" => {
                let mut block_state = LecternState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("has_book") {
                    block_state.with_has_book(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("powered") {
                    block_state.with_powered(bool::from_str(prop)?);
                }
                Blocks::Lectern(block_state)
            }
            "smithing_table" => Blocks::SmithingTable,
            "stonecutter" => {
                let mut block_state = StonecutterState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                Blocks::Stonecutter(block_state)
            }
            "bell" => {
                let mut block_state = BellState::default();
                if let Some(prop) = props.get("attachment") {
                    block_state.with_attachment(Attachment::from_str(prop)?);
                }
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("powered") {
                    block_state.with_powered(bool::from_str(prop)?);
                }
                Blocks::Bell(block_state)
            }
            "lantern" => {
                let mut block_state = LanternState::default();
                if let Some(prop) = props.get("hanging") {
                    block_state.with_hanging(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::Lantern(block_state)
            }
            "soul_lantern" => {
                let mut block_state = SoulLanternState::default();
                if let Some(prop) = props.get("hanging") {
                    block_state.with_hanging(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::SoulLantern(block_state)
            }
            "campfire" => {
                let mut block_state = CampfireState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("lit") {
                    block_state.with_lit(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("signal_fire") {
                    block_state.with_signal_fire(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::Campfire(block_state)
            }
            "soul_campfire" => {
                let mut block_state = SoulCampfireState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("lit") {
                    block_state.with_lit(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("signal_fire") {
                    block_state.with_signal_fire(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::SoulCampfire(block_state)
            }
            "sweet_berry_bush" => {
                let mut block_state = SweetBerryBushState::default();
                if let Some(prop) = props.get("age") {
                    block_state.with_age(i32::from_str(prop)?);
                }
                Blocks::SweetBerryBush(block_state)
            }
            "warped_stem" => {
                let mut block_state = WarpedStemState::default();
                if let Some(prop) = props.get("axis") {
                    block_state.with_axis(Axis::from_str(prop)?);
                }
                Blocks::WarpedStem(block_state)
            }
            "stripped_warped_stem" => {
                let mut block_state = StrippedWarpedStemState::default();
                if let Some(prop) = props.get("axis") {
                    block_state.with_axis(Axis::from_str(prop)?);
                }
                Blocks::StrippedWarpedStem(block_state)
            }
            "warped_hyphae" => {
                let mut block_state = WarpedHyphaeState::default();
                if let Some(prop) = props.get("axis") {
                    block_state.with_axis(Axis::from_str(prop)?);
                }
                Blocks::WarpedHyphae(block_state)
            }
            "stripped_warped_hyphae" => {
                let mut block_state = StrippedWarpedHyphaeState::default();
                if let Some(prop) = props.get("axis") {
                    block_state.with_axis(Axis::from_str(prop)?);
                }
                Blocks::StrippedWarpedHyphae(block_state)
            }
            "warped_nylium" => Blocks::WarpedNylium,
            "warped_fungus" => Blocks::WarpedFungus,
            "warped_wart_block" => Blocks::WarpedWartBlock,
            "warped_roots" => Blocks::WarpedRoots,
            "nether_sprouts" => Blocks::NetherSprouts,
            "crimson_stem" => {
                let mut block_state = CrimsonStemState::default();
                if let Some(prop) = props.get("axis") {
                    block_state.with_axis(Axis::from_str(prop)?);
                }
                Blocks::CrimsonStem(block_state)
            }
            "stripped_crimson_stem" => {
                let mut block_state = StrippedCrimsonStemState::default();
                if let Some(prop) = props.get("axis") {
                    block_state.with_axis(Axis::from_str(prop)?);
                }
                Blocks::StrippedCrimsonStem(block_state)
            }
            "crimson_hyphae" => {
                let mut block_state = CrimsonHyphaeState::default();
                if let Some(prop) = props.get("axis") {
                    block_state.with_axis(Axis::from_str(prop)?);
                }
                Blocks::CrimsonHyphae(block_state)
            }
            "stripped_crimson_hyphae" => {
                let mut block_state = StrippedCrimsonHyphaeState::default();
                if let Some(prop) = props.get("axis") {
                    block_state.with_axis(Axis::from_str(prop)?);
                }
                Blocks::StrippedCrimsonHyphae(block_state)
            }
            "crimson_nylium" => Blocks::CrimsonNylium,
            "crimson_fungus" => Blocks::CrimsonFungus,
            "shroomlight" => Blocks::Shroomlight,
            "weeping_vines" => {
                let mut block_state = WeepingVinesState::default();
                if let Some(prop) = props.get("age") {
                    block_state.with_age(i32::from_str(prop)?);
                }
                Blocks::WeepingVines(block_state)
            }
            "weeping_vines_plant" => Blocks::WeepingVinesPlant,
            "twisting_vines" => {
                let mut block_state = TwistingVinesState::default();
                if let Some(prop) = props.get("age") {
                    block_state.with_age(i32::from_str(prop)?);
                }
                Blocks::TwistingVines(block_state)
            }
            "twisting_vines_plant" => Blocks::TwistingVinesPlant,
            "crimson_roots" => Blocks::CrimsonRoots,
            "crimson_planks" => Blocks::CrimsonPlanks,
            "warped_planks" => Blocks::WarpedPlanks,
            "crimson_slab" => {
                let mut block_state = CrimsonSlabState::default();
                if let Some(prop) = props.get("typed") {
                    block_state.with_typed(SlabType::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::CrimsonSlab(block_state)
            }
            "warped_slab" => {
                let mut block_state = WarpedSlabState::default();
                if let Some(prop) = props.get("typed") {
                    block_state.with_typed(SlabType::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::WarpedSlab(block_state)
            }
            "crimson_pressure_plate" => {
                let mut block_state = CrimsonPressurePlateState::default();
                if let Some(prop) = props.get("powered") {
                    block_state.with_powered(bool::from_str(prop)?);
                }
                Blocks::CrimsonPressurePlate(block_state)
            }
            "warped_pressure_plate" => {
                let mut block_state = WarpedPressurePlateState::default();
                if let Some(prop) = props.get("powered") {
                    block_state.with_powered(bool::from_str(prop)?);
                }
                Blocks::WarpedPressurePlate(block_state)
            }
            "crimson_fence" => {
                let mut block_state = CrimsonFenceState::default();
                if let Some(prop) = props.get("east") {
                    block_state.with_east(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("north") {
                    block_state.with_north(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("south") {
                    block_state.with_south(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("west") {
                    block_state.with_west(bool::from_str(prop)?);
                }
                Blocks::CrimsonFence(block_state)
            }
            "warped_fence" => {
                let mut block_state = WarpedFenceState::default();
                if let Some(prop) = props.get("east") {
                    block_state.with_east(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("north") {
                    block_state.with_north(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("south") {
                    block_state.with_south(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("west") {
                    block_state.with_west(bool::from_str(prop)?);
                }
                Blocks::WarpedFence(block_state)
            }
            "crimson_trapdoor" => {
                let mut block_state = CrimsonTrapdoorState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("half") {
                    block_state.with_half(SingleBlockHalf::from_str(prop)?);
                }
                if let Some(prop) = props.get("open") {
                    block_state.with_open(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("powered") {
                    block_state.with_powered(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::CrimsonTrapdoor(block_state)
            }
            "warped_trapdoor" => {
                let mut block_state = WarpedTrapdoorState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("half") {
                    block_state.with_half(SingleBlockHalf::from_str(prop)?);
                }
                if let Some(prop) = props.get("open") {
                    block_state.with_open(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("powered") {
                    block_state.with_powered(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::WarpedTrapdoor(block_state)
            }
            "crimson_fence_gate" => {
                let mut block_state = CrimsonFenceGateState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("in_wall") {
                    block_state.with_in_wall(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("open") {
                    block_state.with_open(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("powered") {
                    block_state.with_powered(bool::from_str(prop)?);
                }
                Blocks::CrimsonFenceGate(block_state)
            }
            "warped_fence_gate" => {
                let mut block_state = WarpedFenceGateState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("in_wall") {
                    block_state.with_in_wall(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("open") {
                    block_state.with_open(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("powered") {
                    block_state.with_powered(bool::from_str(prop)?);
                }
                Blocks::WarpedFenceGate(block_state)
            }
            "crimson_stairs" => {
                let mut block_state = CrimsonStairsState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("half") {
                    block_state.with_half(SingleBlockHalf::from_str(prop)?);
                }
                if let Some(prop) = props.get("shape") {
                    block_state.with_shape(StairShape::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::CrimsonStairs(block_state)
            }
            "warped_stairs" => {
                let mut block_state = WarpedStairsState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("half") {
                    block_state.with_half(SingleBlockHalf::from_str(prop)?);
                }
                if let Some(prop) = props.get("shape") {
                    block_state.with_shape(StairShape::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::WarpedStairs(block_state)
            }
            "crimson_button" => {
                let mut block_state = CrimsonButtonState::default();
                if let Some(prop) = props.get("face") {
                    block_state.with_face(Face::from_str(prop)?);
                }
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("powered") {
                    block_state.with_powered(bool::from_str(prop)?);
                }
                Blocks::CrimsonButton(block_state)
            }
            "warped_button" => {
                let mut block_state = WarpedButtonState::default();
                if let Some(prop) = props.get("face") {
                    block_state.with_face(Face::from_str(prop)?);
                }
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("powered") {
                    block_state.with_powered(bool::from_str(prop)?);
                }
                Blocks::WarpedButton(block_state)
            }
            "crimson_door" => {
                let mut block_state = CrimsonDoorState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("half") {
                    block_state.with_half(DoubleBlockHalf::from_str(prop)?);
                }
                if let Some(prop) = props.get("hinge") {
                    block_state.with_hinge(Hinge::from_str(prop)?);
                }
                if let Some(prop) = props.get("open") {
                    block_state.with_open(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("powered") {
                    block_state.with_powered(bool::from_str(prop)?);
                }
                Blocks::CrimsonDoor(block_state)
            }
            "warped_door" => {
                let mut block_state = WarpedDoorState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("half") {
                    block_state.with_half(DoubleBlockHalf::from_str(prop)?);
                }
                if let Some(prop) = props.get("hinge") {
                    block_state.with_hinge(Hinge::from_str(prop)?);
                }
                if let Some(prop) = props.get("open") {
                    block_state.with_open(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("powered") {
                    block_state.with_powered(bool::from_str(prop)?);
                }
                Blocks::WarpedDoor(block_state)
            }
            "crimson_sign" => {
                let mut block_state = CrimsonSignState::default();
                if let Some(prop) = props.get("rotation") {
                    block_state.with_rotation(i32::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::CrimsonSign(block_state)
            }
            "warped_sign" => {
                let mut block_state = WarpedSignState::default();
                if let Some(prop) = props.get("rotation") {
                    block_state.with_rotation(i32::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::WarpedSign(block_state)
            }
            "crimson_wall_sign" => {
                let mut block_state = CrimsonWallSignState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::CrimsonWallSign(block_state)
            }
            "warped_wall_sign" => {
                let mut block_state = WarpedWallSignState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::WarpedWallSign(block_state)
            }
            "structure_block" => {
                let mut block_state = StructureBlockState::default();
                if let Some(prop) = props.get("mode") {
                    block_state.with_mode(StructureBlockMode::from_str(prop)?);
                }
                Blocks::StructureBlock(block_state)
            }
            "jigsaw" => {
                let mut block_state = JigsawState::default();
                if let Some(prop) = props.get("orientation") {
                    block_state.with_orientation(Orientation::from_str(prop)?);
                }
                Blocks::Jigsaw(block_state)
            }
            "composter" => {
                let mut block_state = ComposterState::default();
                if let Some(prop) = props.get("level") {
                    block_state.with_level(i32::from_str(prop)?);
                }
                Blocks::Composter(block_state)
            }
            "target" => {
                let mut block_state = TargetState::default();
                if let Some(prop) = props.get("power") {
                    block_state.with_power(i32::from_str(prop)?);
                }
                Blocks::Target(block_state)
            }
            "bee_nest" => {
                let mut block_state = BeeNestState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("honey_level") {
                    block_state.with_honey_level(i32::from_str(prop)?);
                }
                Blocks::BeeNest(block_state)
            }
            "beehive" => {
                let mut block_state = BeehiveState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("honey_level") {
                    block_state.with_honey_level(i32::from_str(prop)?);
                }
                Blocks::Beehive(block_state)
            }
            "honey_block" => Blocks::HoneyBlock,
            "honeycomb_block" => Blocks::HoneycombBlock,
            "netherite_block" => Blocks::NetheriteBlock,
            "ancient_debris" => Blocks::AncientDebris,
            "crying_obsidian" => Blocks::CryingObsidian,
            "respawn_anchor" => {
                let mut block_state = RespawnAnchorState::default();
                if let Some(prop) = props.get("charges") {
                    block_state.with_charges(i32::from_str(prop)?);
                }
                Blocks::RespawnAnchor(block_state)
            }
            "potted_crimson_fungus" => Blocks::PottedCrimsonFungus,
            "potted_warped_fungus" => Blocks::PottedWarpedFungus,
            "potted_crimson_roots" => Blocks::PottedCrimsonRoots,
            "potted_warped_roots" => Blocks::PottedWarpedRoots,
            "lodestone" => Blocks::Lodestone,
            "blackstone" => Blocks::Blackstone,
            "blackstone_stairs" => {
                let mut block_state = BlackstoneStairsState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("half") {
                    block_state.with_half(SingleBlockHalf::from_str(prop)?);
                }
                if let Some(prop) = props.get("shape") {
                    block_state.with_shape(StairShape::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::BlackstoneStairs(block_state)
            }
            "blackstone_wall" => {
                let mut block_state = BlackstoneWallState::default();
                if let Some(prop) = props.get("east") {
                    block_state.with_east(WallType::from_str(prop)?);
                }
                if let Some(prop) = props.get("north") {
                    block_state.with_north(WallType::from_str(prop)?);
                }
                if let Some(prop) = props.get("south") {
                    block_state.with_south(WallType::from_str(prop)?);
                }
                if let Some(prop) = props.get("up") {
                    block_state.with_up(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("west") {
                    block_state.with_west(WallType::from_str(prop)?);
                }
                Blocks::BlackstoneWall(block_state)
            }
            "blackstone_slab" => {
                let mut block_state = BlackstoneSlabState::default();
                if let Some(prop) = props.get("typed") {
                    block_state.with_typed(SlabType::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::BlackstoneSlab(block_state)
            }
            "polished_blackstone" => Blocks::PolishedBlackstone,
            "polished_blackstone_bricks" => Blocks::PolishedBlackstoneBricks,
            "cracked_polished_blackstone_bricks" => Blocks::CrackedPolishedBlackstoneBricks,
            "chiseled_polished_blackstone" => Blocks::ChiseledPolishedBlackstone,
            "polished_blackstone_brick_slab" => {
                let mut block_state = PolishedBlackstoneBrickSlabState::default();
                if let Some(prop) = props.get("typed") {
                    block_state.with_typed(SlabType::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::PolishedBlackstoneBrickSlab(block_state)
            }
            "polished_blackstone_brick_stairs" => {
                let mut block_state = PolishedBlackstoneBrickStairsState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("half") {
                    block_state.with_half(SingleBlockHalf::from_str(prop)?);
                }
                if let Some(prop) = props.get("shape") {
                    block_state.with_shape(StairShape::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::PolishedBlackstoneBrickStairs(block_state)
            }
            "polished_blackstone_brick_wall" => {
                let mut block_state = PolishedBlackstoneBrickWallState::default();
                if let Some(prop) = props.get("east") {
                    block_state.with_east(WallType::from_str(prop)?);
                }
                if let Some(prop) = props.get("north") {
                    block_state.with_north(WallType::from_str(prop)?);
                }
                if let Some(prop) = props.get("south") {
                    block_state.with_south(WallType::from_str(prop)?);
                }
                if let Some(prop) = props.get("up") {
                    block_state.with_up(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("west") {
                    block_state.with_west(WallType::from_str(prop)?);
                }
                Blocks::PolishedBlackstoneBrickWall(block_state)
            }
            "gilded_blackstone" => Blocks::GildedBlackstone,
            "polished_blackstone_stairs" => {
                let mut block_state = PolishedBlackstoneStairsState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("half") {
                    block_state.with_half(SingleBlockHalf::from_str(prop)?);
                }
                if let Some(prop) = props.get("shape") {
                    block_state.with_shape(StairShape::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::PolishedBlackstoneStairs(block_state)
            }
            "polished_blackstone_slab" => {
                let mut block_state = PolishedBlackstoneSlabState::default();
                if let Some(prop) = props.get("typed") {
                    block_state.with_typed(SlabType::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::PolishedBlackstoneSlab(block_state)
            }
            "polished_blackstone_pressure_plate" => {
                let mut block_state = PolishedBlackstonePressurePlateState::default();
                if let Some(prop) = props.get("powered") {
                    block_state.with_powered(bool::from_str(prop)?);
                }
                Blocks::PolishedBlackstonePressurePlate(block_state)
            }
            "polished_blackstone_button" => {
                let mut block_state = PolishedBlackstoneButtonState::default();
                if let Some(prop) = props.get("face") {
                    block_state.with_face(Face::from_str(prop)?);
                }
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("powered") {
                    block_state.with_powered(bool::from_str(prop)?);
                }
                Blocks::PolishedBlackstoneButton(block_state)
            }
            "polished_blackstone_wall" => {
                let mut block_state = PolishedBlackstoneWallState::default();
                if let Some(prop) = props.get("east") {
                    block_state.with_east(WallType::from_str(prop)?);
                }
                if let Some(prop) = props.get("north") {
                    block_state.with_north(WallType::from_str(prop)?);
                }
                if let Some(prop) = props.get("south") {
                    block_state.with_south(WallType::from_str(prop)?);
                }
                if let Some(prop) = props.get("up") {
                    block_state.with_up(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("west") {
                    block_state.with_west(WallType::from_str(prop)?);
                }
                Blocks::PolishedBlackstoneWall(block_state)
            }
            "chiseled_nether_bricks" => Blocks::ChiseledNetherBricks,
            "cracked_nether_bricks" => Blocks::CrackedNetherBricks,
            "quartz_bricks" => Blocks::QuartzBricks,
            "candle" => {
                let mut block_state = CandleState::default();
                if let Some(prop) = props.get("candles") {
                    block_state.with_candles(i32::from_str(prop)?);
                }
                if let Some(prop) = props.get("lit") {
                    block_state.with_lit(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::Candle(block_state)
            }
            "white_candle" => {
                let mut block_state = WhiteCandleState::default();
                if let Some(prop) = props.get("candles") {
                    block_state.with_candles(i32::from_str(prop)?);
                }
                if let Some(prop) = props.get("lit") {
                    block_state.with_lit(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::WhiteCandle(block_state)
            }
            "orange_candle" => {
                let mut block_state = OrangeCandleState::default();
                if let Some(prop) = props.get("candles") {
                    block_state.with_candles(i32::from_str(prop)?);
                }
                if let Some(prop) = props.get("lit") {
                    block_state.with_lit(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::OrangeCandle(block_state)
            }
            "magenta_candle" => {
                let mut block_state = MagentaCandleState::default();
                if let Some(prop) = props.get("candles") {
                    block_state.with_candles(i32::from_str(prop)?);
                }
                if let Some(prop) = props.get("lit") {
                    block_state.with_lit(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::MagentaCandle(block_state)
            }
            "light_blue_candle" => {
                let mut block_state = LightBlueCandleState::default();
                if let Some(prop) = props.get("candles") {
                    block_state.with_candles(i32::from_str(prop)?);
                }
                if let Some(prop) = props.get("lit") {
                    block_state.with_lit(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::LightBlueCandle(block_state)
            }
            "yellow_candle" => {
                let mut block_state = YellowCandleState::default();
                if let Some(prop) = props.get("candles") {
                    block_state.with_candles(i32::from_str(prop)?);
                }
                if let Some(prop) = props.get("lit") {
                    block_state.with_lit(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::YellowCandle(block_state)
            }
            "lime_candle" => {
                let mut block_state = LimeCandleState::default();
                if let Some(prop) = props.get("candles") {
                    block_state.with_candles(i32::from_str(prop)?);
                }
                if let Some(prop) = props.get("lit") {
                    block_state.with_lit(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::LimeCandle(block_state)
            }
            "pink_candle" => {
                let mut block_state = PinkCandleState::default();
                if let Some(prop) = props.get("candles") {
                    block_state.with_candles(i32::from_str(prop)?);
                }
                if let Some(prop) = props.get("lit") {
                    block_state.with_lit(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::PinkCandle(block_state)
            }
            "gray_candle" => {
                let mut block_state = GrayCandleState::default();
                if let Some(prop) = props.get("candles") {
                    block_state.with_candles(i32::from_str(prop)?);
                }
                if let Some(prop) = props.get("lit") {
                    block_state.with_lit(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::GrayCandle(block_state)
            }
            "light_gray_candle" => {
                let mut block_state = LightGrayCandleState::default();
                if let Some(prop) = props.get("candles") {
                    block_state.with_candles(i32::from_str(prop)?);
                }
                if let Some(prop) = props.get("lit") {
                    block_state.with_lit(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::LightGrayCandle(block_state)
            }
            "cyan_candle" => {
                let mut block_state = CyanCandleState::default();
                if let Some(prop) = props.get("candles") {
                    block_state.with_candles(i32::from_str(prop)?);
                }
                if let Some(prop) = props.get("lit") {
                    block_state.with_lit(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::CyanCandle(block_state)
            }
            "purple_candle" => {
                let mut block_state = PurpleCandleState::default();
                if let Some(prop) = props.get("candles") {
                    block_state.with_candles(i32::from_str(prop)?);
                }
                if let Some(prop) = props.get("lit") {
                    block_state.with_lit(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::PurpleCandle(block_state)
            }
            "blue_candle" => {
                let mut block_state = BlueCandleState::default();
                if let Some(prop) = props.get("candles") {
                    block_state.with_candles(i32::from_str(prop)?);
                }
                if let Some(prop) = props.get("lit") {
                    block_state.with_lit(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::BlueCandle(block_state)
            }
            "brown_candle" => {
                let mut block_state = BrownCandleState::default();
                if let Some(prop) = props.get("candles") {
                    block_state.with_candles(i32::from_str(prop)?);
                }
                if let Some(prop) = props.get("lit") {
                    block_state.with_lit(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::BrownCandle(block_state)
            }
            "green_candle" => {
                let mut block_state = GreenCandleState::default();
                if let Some(prop) = props.get("candles") {
                    block_state.with_candles(i32::from_str(prop)?);
                }
                if let Some(prop) = props.get("lit") {
                    block_state.with_lit(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::GreenCandle(block_state)
            }
            "red_candle" => {
                let mut block_state = RedCandleState::default();
                if let Some(prop) = props.get("candles") {
                    block_state.with_candles(i32::from_str(prop)?);
                }
                if let Some(prop) = props.get("lit") {
                    block_state.with_lit(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::RedCandle(block_state)
            }
            "black_candle" => {
                let mut block_state = BlackCandleState::default();
                if let Some(prop) = props.get("candles") {
                    block_state.with_candles(i32::from_str(prop)?);
                }
                if let Some(prop) = props.get("lit") {
                    block_state.with_lit(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::BlackCandle(block_state)
            }
            "candle_cake" => {
                let mut block_state = CandleCakeState::default();
                if let Some(prop) = props.get("lit") {
                    block_state.with_lit(bool::from_str(prop)?);
                }
                Blocks::CandleCake(block_state)
            }
            "white_candle_cake" => {
                let mut block_state = WhiteCandleCakeState::default();
                if let Some(prop) = props.get("lit") {
                    block_state.with_lit(bool::from_str(prop)?);
                }
                Blocks::WhiteCandleCake(block_state)
            }
            "orange_candle_cake" => {
                let mut block_state = OrangeCandleCakeState::default();
                if let Some(prop) = props.get("lit") {
                    block_state.with_lit(bool::from_str(prop)?);
                }
                Blocks::OrangeCandleCake(block_state)
            }
            "magenta_candle_cake" => {
                let mut block_state = MagentaCandleCakeState::default();
                if let Some(prop) = props.get("lit") {
                    block_state.with_lit(bool::from_str(prop)?);
                }
                Blocks::MagentaCandleCake(block_state)
            }
            "light_blue_candle_cake" => {
                let mut block_state = LightBlueCandleCakeState::default();
                if let Some(prop) = props.get("lit") {
                    block_state.with_lit(bool::from_str(prop)?);
                }
                Blocks::LightBlueCandleCake(block_state)
            }
            "yellow_candle_cake" => {
                let mut block_state = YellowCandleCakeState::default();
                if let Some(prop) = props.get("lit") {
                    block_state.with_lit(bool::from_str(prop)?);
                }
                Blocks::YellowCandleCake(block_state)
            }
            "lime_candle_cake" => {
                let mut block_state = LimeCandleCakeState::default();
                if let Some(prop) = props.get("lit") {
                    block_state.with_lit(bool::from_str(prop)?);
                }
                Blocks::LimeCandleCake(block_state)
            }
            "pink_candle_cake" => {
                let mut block_state = PinkCandleCakeState::default();
                if let Some(prop) = props.get("lit") {
                    block_state.with_lit(bool::from_str(prop)?);
                }
                Blocks::PinkCandleCake(block_state)
            }
            "gray_candle_cake" => {
                let mut block_state = GrayCandleCakeState::default();
                if let Some(prop) = props.get("lit") {
                    block_state.with_lit(bool::from_str(prop)?);
                }
                Blocks::GrayCandleCake(block_state)
            }
            "light_gray_candle_cake" => {
                let mut block_state = LightGrayCandleCakeState::default();
                if let Some(prop) = props.get("lit") {
                    block_state.with_lit(bool::from_str(prop)?);
                }
                Blocks::LightGrayCandleCake(block_state)
            }
            "cyan_candle_cake" => {
                let mut block_state = CyanCandleCakeState::default();
                if let Some(prop) = props.get("lit") {
                    block_state.with_lit(bool::from_str(prop)?);
                }
                Blocks::CyanCandleCake(block_state)
            }
            "purple_candle_cake" => {
                let mut block_state = PurpleCandleCakeState::default();
                if let Some(prop) = props.get("lit") {
                    block_state.with_lit(bool::from_str(prop)?);
                }
                Blocks::PurpleCandleCake(block_state)
            }
            "blue_candle_cake" => {
                let mut block_state = BlueCandleCakeState::default();
                if let Some(prop) = props.get("lit") {
                    block_state.with_lit(bool::from_str(prop)?);
                }
                Blocks::BlueCandleCake(block_state)
            }
            "brown_candle_cake" => {
                let mut block_state = BrownCandleCakeState::default();
                if let Some(prop) = props.get("lit") {
                    block_state.with_lit(bool::from_str(prop)?);
                }
                Blocks::BrownCandleCake(block_state)
            }
            "green_candle_cake" => {
                let mut block_state = GreenCandleCakeState::default();
                if let Some(prop) = props.get("lit") {
                    block_state.with_lit(bool::from_str(prop)?);
                }
                Blocks::GreenCandleCake(block_state)
            }
            "red_candle_cake" => {
                let mut block_state = RedCandleCakeState::default();
                if let Some(prop) = props.get("lit") {
                    block_state.with_lit(bool::from_str(prop)?);
                }
                Blocks::RedCandleCake(block_state)
            }
            "black_candle_cake" => {
                let mut block_state = BlackCandleCakeState::default();
                if let Some(prop) = props.get("lit") {
                    block_state.with_lit(bool::from_str(prop)?);
                }
                Blocks::BlackCandleCake(block_state)
            }
            "amethyst_block" => Blocks::AmethystBlock,
            "budding_amethyst" => Blocks::BuddingAmethyst,
            "amethyst_cluster" => {
                let mut block_state = AmethystClusterState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(AllFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::AmethystCluster(block_state)
            }
            "large_amethyst_bud" => {
                let mut block_state = LargeAmethystBudState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(AllFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::LargeAmethystBud(block_state)
            }
            "medium_amethyst_bud" => {
                let mut block_state = MediumAmethystBudState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(AllFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::MediumAmethystBud(block_state)
            }
            "small_amethyst_bud" => {
                let mut block_state = SmallAmethystBudState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(AllFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::SmallAmethystBud(block_state)
            }
            "tuff" => Blocks::Tuff,
            "calcite" => Blocks::Calcite,
            "tinted_glass" => Blocks::TintedGlass,
            "powder_snow" => Blocks::PowderSnow,
            "sculk_sensor" => {
                let mut block_state = SculkSensorState::default();
                if let Some(prop) = props.get("power") {
                    block_state.with_power(i32::from_str(prop)?);
                }
                if let Some(prop) = props.get("sculk_sensor_phase") {
                    block_state.with_sculk_sensor_phase(SculkSensorPhase::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::SculkSensor(block_state)
            }
            "oxidized_copper" => Blocks::OxidizedCopper,
            "weathered_copper" => Blocks::WeatheredCopper,
            "exposed_copper" => Blocks::ExposedCopper,
            "copper_block" => Blocks::CopperBlock,
            "copper_ore" => Blocks::CopperOre,
            "deepslate_copper_ore" => Blocks::DeepslateCopperOre,
            "oxidized_cut_copper" => Blocks::OxidizedCutCopper,
            "weathered_cut_copper" => Blocks::WeatheredCutCopper,
            "exposed_cut_copper" => Blocks::ExposedCutCopper,
            "cut_copper" => Blocks::CutCopper,
            "oxidized_cut_copper_stairs" => {
                let mut block_state = OxidizedCutCopperStairsState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("half") {
                    block_state.with_half(SingleBlockHalf::from_str(prop)?);
                }
                if let Some(prop) = props.get("shape") {
                    block_state.with_shape(StairShape::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::OxidizedCutCopperStairs(block_state)
            }
            "weathered_cut_copper_stairs" => {
                let mut block_state = WeatheredCutCopperStairsState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("half") {
                    block_state.with_half(SingleBlockHalf::from_str(prop)?);
                }
                if let Some(prop) = props.get("shape") {
                    block_state.with_shape(StairShape::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::WeatheredCutCopperStairs(block_state)
            }
            "exposed_cut_copper_stairs" => {
                let mut block_state = ExposedCutCopperStairsState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("half") {
                    block_state.with_half(SingleBlockHalf::from_str(prop)?);
                }
                if let Some(prop) = props.get("shape") {
                    block_state.with_shape(StairShape::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::ExposedCutCopperStairs(block_state)
            }
            "cut_copper_stairs" => {
                let mut block_state = CutCopperStairsState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("half") {
                    block_state.with_half(SingleBlockHalf::from_str(prop)?);
                }
                if let Some(prop) = props.get("shape") {
                    block_state.with_shape(StairShape::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::CutCopperStairs(block_state)
            }
            "oxidized_cut_copper_slab" => {
                let mut block_state = OxidizedCutCopperSlabState::default();
                if let Some(prop) = props.get("typed") {
                    block_state.with_typed(SlabType::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::OxidizedCutCopperSlab(block_state)
            }
            "weathered_cut_copper_slab" => {
                let mut block_state = WeatheredCutCopperSlabState::default();
                if let Some(prop) = props.get("typed") {
                    block_state.with_typed(SlabType::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::WeatheredCutCopperSlab(block_state)
            }
            "exposed_cut_copper_slab" => {
                let mut block_state = ExposedCutCopperSlabState::default();
                if let Some(prop) = props.get("typed") {
                    block_state.with_typed(SlabType::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::ExposedCutCopperSlab(block_state)
            }
            "cut_copper_slab" => {
                let mut block_state = CutCopperSlabState::default();
                if let Some(prop) = props.get("typed") {
                    block_state.with_typed(SlabType::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::CutCopperSlab(block_state)
            }
            "waxed_copper_block" => Blocks::WaxedCopperBlock,
            "waxed_weathered_copper" => Blocks::WaxedWeatheredCopper,
            "waxed_exposed_copper" => Blocks::WaxedExposedCopper,
            "waxed_oxidized_copper" => Blocks::WaxedOxidizedCopper,
            "waxed_oxidized_cut_copper" => Blocks::WaxedOxidizedCutCopper,
            "waxed_weathered_cut_copper" => Blocks::WaxedWeatheredCutCopper,
            "waxed_exposed_cut_copper" => Blocks::WaxedExposedCutCopper,
            "waxed_cut_copper" => Blocks::WaxedCutCopper,
            "waxed_oxidized_cut_copper_stairs" => {
                let mut block_state = WaxedOxidizedCutCopperStairsState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("half") {
                    block_state.with_half(SingleBlockHalf::from_str(prop)?);
                }
                if let Some(prop) = props.get("shape") {
                    block_state.with_shape(StairShape::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::WaxedOxidizedCutCopperStairs(block_state)
            }
            "waxed_weathered_cut_copper_stairs" => {
                let mut block_state = WaxedWeatheredCutCopperStairsState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("half") {
                    block_state.with_half(SingleBlockHalf::from_str(prop)?);
                }
                if let Some(prop) = props.get("shape") {
                    block_state.with_shape(StairShape::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::WaxedWeatheredCutCopperStairs(block_state)
            }
            "waxed_exposed_cut_copper_stairs" => {
                let mut block_state = WaxedExposedCutCopperStairsState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("half") {
                    block_state.with_half(SingleBlockHalf::from_str(prop)?);
                }
                if let Some(prop) = props.get("shape") {
                    block_state.with_shape(StairShape::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::WaxedExposedCutCopperStairs(block_state)
            }
            "waxed_cut_copper_stairs" => {
                let mut block_state = WaxedCutCopperStairsState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("half") {
                    block_state.with_half(SingleBlockHalf::from_str(prop)?);
                }
                if let Some(prop) = props.get("shape") {
                    block_state.with_shape(StairShape::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::WaxedCutCopperStairs(block_state)
            }
            "waxed_oxidized_cut_copper_slab" => {
                let mut block_state = WaxedOxidizedCutCopperSlabState::default();
                if let Some(prop) = props.get("typed") {
                    block_state.with_typed(SlabType::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::WaxedOxidizedCutCopperSlab(block_state)
            }
            "waxed_weathered_cut_copper_slab" => {
                let mut block_state = WaxedWeatheredCutCopperSlabState::default();
                if let Some(prop) = props.get("typed") {
                    block_state.with_typed(SlabType::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::WaxedWeatheredCutCopperSlab(block_state)
            }
            "waxed_exposed_cut_copper_slab" => {
                let mut block_state = WaxedExposedCutCopperSlabState::default();
                if let Some(prop) = props.get("typed") {
                    block_state.with_typed(SlabType::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::WaxedExposedCutCopperSlab(block_state)
            }
            "waxed_cut_copper_slab" => {
                let mut block_state = WaxedCutCopperSlabState::default();
                if let Some(prop) = props.get("typed") {
                    block_state.with_typed(SlabType::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::WaxedCutCopperSlab(block_state)
            }
            "lightning_rod" => {
                let mut block_state = LightningRodState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(AllFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("powered") {
                    block_state.with_powered(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::LightningRod(block_state)
            }
            "pointed_dripstone" => {
                let mut block_state = PointedDripstoneState::default();
                if let Some(prop) = props.get("thickness") {
                    block_state.with_thickness(Thickness::from_str(prop)?);
                }
                if let Some(prop) = props.get("vertical_direction") {
                    block_state.with_vertical_direction(VerticalDirection::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::PointedDripstone(block_state)
            }
            "dripstone_block" => Blocks::DripstoneBlock,
            "cave_vines" => {
                let mut block_state = CaveVinesState::default();
                if let Some(prop) = props.get("age") {
                    block_state.with_age(i32::from_str(prop)?);
                }
                if let Some(prop) = props.get("berries") {
                    block_state.with_berries(bool::from_str(prop)?);
                }
                Blocks::CaveVines(block_state)
            }
            "cave_vines_plant" => {
                let mut block_state = CaveVinesPlantState::default();
                if let Some(prop) = props.get("berries") {
                    block_state.with_berries(bool::from_str(prop)?);
                }
                Blocks::CaveVinesPlant(block_state)
            }
            "spore_blossom" => Blocks::SporeBlossom,
            "azalea" => Blocks::Azalea,
            "flowering_azalea" => Blocks::FloweringAzalea,
            "moss_carpet" => Blocks::MossCarpet,
            "moss_block" => Blocks::MossBlock,
            "big_dripleaf" => {
                let mut block_state = BigDripleafState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("tilt") {
                    block_state.with_tilt(Tilt::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::BigDripleaf(block_state)
            }
            "big_dripleaf_stem" => {
                let mut block_state = BigDripleafStemState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::BigDripleafStem(block_state)
            }
            "small_dripleaf" => {
                let mut block_state = SmallDripleafState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("half") {
                    block_state.with_half(DoubleBlockHalf::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::SmallDripleaf(block_state)
            }
            "hanging_roots" => {
                let mut block_state = HangingRootsState::default();
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::HangingRoots(block_state)
            }
            "rooted_dirt" => Blocks::RootedDirt,
            "deepslate" => {
                let mut block_state = DeepslateState::default();
                if let Some(prop) = props.get("axis") {
                    block_state.with_axis(Axis::from_str(prop)?);
                }
                Blocks::Deepslate(block_state)
            }
            "cobbled_deepslate" => Blocks::CobbledDeepslate,
            "cobbled_deepslate_stairs" => {
                let mut block_state = CobbledDeepslateStairsState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("half") {
                    block_state.with_half(SingleBlockHalf::from_str(prop)?);
                }
                if let Some(prop) = props.get("shape") {
                    block_state.with_shape(StairShape::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::CobbledDeepslateStairs(block_state)
            }
            "cobbled_deepslate_slab" => {
                let mut block_state = CobbledDeepslateSlabState::default();
                if let Some(prop) = props.get("typed") {
                    block_state.with_typed(SlabType::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::CobbledDeepslateSlab(block_state)
            }
            "cobbled_deepslate_wall" => {
                let mut block_state = CobbledDeepslateWallState::default();
                if let Some(prop) = props.get("east") {
                    block_state.with_east(WallType::from_str(prop)?);
                }
                if let Some(prop) = props.get("north") {
                    block_state.with_north(WallType::from_str(prop)?);
                }
                if let Some(prop) = props.get("south") {
                    block_state.with_south(WallType::from_str(prop)?);
                }
                if let Some(prop) = props.get("up") {
                    block_state.with_up(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("west") {
                    block_state.with_west(WallType::from_str(prop)?);
                }
                Blocks::CobbledDeepslateWall(block_state)
            }
            "polished_deepslate" => Blocks::PolishedDeepslate,
            "polished_deepslate_stairs" => {
                let mut block_state = PolishedDeepslateStairsState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("half") {
                    block_state.with_half(SingleBlockHalf::from_str(prop)?);
                }
                if let Some(prop) = props.get("shape") {
                    block_state.with_shape(StairShape::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::PolishedDeepslateStairs(block_state)
            }
            "polished_deepslate_slab" => {
                let mut block_state = PolishedDeepslateSlabState::default();
                if let Some(prop) = props.get("typed") {
                    block_state.with_typed(SlabType::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::PolishedDeepslateSlab(block_state)
            }
            "polished_deepslate_wall" => {
                let mut block_state = PolishedDeepslateWallState::default();
                if let Some(prop) = props.get("east") {
                    block_state.with_east(WallType::from_str(prop)?);
                }
                if let Some(prop) = props.get("north") {
                    block_state.with_north(WallType::from_str(prop)?);
                }
                if let Some(prop) = props.get("south") {
                    block_state.with_south(WallType::from_str(prop)?);
                }
                if let Some(prop) = props.get("up") {
                    block_state.with_up(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("west") {
                    block_state.with_west(WallType::from_str(prop)?);
                }
                Blocks::PolishedDeepslateWall(block_state)
            }
            "deepslate_tiles" => Blocks::DeepslateTiles,
            "deepslate_tile_stairs" => {
                let mut block_state = DeepslateTileStairsState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("half") {
                    block_state.with_half(SingleBlockHalf::from_str(prop)?);
                }
                if let Some(prop) = props.get("shape") {
                    block_state.with_shape(StairShape::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::DeepslateTileStairs(block_state)
            }
            "deepslate_tile_slab" => {
                let mut block_state = DeepslateTileSlabState::default();
                if let Some(prop) = props.get("typed") {
                    block_state.with_typed(SlabType::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::DeepslateTileSlab(block_state)
            }
            "deepslate_tile_wall" => {
                let mut block_state = DeepslateTileWallState::default();
                if let Some(prop) = props.get("east") {
                    block_state.with_east(WallType::from_str(prop)?);
                }
                if let Some(prop) = props.get("north") {
                    block_state.with_north(WallType::from_str(prop)?);
                }
                if let Some(prop) = props.get("south") {
                    block_state.with_south(WallType::from_str(prop)?);
                }
                if let Some(prop) = props.get("up") {
                    block_state.with_up(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("west") {
                    block_state.with_west(WallType::from_str(prop)?);
                }
                Blocks::DeepslateTileWall(block_state)
            }
            "deepslate_bricks" => Blocks::DeepslateBricks,
            "deepslate_brick_stairs" => {
                let mut block_state = DeepslateBrickStairsState::default();
                if let Some(prop) = props.get("facing") {
                    block_state.with_facing(HorizontalFacing::from_str(prop)?);
                }
                if let Some(prop) = props.get("half") {
                    block_state.with_half(SingleBlockHalf::from_str(prop)?);
                }
                if let Some(prop) = props.get("shape") {
                    block_state.with_shape(StairShape::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::DeepslateBrickStairs(block_state)
            }
            "deepslate_brick_slab" => {
                let mut block_state = DeepslateBrickSlabState::default();
                if let Some(prop) = props.get("typed") {
                    block_state.with_typed(SlabType::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                Blocks::DeepslateBrickSlab(block_state)
            }
            "deepslate_brick_wall" => {
                let mut block_state = DeepslateBrickWallState::default();
                if let Some(prop) = props.get("east") {
                    block_state.with_east(WallType::from_str(prop)?);
                }
                if let Some(prop) = props.get("north") {
                    block_state.with_north(WallType::from_str(prop)?);
                }
                if let Some(prop) = props.get("south") {
                    block_state.with_south(WallType::from_str(prop)?);
                }
                if let Some(prop) = props.get("up") {
                    block_state.with_up(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("waterlogged") {
                    block_state.with_waterlogged(bool::from_str(prop)?);
                }
                if let Some(prop) = props.get("west") {
                    block_state.with_west(WallType::from_str(prop)?);
                }
                Blocks::DeepslateBrickWall(block_state)
            }
            "chiseled_deepslate" => Blocks::ChiseledDeepslate,
            "cracked_deepslate_bricks" => Blocks::CrackedDeepslateBricks,
            "cracked_deepslate_tiles" => Blocks::CrackedDeepslateTiles,
            "infested_deepslate" => {
                let mut block_state = InfestedDeepslateState::default();
                if let Some(prop) = props.get("axis") {
                    block_state.with_axis(Axis::from_str(prop)?);
                }
                Blocks::InfestedDeepslate(block_state)
            }
            "smooth_basalt" => Blocks::SmoothBasalt,
            "raw_iron_block" => Blocks::RawIronBlock,
            "raw_copper_block" => Blocks::RawCopperBlock,
            "raw_gold_block" => Blocks::RawGoldBlock,
            "potted_azalea_bush" => Blocks::PottedAzaleaBush,
            "potted_flowering_azalea_bush" => Blocks::PottedFloweringAzaleaBush,
            _ => return Err(ParseBlockError::UnknownBlock),        })
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct GrassBlockState {
    snowy: bool,
}
impl GrassBlockState {
    pub fn with_snowy(&mut self, snowy: bool) -> &mut Self {
        self.snowy = snowy;
        self
    }
    pub fn snowy(&self) -> bool {
        self.snowy
    }
}
impl Default for GrassBlockState {
    fn default() -> Self {
        GrassBlockState {
            snowy: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct PodzolState {
    snowy: bool,
}
impl PodzolState {
    pub fn with_snowy(&mut self, snowy: bool) -> &mut Self {
        self.snowy = snowy;
        self
    }
    pub fn snowy(&self) -> bool {
        self.snowy
    }
}
impl Default for PodzolState {
    fn default() -> Self {
        PodzolState {
            snowy: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct OakSaplingState {
    stage: i32,
}
impl OakSaplingState {
    /// This is a value between 0 and 1 (both ends inclusive).\Developers should be careful to respect these bounds as no checking is done at runtime!!!
    pub fn with_stage(&mut self, stage: i32) -> &mut Self {
        self.stage = stage;
        self
    }
    pub fn stage(&self) -> i32 {
        self.stage
    }
}
impl Default for OakSaplingState {
    fn default() -> Self {
        OakSaplingState {
            stage: 0,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct SpruceSaplingState {
    stage: i32,
}
impl SpruceSaplingState {
    /// This is a value between 0 and 1 (both ends inclusive).\Developers should be careful to respect these bounds as no checking is done at runtime!!!
    pub fn with_stage(&mut self, stage: i32) -> &mut Self {
        self.stage = stage;
        self
    }
    pub fn stage(&self) -> i32 {
        self.stage
    }
}
impl Default for SpruceSaplingState {
    fn default() -> Self {
        SpruceSaplingState {
            stage: 0,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct BirchSaplingState {
    stage: i32,
}
impl BirchSaplingState {
    /// This is a value between 0 and 1 (both ends inclusive).\Developers should be careful to respect these bounds as no checking is done at runtime!!!
    pub fn with_stage(&mut self, stage: i32) -> &mut Self {
        self.stage = stage;
        self
    }
    pub fn stage(&self) -> i32 {
        self.stage
    }
}
impl Default for BirchSaplingState {
    fn default() -> Self {
        BirchSaplingState {
            stage: 0,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct JungleSaplingState {
    stage: i32,
}
impl JungleSaplingState {
    /// This is a value between 0 and 1 (both ends inclusive).\Developers should be careful to respect these bounds as no checking is done at runtime!!!
    pub fn with_stage(&mut self, stage: i32) -> &mut Self {
        self.stage = stage;
        self
    }
    pub fn stage(&self) -> i32 {
        self.stage
    }
}
impl Default for JungleSaplingState {
    fn default() -> Self {
        JungleSaplingState {
            stage: 0,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct AcaciaSaplingState {
    stage: i32,
}
impl AcaciaSaplingState {
    /// This is a value between 0 and 1 (both ends inclusive).\Developers should be careful to respect these bounds as no checking is done at runtime!!!
    pub fn with_stage(&mut self, stage: i32) -> &mut Self {
        self.stage = stage;
        self
    }
    pub fn stage(&self) -> i32 {
        self.stage
    }
}
impl Default for AcaciaSaplingState {
    fn default() -> Self {
        AcaciaSaplingState {
            stage: 0,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct DarkOakSaplingState {
    stage: i32,
}
impl DarkOakSaplingState {
    /// This is a value between 0 and 1 (both ends inclusive).\Developers should be careful to respect these bounds as no checking is done at runtime!!!
    pub fn with_stage(&mut self, stage: i32) -> &mut Self {
        self.stage = stage;
        self
    }
    pub fn stage(&self) -> i32 {
        self.stage
    }
}
impl Default for DarkOakSaplingState {
    fn default() -> Self {
        DarkOakSaplingState {
            stage: 0,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct WaterState {
    level: i32,
}
impl WaterState {
    /// This is a value between 0 and 15 (both ends inclusive).\Developers should be careful to respect these bounds as no checking is done at runtime!!!
    pub fn with_level(&mut self, level: i32) -> &mut Self {
        self.level = level;
        self
    }
    pub fn level(&self) -> i32 {
        self.level
    }
}
impl Default for WaterState {
    fn default() -> Self {
        WaterState {
            level: 0,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct LavaState {
    level: i32,
}
impl LavaState {
    /// This is a value between 0 and 15 (both ends inclusive).\Developers should be careful to respect these bounds as no checking is done at runtime!!!
    pub fn with_level(&mut self, level: i32) -> &mut Self {
        self.level = level;
        self
    }
    pub fn level(&self) -> i32 {
        self.level
    }
}
impl Default for LavaState {
    fn default() -> Self {
        LavaState {
            level: 0,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct OakLogState {
    axis: Axis,
}
impl OakLogState {
    pub fn with_axis(&mut self, axis: Axis) -> &mut Self {
        self.axis = axis;
        self
    }
    pub fn axis(&self) -> Axis {
        self.axis
    }
}
impl Default for OakLogState {
    fn default() -> Self {
        OakLogState {
            axis: Axis::Y,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct SpruceLogState {
    axis: Axis,
}
impl SpruceLogState {
    pub fn with_axis(&mut self, axis: Axis) -> &mut Self {
        self.axis = axis;
        self
    }
    pub fn axis(&self) -> Axis {
        self.axis
    }
}
impl Default for SpruceLogState {
    fn default() -> Self {
        SpruceLogState {
            axis: Axis::Y,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct BirchLogState {
    axis: Axis,
}
impl BirchLogState {
    pub fn with_axis(&mut self, axis: Axis) -> &mut Self {
        self.axis = axis;
        self
    }
    pub fn axis(&self) -> Axis {
        self.axis
    }
}
impl Default for BirchLogState {
    fn default() -> Self {
        BirchLogState {
            axis: Axis::Y,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct JungleLogState {
    axis: Axis,
}
impl JungleLogState {
    pub fn with_axis(&mut self, axis: Axis) -> &mut Self {
        self.axis = axis;
        self
    }
    pub fn axis(&self) -> Axis {
        self.axis
    }
}
impl Default for JungleLogState {
    fn default() -> Self {
        JungleLogState {
            axis: Axis::Y,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct AcaciaLogState {
    axis: Axis,
}
impl AcaciaLogState {
    pub fn with_axis(&mut self, axis: Axis) -> &mut Self {
        self.axis = axis;
        self
    }
    pub fn axis(&self) -> Axis {
        self.axis
    }
}
impl Default for AcaciaLogState {
    fn default() -> Self {
        AcaciaLogState {
            axis: Axis::Y,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct DarkOakLogState {
    axis: Axis,
}
impl DarkOakLogState {
    pub fn with_axis(&mut self, axis: Axis) -> &mut Self {
        self.axis = axis;
        self
    }
    pub fn axis(&self) -> Axis {
        self.axis
    }
}
impl Default for DarkOakLogState {
    fn default() -> Self {
        DarkOakLogState {
            axis: Axis::Y,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct StrippedSpruceLogState {
    axis: Axis,
}
impl StrippedSpruceLogState {
    pub fn with_axis(&mut self, axis: Axis) -> &mut Self {
        self.axis = axis;
        self
    }
    pub fn axis(&self) -> Axis {
        self.axis
    }
}
impl Default for StrippedSpruceLogState {
    fn default() -> Self {
        StrippedSpruceLogState {
            axis: Axis::Y,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct StrippedBirchLogState {
    axis: Axis,
}
impl StrippedBirchLogState {
    pub fn with_axis(&mut self, axis: Axis) -> &mut Self {
        self.axis = axis;
        self
    }
    pub fn axis(&self) -> Axis {
        self.axis
    }
}
impl Default for StrippedBirchLogState {
    fn default() -> Self {
        StrippedBirchLogState {
            axis: Axis::Y,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct StrippedJungleLogState {
    axis: Axis,
}
impl StrippedJungleLogState {
    pub fn with_axis(&mut self, axis: Axis) -> &mut Self {
        self.axis = axis;
        self
    }
    pub fn axis(&self) -> Axis {
        self.axis
    }
}
impl Default for StrippedJungleLogState {
    fn default() -> Self {
        StrippedJungleLogState {
            axis: Axis::Y,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct StrippedAcaciaLogState {
    axis: Axis,
}
impl StrippedAcaciaLogState {
    pub fn with_axis(&mut self, axis: Axis) -> &mut Self {
        self.axis = axis;
        self
    }
    pub fn axis(&self) -> Axis {
        self.axis
    }
}
impl Default for StrippedAcaciaLogState {
    fn default() -> Self {
        StrippedAcaciaLogState {
            axis: Axis::Y,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct StrippedDarkOakLogState {
    axis: Axis,
}
impl StrippedDarkOakLogState {
    pub fn with_axis(&mut self, axis: Axis) -> &mut Self {
        self.axis = axis;
        self
    }
    pub fn axis(&self) -> Axis {
        self.axis
    }
}
impl Default for StrippedDarkOakLogState {
    fn default() -> Self {
        StrippedDarkOakLogState {
            axis: Axis::Y,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct StrippedOakLogState {
    axis: Axis,
}
impl StrippedOakLogState {
    pub fn with_axis(&mut self, axis: Axis) -> &mut Self {
        self.axis = axis;
        self
    }
    pub fn axis(&self) -> Axis {
        self.axis
    }
}
impl Default for StrippedOakLogState {
    fn default() -> Self {
        StrippedOakLogState {
            axis: Axis::Y,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct OakWoodState {
    axis: Axis,
}
impl OakWoodState {
    pub fn with_axis(&mut self, axis: Axis) -> &mut Self {
        self.axis = axis;
        self
    }
    pub fn axis(&self) -> Axis {
        self.axis
    }
}
impl Default for OakWoodState {
    fn default() -> Self {
        OakWoodState {
            axis: Axis::Y,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct SpruceWoodState {
    axis: Axis,
}
impl SpruceWoodState {
    pub fn with_axis(&mut self, axis: Axis) -> &mut Self {
        self.axis = axis;
        self
    }
    pub fn axis(&self) -> Axis {
        self.axis
    }
}
impl Default for SpruceWoodState {
    fn default() -> Self {
        SpruceWoodState {
            axis: Axis::Y,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct BirchWoodState {
    axis: Axis,
}
impl BirchWoodState {
    pub fn with_axis(&mut self, axis: Axis) -> &mut Self {
        self.axis = axis;
        self
    }
    pub fn axis(&self) -> Axis {
        self.axis
    }
}
impl Default for BirchWoodState {
    fn default() -> Self {
        BirchWoodState {
            axis: Axis::Y,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct JungleWoodState {
    axis: Axis,
}
impl JungleWoodState {
    pub fn with_axis(&mut self, axis: Axis) -> &mut Self {
        self.axis = axis;
        self
    }
    pub fn axis(&self) -> Axis {
        self.axis
    }
}
impl Default for JungleWoodState {
    fn default() -> Self {
        JungleWoodState {
            axis: Axis::Y,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct AcaciaWoodState {
    axis: Axis,
}
impl AcaciaWoodState {
    pub fn with_axis(&mut self, axis: Axis) -> &mut Self {
        self.axis = axis;
        self
    }
    pub fn axis(&self) -> Axis {
        self.axis
    }
}
impl Default for AcaciaWoodState {
    fn default() -> Self {
        AcaciaWoodState {
            axis: Axis::Y,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct DarkOakWoodState {
    axis: Axis,
}
impl DarkOakWoodState {
    pub fn with_axis(&mut self, axis: Axis) -> &mut Self {
        self.axis = axis;
        self
    }
    pub fn axis(&self) -> Axis {
        self.axis
    }
}
impl Default for DarkOakWoodState {
    fn default() -> Self {
        DarkOakWoodState {
            axis: Axis::Y,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct StrippedOakWoodState {
    axis: Axis,
}
impl StrippedOakWoodState {
    pub fn with_axis(&mut self, axis: Axis) -> &mut Self {
        self.axis = axis;
        self
    }
    pub fn axis(&self) -> Axis {
        self.axis
    }
}
impl Default for StrippedOakWoodState {
    fn default() -> Self {
        StrippedOakWoodState {
            axis: Axis::Y,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct StrippedSpruceWoodState {
    axis: Axis,
}
impl StrippedSpruceWoodState {
    pub fn with_axis(&mut self, axis: Axis) -> &mut Self {
        self.axis = axis;
        self
    }
    pub fn axis(&self) -> Axis {
        self.axis
    }
}
impl Default for StrippedSpruceWoodState {
    fn default() -> Self {
        StrippedSpruceWoodState {
            axis: Axis::Y,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct StrippedBirchWoodState {
    axis: Axis,
}
impl StrippedBirchWoodState {
    pub fn with_axis(&mut self, axis: Axis) -> &mut Self {
        self.axis = axis;
        self
    }
    pub fn axis(&self) -> Axis {
        self.axis
    }
}
impl Default for StrippedBirchWoodState {
    fn default() -> Self {
        StrippedBirchWoodState {
            axis: Axis::Y,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct StrippedJungleWoodState {
    axis: Axis,
}
impl StrippedJungleWoodState {
    pub fn with_axis(&mut self, axis: Axis) -> &mut Self {
        self.axis = axis;
        self
    }
    pub fn axis(&self) -> Axis {
        self.axis
    }
}
impl Default for StrippedJungleWoodState {
    fn default() -> Self {
        StrippedJungleWoodState {
            axis: Axis::Y,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct StrippedAcaciaWoodState {
    axis: Axis,
}
impl StrippedAcaciaWoodState {
    pub fn with_axis(&mut self, axis: Axis) -> &mut Self {
        self.axis = axis;
        self
    }
    pub fn axis(&self) -> Axis {
        self.axis
    }
}
impl Default for StrippedAcaciaWoodState {
    fn default() -> Self {
        StrippedAcaciaWoodState {
            axis: Axis::Y,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct StrippedDarkOakWoodState {
    axis: Axis,
}
impl StrippedDarkOakWoodState {
    pub fn with_axis(&mut self, axis: Axis) -> &mut Self {
        self.axis = axis;
        self
    }
    pub fn axis(&self) -> Axis {
        self.axis
    }
}
impl Default for StrippedDarkOakWoodState {
    fn default() -> Self {
        StrippedDarkOakWoodState {
            axis: Axis::Y,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct OakLeavesState {
    distance: i32,
    persistent: bool,
}
impl OakLeavesState {
    /// This is a value between 1 and 7 (both ends inclusive).\Developers should be careful to respect these bounds as no checking is done at runtime!!!
    pub fn with_distance(&mut self, distance: i32) -> &mut Self {
        self.distance = distance - 1;
        self
    }
    pub fn distance(&self) -> i32 {
        self.distance + 1
    }
    pub fn with_persistent(&mut self, persistent: bool) -> &mut Self {
        self.persistent = persistent;
        self
    }
    pub fn persistent(&self) -> bool {
        self.persistent
    }
}
impl Default for OakLeavesState {
    fn default() -> Self {
        OakLeavesState {
            distance: 6,
            persistent: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct SpruceLeavesState {
    distance: i32,
    persistent: bool,
}
impl SpruceLeavesState {
    /// This is a value between 1 and 7 (both ends inclusive).\Developers should be careful to respect these bounds as no checking is done at runtime!!!
    pub fn with_distance(&mut self, distance: i32) -> &mut Self {
        self.distance = distance - 1;
        self
    }
    pub fn distance(&self) -> i32 {
        self.distance + 1
    }
    pub fn with_persistent(&mut self, persistent: bool) -> &mut Self {
        self.persistent = persistent;
        self
    }
    pub fn persistent(&self) -> bool {
        self.persistent
    }
}
impl Default for SpruceLeavesState {
    fn default() -> Self {
        SpruceLeavesState {
            distance: 6,
            persistent: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct BirchLeavesState {
    distance: i32,
    persistent: bool,
}
impl BirchLeavesState {
    /// This is a value between 1 and 7 (both ends inclusive).\Developers should be careful to respect these bounds as no checking is done at runtime!!!
    pub fn with_distance(&mut self, distance: i32) -> &mut Self {
        self.distance = distance - 1;
        self
    }
    pub fn distance(&self) -> i32 {
        self.distance + 1
    }
    pub fn with_persistent(&mut self, persistent: bool) -> &mut Self {
        self.persistent = persistent;
        self
    }
    pub fn persistent(&self) -> bool {
        self.persistent
    }
}
impl Default for BirchLeavesState {
    fn default() -> Self {
        BirchLeavesState {
            distance: 6,
            persistent: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct JungleLeavesState {
    distance: i32,
    persistent: bool,
}
impl JungleLeavesState {
    /// This is a value between 1 and 7 (both ends inclusive).\Developers should be careful to respect these bounds as no checking is done at runtime!!!
    pub fn with_distance(&mut self, distance: i32) -> &mut Self {
        self.distance = distance - 1;
        self
    }
    pub fn distance(&self) -> i32 {
        self.distance + 1
    }
    pub fn with_persistent(&mut self, persistent: bool) -> &mut Self {
        self.persistent = persistent;
        self
    }
    pub fn persistent(&self) -> bool {
        self.persistent
    }
}
impl Default for JungleLeavesState {
    fn default() -> Self {
        JungleLeavesState {
            distance: 6,
            persistent: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct AcaciaLeavesState {
    distance: i32,
    persistent: bool,
}
impl AcaciaLeavesState {
    /// This is a value between 1 and 7 (both ends inclusive).\Developers should be careful to respect these bounds as no checking is done at runtime!!!
    pub fn with_distance(&mut self, distance: i32) -> &mut Self {
        self.distance = distance - 1;
        self
    }
    pub fn distance(&self) -> i32 {
        self.distance + 1
    }
    pub fn with_persistent(&mut self, persistent: bool) -> &mut Self {
        self.persistent = persistent;
        self
    }
    pub fn persistent(&self) -> bool {
        self.persistent
    }
}
impl Default for AcaciaLeavesState {
    fn default() -> Self {
        AcaciaLeavesState {
            distance: 6,
            persistent: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct DarkOakLeavesState {
    distance: i32,
    persistent: bool,
}
impl DarkOakLeavesState {
    /// This is a value between 1 and 7 (both ends inclusive).\Developers should be careful to respect these bounds as no checking is done at runtime!!!
    pub fn with_distance(&mut self, distance: i32) -> &mut Self {
        self.distance = distance - 1;
        self
    }
    pub fn distance(&self) -> i32 {
        self.distance + 1
    }
    pub fn with_persistent(&mut self, persistent: bool) -> &mut Self {
        self.persistent = persistent;
        self
    }
    pub fn persistent(&self) -> bool {
        self.persistent
    }
}
impl Default for DarkOakLeavesState {
    fn default() -> Self {
        DarkOakLeavesState {
            distance: 6,
            persistent: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct AzaleaLeavesState {
    distance: i32,
    persistent: bool,
}
impl AzaleaLeavesState {
    /// This is a value between 1 and 7 (both ends inclusive).\Developers should be careful to respect these bounds as no checking is done at runtime!!!
    pub fn with_distance(&mut self, distance: i32) -> &mut Self {
        self.distance = distance - 1;
        self
    }
    pub fn distance(&self) -> i32 {
        self.distance + 1
    }
    pub fn with_persistent(&mut self, persistent: bool) -> &mut Self {
        self.persistent = persistent;
        self
    }
    pub fn persistent(&self) -> bool {
        self.persistent
    }
}
impl Default for AzaleaLeavesState {
    fn default() -> Self {
        AzaleaLeavesState {
            distance: 6,
            persistent: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct FloweringAzaleaLeavesState {
    distance: i32,
    persistent: bool,
}
impl FloweringAzaleaLeavesState {
    /// This is a value between 1 and 7 (both ends inclusive).\Developers should be careful to respect these bounds as no checking is done at runtime!!!
    pub fn with_distance(&mut self, distance: i32) -> &mut Self {
        self.distance = distance - 1;
        self
    }
    pub fn distance(&self) -> i32 {
        self.distance + 1
    }
    pub fn with_persistent(&mut self, persistent: bool) -> &mut Self {
        self.persistent = persistent;
        self
    }
    pub fn persistent(&self) -> bool {
        self.persistent
    }
}
impl Default for FloweringAzaleaLeavesState {
    fn default() -> Self {
        FloweringAzaleaLeavesState {
            distance: 6,
            persistent: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct DispenserState {
    facing: AllFacing,
    triggered: bool,
}
impl DispenserState {
    pub fn with_facing(&mut self, facing: AllFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> AllFacing {
        self.facing
    }
    pub fn with_triggered(&mut self, triggered: bool) -> &mut Self {
        self.triggered = triggered;
        self
    }
    pub fn triggered(&self) -> bool {
        self.triggered
    }
}
impl Default for DispenserState {
    fn default() -> Self {
        DispenserState {
            facing: AllFacing::North,
            triggered: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct NoteBlockState {
    instrument: Instrument,
    note: i32,
    powered: bool,
}
impl NoteBlockState {
    pub fn with_instrument(&mut self, instrument: Instrument) -> &mut Self {
        self.instrument = instrument;
        self
    }
    pub fn instrument(&self) -> Instrument {
        self.instrument
    }
    /// This is a value between 0 and 24 (both ends inclusive).\Developers should be careful to respect these bounds as no checking is done at runtime!!!
    pub fn with_note(&mut self, note: i32) -> &mut Self {
        self.note = note;
        self
    }
    pub fn note(&self) -> i32 {
        self.note
    }
    pub fn with_powered(&mut self, powered: bool) -> &mut Self {
        self.powered = powered;
        self
    }
    pub fn powered(&self) -> bool {
        self.powered
    }
}
impl Default for NoteBlockState {
    fn default() -> Self {
        NoteBlockState {
            instrument: Instrument::Harp,
            note: 0,
            powered: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct WhiteBedState {
    facing: HorizontalFacing,
    occupied: bool,
    part: Part,
}
impl WhiteBedState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_occupied(&mut self, occupied: bool) -> &mut Self {
        self.occupied = occupied;
        self
    }
    pub fn occupied(&self) -> bool {
        self.occupied
    }
    pub fn with_part(&mut self, part: Part) -> &mut Self {
        self.part = part;
        self
    }
    pub fn part(&self) -> Part {
        self.part
    }
}
impl Default for WhiteBedState {
    fn default() -> Self {
        WhiteBedState {
            facing: HorizontalFacing::North,
            occupied: false,
            part: Part::Foot,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct OrangeBedState {
    facing: HorizontalFacing,
    occupied: bool,
    part: Part,
}
impl OrangeBedState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_occupied(&mut self, occupied: bool) -> &mut Self {
        self.occupied = occupied;
        self
    }
    pub fn occupied(&self) -> bool {
        self.occupied
    }
    pub fn with_part(&mut self, part: Part) -> &mut Self {
        self.part = part;
        self
    }
    pub fn part(&self) -> Part {
        self.part
    }
}
impl Default for OrangeBedState {
    fn default() -> Self {
        OrangeBedState {
            facing: HorizontalFacing::North,
            occupied: false,
            part: Part::Foot,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct MagentaBedState {
    facing: HorizontalFacing,
    occupied: bool,
    part: Part,
}
impl MagentaBedState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_occupied(&mut self, occupied: bool) -> &mut Self {
        self.occupied = occupied;
        self
    }
    pub fn occupied(&self) -> bool {
        self.occupied
    }
    pub fn with_part(&mut self, part: Part) -> &mut Self {
        self.part = part;
        self
    }
    pub fn part(&self) -> Part {
        self.part
    }
}
impl Default for MagentaBedState {
    fn default() -> Self {
        MagentaBedState {
            facing: HorizontalFacing::North,
            occupied: false,
            part: Part::Foot,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct LightBlueBedState {
    facing: HorizontalFacing,
    occupied: bool,
    part: Part,
}
impl LightBlueBedState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_occupied(&mut self, occupied: bool) -> &mut Self {
        self.occupied = occupied;
        self
    }
    pub fn occupied(&self) -> bool {
        self.occupied
    }
    pub fn with_part(&mut self, part: Part) -> &mut Self {
        self.part = part;
        self
    }
    pub fn part(&self) -> Part {
        self.part
    }
}
impl Default for LightBlueBedState {
    fn default() -> Self {
        LightBlueBedState {
            facing: HorizontalFacing::North,
            occupied: false,
            part: Part::Foot,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct YellowBedState {
    facing: HorizontalFacing,
    occupied: bool,
    part: Part,
}
impl YellowBedState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_occupied(&mut self, occupied: bool) -> &mut Self {
        self.occupied = occupied;
        self
    }
    pub fn occupied(&self) -> bool {
        self.occupied
    }
    pub fn with_part(&mut self, part: Part) -> &mut Self {
        self.part = part;
        self
    }
    pub fn part(&self) -> Part {
        self.part
    }
}
impl Default for YellowBedState {
    fn default() -> Self {
        YellowBedState {
            facing: HorizontalFacing::North,
            occupied: false,
            part: Part::Foot,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct LimeBedState {
    facing: HorizontalFacing,
    occupied: bool,
    part: Part,
}
impl LimeBedState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_occupied(&mut self, occupied: bool) -> &mut Self {
        self.occupied = occupied;
        self
    }
    pub fn occupied(&self) -> bool {
        self.occupied
    }
    pub fn with_part(&mut self, part: Part) -> &mut Self {
        self.part = part;
        self
    }
    pub fn part(&self) -> Part {
        self.part
    }
}
impl Default for LimeBedState {
    fn default() -> Self {
        LimeBedState {
            facing: HorizontalFacing::North,
            occupied: false,
            part: Part::Foot,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct PinkBedState {
    facing: HorizontalFacing,
    occupied: bool,
    part: Part,
}
impl PinkBedState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_occupied(&mut self, occupied: bool) -> &mut Self {
        self.occupied = occupied;
        self
    }
    pub fn occupied(&self) -> bool {
        self.occupied
    }
    pub fn with_part(&mut self, part: Part) -> &mut Self {
        self.part = part;
        self
    }
    pub fn part(&self) -> Part {
        self.part
    }
}
impl Default for PinkBedState {
    fn default() -> Self {
        PinkBedState {
            facing: HorizontalFacing::North,
            occupied: false,
            part: Part::Foot,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct GrayBedState {
    facing: HorizontalFacing,
    occupied: bool,
    part: Part,
}
impl GrayBedState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_occupied(&mut self, occupied: bool) -> &mut Self {
        self.occupied = occupied;
        self
    }
    pub fn occupied(&self) -> bool {
        self.occupied
    }
    pub fn with_part(&mut self, part: Part) -> &mut Self {
        self.part = part;
        self
    }
    pub fn part(&self) -> Part {
        self.part
    }
}
impl Default for GrayBedState {
    fn default() -> Self {
        GrayBedState {
            facing: HorizontalFacing::North,
            occupied: false,
            part: Part::Foot,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct LightGrayBedState {
    facing: HorizontalFacing,
    occupied: bool,
    part: Part,
}
impl LightGrayBedState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_occupied(&mut self, occupied: bool) -> &mut Self {
        self.occupied = occupied;
        self
    }
    pub fn occupied(&self) -> bool {
        self.occupied
    }
    pub fn with_part(&mut self, part: Part) -> &mut Self {
        self.part = part;
        self
    }
    pub fn part(&self) -> Part {
        self.part
    }
}
impl Default for LightGrayBedState {
    fn default() -> Self {
        LightGrayBedState {
            facing: HorizontalFacing::North,
            occupied: false,
            part: Part::Foot,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct CyanBedState {
    facing: HorizontalFacing,
    occupied: bool,
    part: Part,
}
impl CyanBedState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_occupied(&mut self, occupied: bool) -> &mut Self {
        self.occupied = occupied;
        self
    }
    pub fn occupied(&self) -> bool {
        self.occupied
    }
    pub fn with_part(&mut self, part: Part) -> &mut Self {
        self.part = part;
        self
    }
    pub fn part(&self) -> Part {
        self.part
    }
}
impl Default for CyanBedState {
    fn default() -> Self {
        CyanBedState {
            facing: HorizontalFacing::North,
            occupied: false,
            part: Part::Foot,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct PurpleBedState {
    facing: HorizontalFacing,
    occupied: bool,
    part: Part,
}
impl PurpleBedState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_occupied(&mut self, occupied: bool) -> &mut Self {
        self.occupied = occupied;
        self
    }
    pub fn occupied(&self) -> bool {
        self.occupied
    }
    pub fn with_part(&mut self, part: Part) -> &mut Self {
        self.part = part;
        self
    }
    pub fn part(&self) -> Part {
        self.part
    }
}
impl Default for PurpleBedState {
    fn default() -> Self {
        PurpleBedState {
            facing: HorizontalFacing::North,
            occupied: false,
            part: Part::Foot,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct BlueBedState {
    facing: HorizontalFacing,
    occupied: bool,
    part: Part,
}
impl BlueBedState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_occupied(&mut self, occupied: bool) -> &mut Self {
        self.occupied = occupied;
        self
    }
    pub fn occupied(&self) -> bool {
        self.occupied
    }
    pub fn with_part(&mut self, part: Part) -> &mut Self {
        self.part = part;
        self
    }
    pub fn part(&self) -> Part {
        self.part
    }
}
impl Default for BlueBedState {
    fn default() -> Self {
        BlueBedState {
            facing: HorizontalFacing::North,
            occupied: false,
            part: Part::Foot,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct BrownBedState {
    facing: HorizontalFacing,
    occupied: bool,
    part: Part,
}
impl BrownBedState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_occupied(&mut self, occupied: bool) -> &mut Self {
        self.occupied = occupied;
        self
    }
    pub fn occupied(&self) -> bool {
        self.occupied
    }
    pub fn with_part(&mut self, part: Part) -> &mut Self {
        self.part = part;
        self
    }
    pub fn part(&self) -> Part {
        self.part
    }
}
impl Default for BrownBedState {
    fn default() -> Self {
        BrownBedState {
            facing: HorizontalFacing::North,
            occupied: false,
            part: Part::Foot,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct GreenBedState {
    facing: HorizontalFacing,
    occupied: bool,
    part: Part,
}
impl GreenBedState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_occupied(&mut self, occupied: bool) -> &mut Self {
        self.occupied = occupied;
        self
    }
    pub fn occupied(&self) -> bool {
        self.occupied
    }
    pub fn with_part(&mut self, part: Part) -> &mut Self {
        self.part = part;
        self
    }
    pub fn part(&self) -> Part {
        self.part
    }
}
impl Default for GreenBedState {
    fn default() -> Self {
        GreenBedState {
            facing: HorizontalFacing::North,
            occupied: false,
            part: Part::Foot,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct RedBedState {
    facing: HorizontalFacing,
    occupied: bool,
    part: Part,
}
impl RedBedState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_occupied(&mut self, occupied: bool) -> &mut Self {
        self.occupied = occupied;
        self
    }
    pub fn occupied(&self) -> bool {
        self.occupied
    }
    pub fn with_part(&mut self, part: Part) -> &mut Self {
        self.part = part;
        self
    }
    pub fn part(&self) -> Part {
        self.part
    }
}
impl Default for RedBedState {
    fn default() -> Self {
        RedBedState {
            facing: HorizontalFacing::North,
            occupied: false,
            part: Part::Foot,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct BlackBedState {
    facing: HorizontalFacing,
    occupied: bool,
    part: Part,
}
impl BlackBedState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_occupied(&mut self, occupied: bool) -> &mut Self {
        self.occupied = occupied;
        self
    }
    pub fn occupied(&self) -> bool {
        self.occupied
    }
    pub fn with_part(&mut self, part: Part) -> &mut Self {
        self.part = part;
        self
    }
    pub fn part(&self) -> Part {
        self.part
    }
}
impl Default for BlackBedState {
    fn default() -> Self {
        BlackBedState {
            facing: HorizontalFacing::North,
            occupied: false,
            part: Part::Foot,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct PoweredRailState {
    powered: bool,
    shape: StraightRailShape,
    waterlogged: bool,
}
impl PoweredRailState {
    pub fn with_powered(&mut self, powered: bool) -> &mut Self {
        self.powered = powered;
        self
    }
    pub fn powered(&self) -> bool {
        self.powered
    }
    pub fn with_shape(&mut self, shape: StraightRailShape) -> &mut Self {
        self.shape = shape;
        self
    }
    pub fn shape(&self) -> StraightRailShape {
        self.shape
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for PoweredRailState {
    fn default() -> Self {
        PoweredRailState {
            powered: false,
            shape: StraightRailShape::NorthSouth,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct DetectorRailState {
    powered: bool,
    shape: StraightRailShape,
    waterlogged: bool,
}
impl DetectorRailState {
    pub fn with_powered(&mut self, powered: bool) -> &mut Self {
        self.powered = powered;
        self
    }
    pub fn powered(&self) -> bool {
        self.powered
    }
    pub fn with_shape(&mut self, shape: StraightRailShape) -> &mut Self {
        self.shape = shape;
        self
    }
    pub fn shape(&self) -> StraightRailShape {
        self.shape
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for DetectorRailState {
    fn default() -> Self {
        DetectorRailState {
            powered: false,
            shape: StraightRailShape::NorthSouth,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct StickyPistonState {
    extended: bool,
    facing: AllFacing,
}
impl StickyPistonState {
    pub fn with_extended(&mut self, extended: bool) -> &mut Self {
        self.extended = extended;
        self
    }
    pub fn extended(&self) -> bool {
        self.extended
    }
    pub fn with_facing(&mut self, facing: AllFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> AllFacing {
        self.facing
    }
}
impl Default for StickyPistonState {
    fn default() -> Self {
        StickyPistonState {
            extended: false,
            facing: AllFacing::North,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct TallSeagrassState {
    half: DoubleBlockHalf,
}
impl TallSeagrassState {
    pub fn with_half(&mut self, half: DoubleBlockHalf) -> &mut Self {
        self.half = half;
        self
    }
    pub fn half(&self) -> DoubleBlockHalf {
        self.half
    }
}
impl Default for TallSeagrassState {
    fn default() -> Self {
        TallSeagrassState {
            half: DoubleBlockHalf::Lower,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct PistonState {
    extended: bool,
    facing: AllFacing,
}
impl PistonState {
    pub fn with_extended(&mut self, extended: bool) -> &mut Self {
        self.extended = extended;
        self
    }
    pub fn extended(&self) -> bool {
        self.extended
    }
    pub fn with_facing(&mut self, facing: AllFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> AllFacing {
        self.facing
    }
}
impl Default for PistonState {
    fn default() -> Self {
        PistonState {
            extended: false,
            facing: AllFacing::North,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct PistonHeadState {
    facing: AllFacing,
    short: bool,
    typed: PistonType,
}
impl PistonHeadState {
    pub fn with_facing(&mut self, facing: AllFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> AllFacing {
        self.facing
    }
    pub fn with_short(&mut self, short: bool) -> &mut Self {
        self.short = short;
        self
    }
    pub fn short(&self) -> bool {
        self.short
    }
    pub fn with_typed(&mut self, typed: PistonType) -> &mut Self {
        self.typed = typed;
        self
    }
    pub fn typed(&self) -> PistonType {
        self.typed
    }
}
impl Default for PistonHeadState {
    fn default() -> Self {
        PistonHeadState {
            facing: AllFacing::North,
            short: false,
            typed: PistonType::Normal,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct MovingPistonState {
    facing: AllFacing,
    typed: PistonType,
}
impl MovingPistonState {
    pub fn with_facing(&mut self, facing: AllFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> AllFacing {
        self.facing
    }
    pub fn with_typed(&mut self, typed: PistonType) -> &mut Self {
        self.typed = typed;
        self
    }
    pub fn typed(&self) -> PistonType {
        self.typed
    }
}
impl Default for MovingPistonState {
    fn default() -> Self {
        MovingPistonState {
            facing: AllFacing::North,
            typed: PistonType::Normal,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct TntState {
    unstable: bool,
}
impl TntState {
    pub fn with_unstable(&mut self, unstable: bool) -> &mut Self {
        self.unstable = unstable;
        self
    }
    pub fn unstable(&self) -> bool {
        self.unstable
    }
}
impl Default for TntState {
    fn default() -> Self {
        TntState {
            unstable: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct WallTorchState {
    facing: HorizontalFacing,
}
impl WallTorchState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
}
impl Default for WallTorchState {
    fn default() -> Self {
        WallTorchState {
            facing: HorizontalFacing::North,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct FireState {
    age: i32,
    east: bool,
    north: bool,
    south: bool,
    up: bool,
    west: bool,
}
impl FireState {
    /// This is a value between 0 and 15 (both ends inclusive).\Developers should be careful to respect these bounds as no checking is done at runtime!!!
    pub fn with_age(&mut self, age: i32) -> &mut Self {
        self.age = age;
        self
    }
    pub fn age(&self) -> i32 {
        self.age
    }
    pub fn with_east(&mut self, east: bool) -> &mut Self {
        self.east = east;
        self
    }
    pub fn east(&self) -> bool {
        self.east
    }
    pub fn with_north(&mut self, north: bool) -> &mut Self {
        self.north = north;
        self
    }
    pub fn north(&self) -> bool {
        self.north
    }
    pub fn with_south(&mut self, south: bool) -> &mut Self {
        self.south = south;
        self
    }
    pub fn south(&self) -> bool {
        self.south
    }
    pub fn with_up(&mut self, up: bool) -> &mut Self {
        self.up = up;
        self
    }
    pub fn up(&self) -> bool {
        self.up
    }
    pub fn with_west(&mut self, west: bool) -> &mut Self {
        self.west = west;
        self
    }
    pub fn west(&self) -> bool {
        self.west
    }
}
impl Default for FireState {
    fn default() -> Self {
        FireState {
            age: 0,
            east: false,
            north: false,
            south: false,
            up: false,
            west: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct OakStairsState {
    facing: HorizontalFacing,
    half: SingleBlockHalf,
    shape: StairShape,
    waterlogged: bool,
}
impl OakStairsState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_half(&mut self, half: SingleBlockHalf) -> &mut Self {
        self.half = half;
        self
    }
    pub fn half(&self) -> SingleBlockHalf {
        self.half
    }
    pub fn with_shape(&mut self, shape: StairShape) -> &mut Self {
        self.shape = shape;
        self
    }
    pub fn shape(&self) -> StairShape {
        self.shape
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for OakStairsState {
    fn default() -> Self {
        OakStairsState {
            facing: HorizontalFacing::North,
            half: SingleBlockHalf::Bottom,
            shape: StairShape::Straight,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct ChestState {
    facing: HorizontalFacing,
    typed: ChestType,
    waterlogged: bool,
}
impl ChestState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_typed(&mut self, typed: ChestType) -> &mut Self {
        self.typed = typed;
        self
    }
    pub fn typed(&self) -> ChestType {
        self.typed
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for ChestState {
    fn default() -> Self {
        ChestState {
            facing: HorizontalFacing::North,
            typed: ChestType::Single,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct RedstoneWireState {
    east: RedstoneType,
    north: RedstoneType,
    power: i32,
    south: RedstoneType,
    west: RedstoneType,
}
impl RedstoneWireState {
    pub fn with_east(&mut self, east: RedstoneType) -> &mut Self {
        self.east = east;
        self
    }
    pub fn east(&self) -> RedstoneType {
        self.east
    }
    pub fn with_north(&mut self, north: RedstoneType) -> &mut Self {
        self.north = north;
        self
    }
    pub fn north(&self) -> RedstoneType {
        self.north
    }
    /// This is a value between 0 and 15 (both ends inclusive).\Developers should be careful to respect these bounds as no checking is done at runtime!!!
    pub fn with_power(&mut self, power: i32) -> &mut Self {
        self.power = power;
        self
    }
    pub fn power(&self) -> i32 {
        self.power
    }
    pub fn with_south(&mut self, south: RedstoneType) -> &mut Self {
        self.south = south;
        self
    }
    pub fn south(&self) -> RedstoneType {
        self.south
    }
    pub fn with_west(&mut self, west: RedstoneType) -> &mut Self {
        self.west = west;
        self
    }
    pub fn west(&self) -> RedstoneType {
        self.west
    }
}
impl Default for RedstoneWireState {
    fn default() -> Self {
        RedstoneWireState {
            east: RedstoneType::None,
            north: RedstoneType::None,
            power: 0,
            south: RedstoneType::None,
            west: RedstoneType::None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct WheatState {
    age: i32,
}
impl WheatState {
    /// This is a value between 0 and 7 (both ends inclusive).\Developers should be careful to respect these bounds as no checking is done at runtime!!!
    pub fn with_age(&mut self, age: i32) -> &mut Self {
        self.age = age;
        self
    }
    pub fn age(&self) -> i32 {
        self.age
    }
}
impl Default for WheatState {
    fn default() -> Self {
        WheatState {
            age: 0,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct FarmlandState {
    moisture: i32,
}
impl FarmlandState {
    /// This is a value between 0 and 7 (both ends inclusive).\Developers should be careful to respect these bounds as no checking is done at runtime!!!
    pub fn with_moisture(&mut self, moisture: i32) -> &mut Self {
        self.moisture = moisture;
        self
    }
    pub fn moisture(&self) -> i32 {
        self.moisture
    }
}
impl Default for FarmlandState {
    fn default() -> Self {
        FarmlandState {
            moisture: 0,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct FurnaceState {
    facing: HorizontalFacing,
    lit: bool,
}
impl FurnaceState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_lit(&mut self, lit: bool) -> &mut Self {
        self.lit = lit;
        self
    }
    pub fn lit(&self) -> bool {
        self.lit
    }
}
impl Default for FurnaceState {
    fn default() -> Self {
        FurnaceState {
            facing: HorizontalFacing::North,
            lit: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct OakSignState {
    rotation: i32,
    waterlogged: bool,
}
impl OakSignState {
    /// This is a value between 0 and 15 (both ends inclusive).\Developers should be careful to respect these bounds as no checking is done at runtime!!!
    pub fn with_rotation(&mut self, rotation: i32) -> &mut Self {
        self.rotation = rotation;
        self
    }
    pub fn rotation(&self) -> i32 {
        self.rotation
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for OakSignState {
    fn default() -> Self {
        OakSignState {
            rotation: 0,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct SpruceSignState {
    rotation: i32,
    waterlogged: bool,
}
impl SpruceSignState {
    /// This is a value between 0 and 15 (both ends inclusive).\Developers should be careful to respect these bounds as no checking is done at runtime!!!
    pub fn with_rotation(&mut self, rotation: i32) -> &mut Self {
        self.rotation = rotation;
        self
    }
    pub fn rotation(&self) -> i32 {
        self.rotation
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for SpruceSignState {
    fn default() -> Self {
        SpruceSignState {
            rotation: 0,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct BirchSignState {
    rotation: i32,
    waterlogged: bool,
}
impl BirchSignState {
    /// This is a value between 0 and 15 (both ends inclusive).\Developers should be careful to respect these bounds as no checking is done at runtime!!!
    pub fn with_rotation(&mut self, rotation: i32) -> &mut Self {
        self.rotation = rotation;
        self
    }
    pub fn rotation(&self) -> i32 {
        self.rotation
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for BirchSignState {
    fn default() -> Self {
        BirchSignState {
            rotation: 0,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct AcaciaSignState {
    rotation: i32,
    waterlogged: bool,
}
impl AcaciaSignState {
    /// This is a value between 0 and 15 (both ends inclusive).\Developers should be careful to respect these bounds as no checking is done at runtime!!!
    pub fn with_rotation(&mut self, rotation: i32) -> &mut Self {
        self.rotation = rotation;
        self
    }
    pub fn rotation(&self) -> i32 {
        self.rotation
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for AcaciaSignState {
    fn default() -> Self {
        AcaciaSignState {
            rotation: 0,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct JungleSignState {
    rotation: i32,
    waterlogged: bool,
}
impl JungleSignState {
    /// This is a value between 0 and 15 (both ends inclusive).\Developers should be careful to respect these bounds as no checking is done at runtime!!!
    pub fn with_rotation(&mut self, rotation: i32) -> &mut Self {
        self.rotation = rotation;
        self
    }
    pub fn rotation(&self) -> i32 {
        self.rotation
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for JungleSignState {
    fn default() -> Self {
        JungleSignState {
            rotation: 0,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct DarkOakSignState {
    rotation: i32,
    waterlogged: bool,
}
impl DarkOakSignState {
    /// This is a value between 0 and 15 (both ends inclusive).\Developers should be careful to respect these bounds as no checking is done at runtime!!!
    pub fn with_rotation(&mut self, rotation: i32) -> &mut Self {
        self.rotation = rotation;
        self
    }
    pub fn rotation(&self) -> i32 {
        self.rotation
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for DarkOakSignState {
    fn default() -> Self {
        DarkOakSignState {
            rotation: 0,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct OakDoorState {
    facing: HorizontalFacing,
    half: DoubleBlockHalf,
    hinge: Hinge,
    open: bool,
    powered: bool,
}
impl OakDoorState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_half(&mut self, half: DoubleBlockHalf) -> &mut Self {
        self.half = half;
        self
    }
    pub fn half(&self) -> DoubleBlockHalf {
        self.half
    }
    pub fn with_hinge(&mut self, hinge: Hinge) -> &mut Self {
        self.hinge = hinge;
        self
    }
    pub fn hinge(&self) -> Hinge {
        self.hinge
    }
    pub fn with_open(&mut self, open: bool) -> &mut Self {
        self.open = open;
        self
    }
    pub fn open(&self) -> bool {
        self.open
    }
    pub fn with_powered(&mut self, powered: bool) -> &mut Self {
        self.powered = powered;
        self
    }
    pub fn powered(&self) -> bool {
        self.powered
    }
}
impl Default for OakDoorState {
    fn default() -> Self {
        OakDoorState {
            facing: HorizontalFacing::North,
            half: DoubleBlockHalf::Lower,
            hinge: Hinge::Left,
            open: false,
            powered: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct LadderState {
    facing: HorizontalFacing,
    waterlogged: bool,
}
impl LadderState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for LadderState {
    fn default() -> Self {
        LadderState {
            facing: HorizontalFacing::North,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct RailState {
    shape: RailShape,
    waterlogged: bool,
}
impl RailState {
    pub fn with_shape(&mut self, shape: RailShape) -> &mut Self {
        self.shape = shape;
        self
    }
    pub fn shape(&self) -> RailShape {
        self.shape
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for RailState {
    fn default() -> Self {
        RailState {
            shape: RailShape::NorthSouth,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct CobblestoneStairsState {
    facing: HorizontalFacing,
    half: SingleBlockHalf,
    shape: StairShape,
    waterlogged: bool,
}
impl CobblestoneStairsState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_half(&mut self, half: SingleBlockHalf) -> &mut Self {
        self.half = half;
        self
    }
    pub fn half(&self) -> SingleBlockHalf {
        self.half
    }
    pub fn with_shape(&mut self, shape: StairShape) -> &mut Self {
        self.shape = shape;
        self
    }
    pub fn shape(&self) -> StairShape {
        self.shape
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for CobblestoneStairsState {
    fn default() -> Self {
        CobblestoneStairsState {
            facing: HorizontalFacing::North,
            half: SingleBlockHalf::Bottom,
            shape: StairShape::Straight,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct OakWallSignState {
    facing: HorizontalFacing,
    waterlogged: bool,
}
impl OakWallSignState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for OakWallSignState {
    fn default() -> Self {
        OakWallSignState {
            facing: HorizontalFacing::North,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct SpruceWallSignState {
    facing: HorizontalFacing,
    waterlogged: bool,
}
impl SpruceWallSignState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for SpruceWallSignState {
    fn default() -> Self {
        SpruceWallSignState {
            facing: HorizontalFacing::North,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct BirchWallSignState {
    facing: HorizontalFacing,
    waterlogged: bool,
}
impl BirchWallSignState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for BirchWallSignState {
    fn default() -> Self {
        BirchWallSignState {
            facing: HorizontalFacing::North,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct AcaciaWallSignState {
    facing: HorizontalFacing,
    waterlogged: bool,
}
impl AcaciaWallSignState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for AcaciaWallSignState {
    fn default() -> Self {
        AcaciaWallSignState {
            facing: HorizontalFacing::North,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct JungleWallSignState {
    facing: HorizontalFacing,
    waterlogged: bool,
}
impl JungleWallSignState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for JungleWallSignState {
    fn default() -> Self {
        JungleWallSignState {
            facing: HorizontalFacing::North,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct DarkOakWallSignState {
    facing: HorizontalFacing,
    waterlogged: bool,
}
impl DarkOakWallSignState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for DarkOakWallSignState {
    fn default() -> Self {
        DarkOakWallSignState {
            facing: HorizontalFacing::North,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct LeverState {
    face: Face,
    facing: HorizontalFacing,
    powered: bool,
}
impl LeverState {
    pub fn with_face(&mut self, face: Face) -> &mut Self {
        self.face = face;
        self
    }
    pub fn face(&self) -> Face {
        self.face
    }
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_powered(&mut self, powered: bool) -> &mut Self {
        self.powered = powered;
        self
    }
    pub fn powered(&self) -> bool {
        self.powered
    }
}
impl Default for LeverState {
    fn default() -> Self {
        LeverState {
            face: Face::Wall,
            facing: HorizontalFacing::North,
            powered: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct StonePressurePlateState {
    powered: bool,
}
impl StonePressurePlateState {
    pub fn with_powered(&mut self, powered: bool) -> &mut Self {
        self.powered = powered;
        self
    }
    pub fn powered(&self) -> bool {
        self.powered
    }
}
impl Default for StonePressurePlateState {
    fn default() -> Self {
        StonePressurePlateState {
            powered: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct IronDoorState {
    facing: HorizontalFacing,
    half: DoubleBlockHalf,
    hinge: Hinge,
    open: bool,
    powered: bool,
}
impl IronDoorState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_half(&mut self, half: DoubleBlockHalf) -> &mut Self {
        self.half = half;
        self
    }
    pub fn half(&self) -> DoubleBlockHalf {
        self.half
    }
    pub fn with_hinge(&mut self, hinge: Hinge) -> &mut Self {
        self.hinge = hinge;
        self
    }
    pub fn hinge(&self) -> Hinge {
        self.hinge
    }
    pub fn with_open(&mut self, open: bool) -> &mut Self {
        self.open = open;
        self
    }
    pub fn open(&self) -> bool {
        self.open
    }
    pub fn with_powered(&mut self, powered: bool) -> &mut Self {
        self.powered = powered;
        self
    }
    pub fn powered(&self) -> bool {
        self.powered
    }
}
impl Default for IronDoorState {
    fn default() -> Self {
        IronDoorState {
            facing: HorizontalFacing::North,
            half: DoubleBlockHalf::Lower,
            hinge: Hinge::Left,
            open: false,
            powered: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct OakPressurePlateState {
    powered: bool,
}
impl OakPressurePlateState {
    pub fn with_powered(&mut self, powered: bool) -> &mut Self {
        self.powered = powered;
        self
    }
    pub fn powered(&self) -> bool {
        self.powered
    }
}
impl Default for OakPressurePlateState {
    fn default() -> Self {
        OakPressurePlateState {
            powered: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct SprucePressurePlateState {
    powered: bool,
}
impl SprucePressurePlateState {
    pub fn with_powered(&mut self, powered: bool) -> &mut Self {
        self.powered = powered;
        self
    }
    pub fn powered(&self) -> bool {
        self.powered
    }
}
impl Default for SprucePressurePlateState {
    fn default() -> Self {
        SprucePressurePlateState {
            powered: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct BirchPressurePlateState {
    powered: bool,
}
impl BirchPressurePlateState {
    pub fn with_powered(&mut self, powered: bool) -> &mut Self {
        self.powered = powered;
        self
    }
    pub fn powered(&self) -> bool {
        self.powered
    }
}
impl Default for BirchPressurePlateState {
    fn default() -> Self {
        BirchPressurePlateState {
            powered: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct JunglePressurePlateState {
    powered: bool,
}
impl JunglePressurePlateState {
    pub fn with_powered(&mut self, powered: bool) -> &mut Self {
        self.powered = powered;
        self
    }
    pub fn powered(&self) -> bool {
        self.powered
    }
}
impl Default for JunglePressurePlateState {
    fn default() -> Self {
        JunglePressurePlateState {
            powered: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct AcaciaPressurePlateState {
    powered: bool,
}
impl AcaciaPressurePlateState {
    pub fn with_powered(&mut self, powered: bool) -> &mut Self {
        self.powered = powered;
        self
    }
    pub fn powered(&self) -> bool {
        self.powered
    }
}
impl Default for AcaciaPressurePlateState {
    fn default() -> Self {
        AcaciaPressurePlateState {
            powered: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct DarkOakPressurePlateState {
    powered: bool,
}
impl DarkOakPressurePlateState {
    pub fn with_powered(&mut self, powered: bool) -> &mut Self {
        self.powered = powered;
        self
    }
    pub fn powered(&self) -> bool {
        self.powered
    }
}
impl Default for DarkOakPressurePlateState {
    fn default() -> Self {
        DarkOakPressurePlateState {
            powered: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct RedstoneOreState {
    lit: bool,
}
impl RedstoneOreState {
    pub fn with_lit(&mut self, lit: bool) -> &mut Self {
        self.lit = lit;
        self
    }
    pub fn lit(&self) -> bool {
        self.lit
    }
}
impl Default for RedstoneOreState {
    fn default() -> Self {
        RedstoneOreState {
            lit: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct DeepslateRedstoneOreState {
    lit: bool,
}
impl DeepslateRedstoneOreState {
    pub fn with_lit(&mut self, lit: bool) -> &mut Self {
        self.lit = lit;
        self
    }
    pub fn lit(&self) -> bool {
        self.lit
    }
}
impl Default for DeepslateRedstoneOreState {
    fn default() -> Self {
        DeepslateRedstoneOreState {
            lit: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct RedstoneTorchState {
    lit: bool,
}
impl RedstoneTorchState {
    pub fn with_lit(&mut self, lit: bool) -> &mut Self {
        self.lit = lit;
        self
    }
    pub fn lit(&self) -> bool {
        self.lit
    }
}
impl Default for RedstoneTorchState {
    fn default() -> Self {
        RedstoneTorchState {
            lit: true,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct RedstoneWallTorchState {
    facing: HorizontalFacing,
    lit: bool,
}
impl RedstoneWallTorchState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_lit(&mut self, lit: bool) -> &mut Self {
        self.lit = lit;
        self
    }
    pub fn lit(&self) -> bool {
        self.lit
    }
}
impl Default for RedstoneWallTorchState {
    fn default() -> Self {
        RedstoneWallTorchState {
            facing: HorizontalFacing::North,
            lit: true,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct StoneButtonState {
    face: Face,
    facing: HorizontalFacing,
    powered: bool,
}
impl StoneButtonState {
    pub fn with_face(&mut self, face: Face) -> &mut Self {
        self.face = face;
        self
    }
    pub fn face(&self) -> Face {
        self.face
    }
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_powered(&mut self, powered: bool) -> &mut Self {
        self.powered = powered;
        self
    }
    pub fn powered(&self) -> bool {
        self.powered
    }
}
impl Default for StoneButtonState {
    fn default() -> Self {
        StoneButtonState {
            face: Face::Wall,
            facing: HorizontalFacing::North,
            powered: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct SnowState {
    layers: i32,
}
impl SnowState {
    /// This is a value between 1 and 8 (both ends inclusive).\Developers should be careful to respect these bounds as no checking is done at runtime!!!
    pub fn with_layers(&mut self, layers: i32) -> &mut Self {
        self.layers = layers - 1;
        self
    }
    pub fn layers(&self) -> i32 {
        self.layers + 1
    }
}
impl Default for SnowState {
    fn default() -> Self {
        SnowState {
            layers: 0,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct CactusState {
    age: i32,
}
impl CactusState {
    /// This is a value between 0 and 15 (both ends inclusive).\Developers should be careful to respect these bounds as no checking is done at runtime!!!
    pub fn with_age(&mut self, age: i32) -> &mut Self {
        self.age = age;
        self
    }
    pub fn age(&self) -> i32 {
        self.age
    }
}
impl Default for CactusState {
    fn default() -> Self {
        CactusState {
            age: 0,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct SugarCaneState {
    age: i32,
}
impl SugarCaneState {
    /// This is a value between 0 and 15 (both ends inclusive).\Developers should be careful to respect these bounds as no checking is done at runtime!!!
    pub fn with_age(&mut self, age: i32) -> &mut Self {
        self.age = age;
        self
    }
    pub fn age(&self) -> i32 {
        self.age
    }
}
impl Default for SugarCaneState {
    fn default() -> Self {
        SugarCaneState {
            age: 0,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct JukeboxState {
    has_record: bool,
}
impl JukeboxState {
    pub fn with_has_record(&mut self, has_record: bool) -> &mut Self {
        self.has_record = has_record;
        self
    }
    pub fn has_record(&self) -> bool {
        self.has_record
    }
}
impl Default for JukeboxState {
    fn default() -> Self {
        JukeboxState {
            has_record: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct OakFenceState {
    east: bool,
    north: bool,
    south: bool,
    waterlogged: bool,
    west: bool,
}
impl OakFenceState {
    pub fn with_east(&mut self, east: bool) -> &mut Self {
        self.east = east;
        self
    }
    pub fn east(&self) -> bool {
        self.east
    }
    pub fn with_north(&mut self, north: bool) -> &mut Self {
        self.north = north;
        self
    }
    pub fn north(&self) -> bool {
        self.north
    }
    pub fn with_south(&mut self, south: bool) -> &mut Self {
        self.south = south;
        self
    }
    pub fn south(&self) -> bool {
        self.south
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
    pub fn with_west(&mut self, west: bool) -> &mut Self {
        self.west = west;
        self
    }
    pub fn west(&self) -> bool {
        self.west
    }
}
impl Default for OakFenceState {
    fn default() -> Self {
        OakFenceState {
            east: false,
            north: false,
            south: false,
            waterlogged: false,
            west: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct BasaltState {
    axis: Axis,
}
impl BasaltState {
    pub fn with_axis(&mut self, axis: Axis) -> &mut Self {
        self.axis = axis;
        self
    }
    pub fn axis(&self) -> Axis {
        self.axis
    }
}
impl Default for BasaltState {
    fn default() -> Self {
        BasaltState {
            axis: Axis::Y,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct PolishedBasaltState {
    axis: Axis,
}
impl PolishedBasaltState {
    pub fn with_axis(&mut self, axis: Axis) -> &mut Self {
        self.axis = axis;
        self
    }
    pub fn axis(&self) -> Axis {
        self.axis
    }
}
impl Default for PolishedBasaltState {
    fn default() -> Self {
        PolishedBasaltState {
            axis: Axis::Y,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct SoulWallTorchState {
    facing: HorizontalFacing,
}
impl SoulWallTorchState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
}
impl Default for SoulWallTorchState {
    fn default() -> Self {
        SoulWallTorchState {
            facing: HorizontalFacing::North,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct NetherPortalState {
    axis: PortalAxis,
}
impl NetherPortalState {
    pub fn with_axis(&mut self, axis: PortalAxis) -> &mut Self {
        self.axis = axis;
        self
    }
    pub fn axis(&self) -> PortalAxis {
        self.axis
    }
}
impl Default for NetherPortalState {
    fn default() -> Self {
        NetherPortalState {
            axis: PortalAxis::X,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct CarvedPumpkinState {
    facing: HorizontalFacing,
}
impl CarvedPumpkinState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
}
impl Default for CarvedPumpkinState {
    fn default() -> Self {
        CarvedPumpkinState {
            facing: HorizontalFacing::North,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct JackOLanternState {
    facing: HorizontalFacing,
}
impl JackOLanternState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
}
impl Default for JackOLanternState {
    fn default() -> Self {
        JackOLanternState {
            facing: HorizontalFacing::North,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct CakeState {
    bites: i32,
}
impl CakeState {
    /// This is a value between 0 and 6 (both ends inclusive).\Developers should be careful to respect these bounds as no checking is done at runtime!!!
    pub fn with_bites(&mut self, bites: i32) -> &mut Self {
        self.bites = bites;
        self
    }
    pub fn bites(&self) -> i32 {
        self.bites
    }
}
impl Default for CakeState {
    fn default() -> Self {
        CakeState {
            bites: 0,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct RepeaterState {
    delay: i32,
    facing: HorizontalFacing,
    locked: bool,
    powered: bool,
}
impl RepeaterState {
    /// This is a value between 1 and 4 (both ends inclusive).\Developers should be careful to respect these bounds as no checking is done at runtime!!!
    pub fn with_delay(&mut self, delay: i32) -> &mut Self {
        self.delay = delay - 1;
        self
    }
    pub fn delay(&self) -> i32 {
        self.delay + 1
    }
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_locked(&mut self, locked: bool) -> &mut Self {
        self.locked = locked;
        self
    }
    pub fn locked(&self) -> bool {
        self.locked
    }
    pub fn with_powered(&mut self, powered: bool) -> &mut Self {
        self.powered = powered;
        self
    }
    pub fn powered(&self) -> bool {
        self.powered
    }
}
impl Default for RepeaterState {
    fn default() -> Self {
        RepeaterState {
            delay: 0,
            facing: HorizontalFacing::North,
            locked: false,
            powered: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct OakTrapdoorState {
    facing: HorizontalFacing,
    half: SingleBlockHalf,
    open: bool,
    powered: bool,
    waterlogged: bool,
}
impl OakTrapdoorState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_half(&mut self, half: SingleBlockHalf) -> &mut Self {
        self.half = half;
        self
    }
    pub fn half(&self) -> SingleBlockHalf {
        self.half
    }
    pub fn with_open(&mut self, open: bool) -> &mut Self {
        self.open = open;
        self
    }
    pub fn open(&self) -> bool {
        self.open
    }
    pub fn with_powered(&mut self, powered: bool) -> &mut Self {
        self.powered = powered;
        self
    }
    pub fn powered(&self) -> bool {
        self.powered
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for OakTrapdoorState {
    fn default() -> Self {
        OakTrapdoorState {
            facing: HorizontalFacing::North,
            half: SingleBlockHalf::Bottom,
            open: false,
            powered: false,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct SpruceTrapdoorState {
    facing: HorizontalFacing,
    half: SingleBlockHalf,
    open: bool,
    powered: bool,
    waterlogged: bool,
}
impl SpruceTrapdoorState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_half(&mut self, half: SingleBlockHalf) -> &mut Self {
        self.half = half;
        self
    }
    pub fn half(&self) -> SingleBlockHalf {
        self.half
    }
    pub fn with_open(&mut self, open: bool) -> &mut Self {
        self.open = open;
        self
    }
    pub fn open(&self) -> bool {
        self.open
    }
    pub fn with_powered(&mut self, powered: bool) -> &mut Self {
        self.powered = powered;
        self
    }
    pub fn powered(&self) -> bool {
        self.powered
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for SpruceTrapdoorState {
    fn default() -> Self {
        SpruceTrapdoorState {
            facing: HorizontalFacing::North,
            half: SingleBlockHalf::Bottom,
            open: false,
            powered: false,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct BirchTrapdoorState {
    facing: HorizontalFacing,
    half: SingleBlockHalf,
    open: bool,
    powered: bool,
    waterlogged: bool,
}
impl BirchTrapdoorState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_half(&mut self, half: SingleBlockHalf) -> &mut Self {
        self.half = half;
        self
    }
    pub fn half(&self) -> SingleBlockHalf {
        self.half
    }
    pub fn with_open(&mut self, open: bool) -> &mut Self {
        self.open = open;
        self
    }
    pub fn open(&self) -> bool {
        self.open
    }
    pub fn with_powered(&mut self, powered: bool) -> &mut Self {
        self.powered = powered;
        self
    }
    pub fn powered(&self) -> bool {
        self.powered
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for BirchTrapdoorState {
    fn default() -> Self {
        BirchTrapdoorState {
            facing: HorizontalFacing::North,
            half: SingleBlockHalf::Bottom,
            open: false,
            powered: false,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct JungleTrapdoorState {
    facing: HorizontalFacing,
    half: SingleBlockHalf,
    open: bool,
    powered: bool,
    waterlogged: bool,
}
impl JungleTrapdoorState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_half(&mut self, half: SingleBlockHalf) -> &mut Self {
        self.half = half;
        self
    }
    pub fn half(&self) -> SingleBlockHalf {
        self.half
    }
    pub fn with_open(&mut self, open: bool) -> &mut Self {
        self.open = open;
        self
    }
    pub fn open(&self) -> bool {
        self.open
    }
    pub fn with_powered(&mut self, powered: bool) -> &mut Self {
        self.powered = powered;
        self
    }
    pub fn powered(&self) -> bool {
        self.powered
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for JungleTrapdoorState {
    fn default() -> Self {
        JungleTrapdoorState {
            facing: HorizontalFacing::North,
            half: SingleBlockHalf::Bottom,
            open: false,
            powered: false,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct AcaciaTrapdoorState {
    facing: HorizontalFacing,
    half: SingleBlockHalf,
    open: bool,
    powered: bool,
    waterlogged: bool,
}
impl AcaciaTrapdoorState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_half(&mut self, half: SingleBlockHalf) -> &mut Self {
        self.half = half;
        self
    }
    pub fn half(&self) -> SingleBlockHalf {
        self.half
    }
    pub fn with_open(&mut self, open: bool) -> &mut Self {
        self.open = open;
        self
    }
    pub fn open(&self) -> bool {
        self.open
    }
    pub fn with_powered(&mut self, powered: bool) -> &mut Self {
        self.powered = powered;
        self
    }
    pub fn powered(&self) -> bool {
        self.powered
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for AcaciaTrapdoorState {
    fn default() -> Self {
        AcaciaTrapdoorState {
            facing: HorizontalFacing::North,
            half: SingleBlockHalf::Bottom,
            open: false,
            powered: false,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct DarkOakTrapdoorState {
    facing: HorizontalFacing,
    half: SingleBlockHalf,
    open: bool,
    powered: bool,
    waterlogged: bool,
}
impl DarkOakTrapdoorState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_half(&mut self, half: SingleBlockHalf) -> &mut Self {
        self.half = half;
        self
    }
    pub fn half(&self) -> SingleBlockHalf {
        self.half
    }
    pub fn with_open(&mut self, open: bool) -> &mut Self {
        self.open = open;
        self
    }
    pub fn open(&self) -> bool {
        self.open
    }
    pub fn with_powered(&mut self, powered: bool) -> &mut Self {
        self.powered = powered;
        self
    }
    pub fn powered(&self) -> bool {
        self.powered
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for DarkOakTrapdoorState {
    fn default() -> Self {
        DarkOakTrapdoorState {
            facing: HorizontalFacing::North,
            half: SingleBlockHalf::Bottom,
            open: false,
            powered: false,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct BrownMushroomBlockState {
    down: bool,
    east: bool,
    north: bool,
    south: bool,
    up: bool,
    west: bool,
}
impl BrownMushroomBlockState {
    pub fn with_down(&mut self, down: bool) -> &mut Self {
        self.down = down;
        self
    }
    pub fn down(&self) -> bool {
        self.down
    }
    pub fn with_east(&mut self, east: bool) -> &mut Self {
        self.east = east;
        self
    }
    pub fn east(&self) -> bool {
        self.east
    }
    pub fn with_north(&mut self, north: bool) -> &mut Self {
        self.north = north;
        self
    }
    pub fn north(&self) -> bool {
        self.north
    }
    pub fn with_south(&mut self, south: bool) -> &mut Self {
        self.south = south;
        self
    }
    pub fn south(&self) -> bool {
        self.south
    }
    pub fn with_up(&mut self, up: bool) -> &mut Self {
        self.up = up;
        self
    }
    pub fn up(&self) -> bool {
        self.up
    }
    pub fn with_west(&mut self, west: bool) -> &mut Self {
        self.west = west;
        self
    }
    pub fn west(&self) -> bool {
        self.west
    }
}
impl Default for BrownMushroomBlockState {
    fn default() -> Self {
        BrownMushroomBlockState {
            down: true,
            east: true,
            north: true,
            south: true,
            up: true,
            west: true,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct RedMushroomBlockState {
    down: bool,
    east: bool,
    north: bool,
    south: bool,
    up: bool,
    west: bool,
}
impl RedMushroomBlockState {
    pub fn with_down(&mut self, down: bool) -> &mut Self {
        self.down = down;
        self
    }
    pub fn down(&self) -> bool {
        self.down
    }
    pub fn with_east(&mut self, east: bool) -> &mut Self {
        self.east = east;
        self
    }
    pub fn east(&self) -> bool {
        self.east
    }
    pub fn with_north(&mut self, north: bool) -> &mut Self {
        self.north = north;
        self
    }
    pub fn north(&self) -> bool {
        self.north
    }
    pub fn with_south(&mut self, south: bool) -> &mut Self {
        self.south = south;
        self
    }
    pub fn south(&self) -> bool {
        self.south
    }
    pub fn with_up(&mut self, up: bool) -> &mut Self {
        self.up = up;
        self
    }
    pub fn up(&self) -> bool {
        self.up
    }
    pub fn with_west(&mut self, west: bool) -> &mut Self {
        self.west = west;
        self
    }
    pub fn west(&self) -> bool {
        self.west
    }
}
impl Default for RedMushroomBlockState {
    fn default() -> Self {
        RedMushroomBlockState {
            down: true,
            east: true,
            north: true,
            south: true,
            up: true,
            west: true,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct MushroomStemState {
    down: bool,
    east: bool,
    north: bool,
    south: bool,
    up: bool,
    west: bool,
}
impl MushroomStemState {
    pub fn with_down(&mut self, down: bool) -> &mut Self {
        self.down = down;
        self
    }
    pub fn down(&self) -> bool {
        self.down
    }
    pub fn with_east(&mut self, east: bool) -> &mut Self {
        self.east = east;
        self
    }
    pub fn east(&self) -> bool {
        self.east
    }
    pub fn with_north(&mut self, north: bool) -> &mut Self {
        self.north = north;
        self
    }
    pub fn north(&self) -> bool {
        self.north
    }
    pub fn with_south(&mut self, south: bool) -> &mut Self {
        self.south = south;
        self
    }
    pub fn south(&self) -> bool {
        self.south
    }
    pub fn with_up(&mut self, up: bool) -> &mut Self {
        self.up = up;
        self
    }
    pub fn up(&self) -> bool {
        self.up
    }
    pub fn with_west(&mut self, west: bool) -> &mut Self {
        self.west = west;
        self
    }
    pub fn west(&self) -> bool {
        self.west
    }
}
impl Default for MushroomStemState {
    fn default() -> Self {
        MushroomStemState {
            down: true,
            east: true,
            north: true,
            south: true,
            up: true,
            west: true,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct IronBarsState {
    east: bool,
    north: bool,
    south: bool,
    waterlogged: bool,
    west: bool,
}
impl IronBarsState {
    pub fn with_east(&mut self, east: bool) -> &mut Self {
        self.east = east;
        self
    }
    pub fn east(&self) -> bool {
        self.east
    }
    pub fn with_north(&mut self, north: bool) -> &mut Self {
        self.north = north;
        self
    }
    pub fn north(&self) -> bool {
        self.north
    }
    pub fn with_south(&mut self, south: bool) -> &mut Self {
        self.south = south;
        self
    }
    pub fn south(&self) -> bool {
        self.south
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
    pub fn with_west(&mut self, west: bool) -> &mut Self {
        self.west = west;
        self
    }
    pub fn west(&self) -> bool {
        self.west
    }
}
impl Default for IronBarsState {
    fn default() -> Self {
        IronBarsState {
            east: false,
            north: false,
            south: false,
            waterlogged: false,
            west: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct ChainState {
    axis: Axis,
    waterlogged: bool,
}
impl ChainState {
    pub fn with_axis(&mut self, axis: Axis) -> &mut Self {
        self.axis = axis;
        self
    }
    pub fn axis(&self) -> Axis {
        self.axis
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for ChainState {
    fn default() -> Self {
        ChainState {
            axis: Axis::Y,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct GlassPaneState {
    east: bool,
    north: bool,
    south: bool,
    waterlogged: bool,
    west: bool,
}
impl GlassPaneState {
    pub fn with_east(&mut self, east: bool) -> &mut Self {
        self.east = east;
        self
    }
    pub fn east(&self) -> bool {
        self.east
    }
    pub fn with_north(&mut self, north: bool) -> &mut Self {
        self.north = north;
        self
    }
    pub fn north(&self) -> bool {
        self.north
    }
    pub fn with_south(&mut self, south: bool) -> &mut Self {
        self.south = south;
        self
    }
    pub fn south(&self) -> bool {
        self.south
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
    pub fn with_west(&mut self, west: bool) -> &mut Self {
        self.west = west;
        self
    }
    pub fn west(&self) -> bool {
        self.west
    }
}
impl Default for GlassPaneState {
    fn default() -> Self {
        GlassPaneState {
            east: false,
            north: false,
            south: false,
            waterlogged: false,
            west: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct AttachedPumpkinStemState {
    facing: HorizontalFacing,
}
impl AttachedPumpkinStemState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
}
impl Default for AttachedPumpkinStemState {
    fn default() -> Self {
        AttachedPumpkinStemState {
            facing: HorizontalFacing::North,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct AttachedMelonStemState {
    facing: HorizontalFacing,
}
impl AttachedMelonStemState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
}
impl Default for AttachedMelonStemState {
    fn default() -> Self {
        AttachedMelonStemState {
            facing: HorizontalFacing::North,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct PumpkinStemState {
    age: i32,
}
impl PumpkinStemState {
    /// This is a value between 0 and 7 (both ends inclusive).\Developers should be careful to respect these bounds as no checking is done at runtime!!!
    pub fn with_age(&mut self, age: i32) -> &mut Self {
        self.age = age;
        self
    }
    pub fn age(&self) -> i32 {
        self.age
    }
}
impl Default for PumpkinStemState {
    fn default() -> Self {
        PumpkinStemState {
            age: 0,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct MelonStemState {
    age: i32,
}
impl MelonStemState {
    /// This is a value between 0 and 7 (both ends inclusive).\Developers should be careful to respect these bounds as no checking is done at runtime!!!
    pub fn with_age(&mut self, age: i32) -> &mut Self {
        self.age = age;
        self
    }
    pub fn age(&self) -> i32 {
        self.age
    }
}
impl Default for MelonStemState {
    fn default() -> Self {
        MelonStemState {
            age: 0,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct VineState {
    east: bool,
    north: bool,
    south: bool,
    up: bool,
    west: bool,
}
impl VineState {
    pub fn with_east(&mut self, east: bool) -> &mut Self {
        self.east = east;
        self
    }
    pub fn east(&self) -> bool {
        self.east
    }
    pub fn with_north(&mut self, north: bool) -> &mut Self {
        self.north = north;
        self
    }
    pub fn north(&self) -> bool {
        self.north
    }
    pub fn with_south(&mut self, south: bool) -> &mut Self {
        self.south = south;
        self
    }
    pub fn south(&self) -> bool {
        self.south
    }
    pub fn with_up(&mut self, up: bool) -> &mut Self {
        self.up = up;
        self
    }
    pub fn up(&self) -> bool {
        self.up
    }
    pub fn with_west(&mut self, west: bool) -> &mut Self {
        self.west = west;
        self
    }
    pub fn west(&self) -> bool {
        self.west
    }
}
impl Default for VineState {
    fn default() -> Self {
        VineState {
            east: false,
            north: false,
            south: false,
            up: false,
            west: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct GlowLichenState {
    down: bool,
    east: bool,
    north: bool,
    south: bool,
    up: bool,
    waterlogged: bool,
    west: bool,
}
impl GlowLichenState {
    pub fn with_down(&mut self, down: bool) -> &mut Self {
        self.down = down;
        self
    }
    pub fn down(&self) -> bool {
        self.down
    }
    pub fn with_east(&mut self, east: bool) -> &mut Self {
        self.east = east;
        self
    }
    pub fn east(&self) -> bool {
        self.east
    }
    pub fn with_north(&mut self, north: bool) -> &mut Self {
        self.north = north;
        self
    }
    pub fn north(&self) -> bool {
        self.north
    }
    pub fn with_south(&mut self, south: bool) -> &mut Self {
        self.south = south;
        self
    }
    pub fn south(&self) -> bool {
        self.south
    }
    pub fn with_up(&mut self, up: bool) -> &mut Self {
        self.up = up;
        self
    }
    pub fn up(&self) -> bool {
        self.up
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
    pub fn with_west(&mut self, west: bool) -> &mut Self {
        self.west = west;
        self
    }
    pub fn west(&self) -> bool {
        self.west
    }
}
impl Default for GlowLichenState {
    fn default() -> Self {
        GlowLichenState {
            down: false,
            east: false,
            north: false,
            south: false,
            up: false,
            waterlogged: false,
            west: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct OakFenceGateState {
    facing: HorizontalFacing,
    in_wall: bool,
    open: bool,
    powered: bool,
}
impl OakFenceGateState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_in_wall(&mut self, in_wall: bool) -> &mut Self {
        self.in_wall = in_wall;
        self
    }
    pub fn in_wall(&self) -> bool {
        self.in_wall
    }
    pub fn with_open(&mut self, open: bool) -> &mut Self {
        self.open = open;
        self
    }
    pub fn open(&self) -> bool {
        self.open
    }
    pub fn with_powered(&mut self, powered: bool) -> &mut Self {
        self.powered = powered;
        self
    }
    pub fn powered(&self) -> bool {
        self.powered
    }
}
impl Default for OakFenceGateState {
    fn default() -> Self {
        OakFenceGateState {
            facing: HorizontalFacing::North,
            in_wall: false,
            open: false,
            powered: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct BrickStairsState {
    facing: HorizontalFacing,
    half: SingleBlockHalf,
    shape: StairShape,
    waterlogged: bool,
}
impl BrickStairsState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_half(&mut self, half: SingleBlockHalf) -> &mut Self {
        self.half = half;
        self
    }
    pub fn half(&self) -> SingleBlockHalf {
        self.half
    }
    pub fn with_shape(&mut self, shape: StairShape) -> &mut Self {
        self.shape = shape;
        self
    }
    pub fn shape(&self) -> StairShape {
        self.shape
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for BrickStairsState {
    fn default() -> Self {
        BrickStairsState {
            facing: HorizontalFacing::North,
            half: SingleBlockHalf::Bottom,
            shape: StairShape::Straight,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct StoneBrickStairsState {
    facing: HorizontalFacing,
    half: SingleBlockHalf,
    shape: StairShape,
    waterlogged: bool,
}
impl StoneBrickStairsState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_half(&mut self, half: SingleBlockHalf) -> &mut Self {
        self.half = half;
        self
    }
    pub fn half(&self) -> SingleBlockHalf {
        self.half
    }
    pub fn with_shape(&mut self, shape: StairShape) -> &mut Self {
        self.shape = shape;
        self
    }
    pub fn shape(&self) -> StairShape {
        self.shape
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for StoneBrickStairsState {
    fn default() -> Self {
        StoneBrickStairsState {
            facing: HorizontalFacing::North,
            half: SingleBlockHalf::Bottom,
            shape: StairShape::Straight,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct MyceliumState {
    snowy: bool,
}
impl MyceliumState {
    pub fn with_snowy(&mut self, snowy: bool) -> &mut Self {
        self.snowy = snowy;
        self
    }
    pub fn snowy(&self) -> bool {
        self.snowy
    }
}
impl Default for MyceliumState {
    fn default() -> Self {
        MyceliumState {
            snowy: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct NetherBrickFenceState {
    east: bool,
    north: bool,
    south: bool,
    waterlogged: bool,
    west: bool,
}
impl NetherBrickFenceState {
    pub fn with_east(&mut self, east: bool) -> &mut Self {
        self.east = east;
        self
    }
    pub fn east(&self) -> bool {
        self.east
    }
    pub fn with_north(&mut self, north: bool) -> &mut Self {
        self.north = north;
        self
    }
    pub fn north(&self) -> bool {
        self.north
    }
    pub fn with_south(&mut self, south: bool) -> &mut Self {
        self.south = south;
        self
    }
    pub fn south(&self) -> bool {
        self.south
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
    pub fn with_west(&mut self, west: bool) -> &mut Self {
        self.west = west;
        self
    }
    pub fn west(&self) -> bool {
        self.west
    }
}
impl Default for NetherBrickFenceState {
    fn default() -> Self {
        NetherBrickFenceState {
            east: false,
            north: false,
            south: false,
            waterlogged: false,
            west: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct NetherBrickStairsState {
    facing: HorizontalFacing,
    half: SingleBlockHalf,
    shape: StairShape,
    waterlogged: bool,
}
impl NetherBrickStairsState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_half(&mut self, half: SingleBlockHalf) -> &mut Self {
        self.half = half;
        self
    }
    pub fn half(&self) -> SingleBlockHalf {
        self.half
    }
    pub fn with_shape(&mut self, shape: StairShape) -> &mut Self {
        self.shape = shape;
        self
    }
    pub fn shape(&self) -> StairShape {
        self.shape
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for NetherBrickStairsState {
    fn default() -> Self {
        NetherBrickStairsState {
            facing: HorizontalFacing::North,
            half: SingleBlockHalf::Bottom,
            shape: StairShape::Straight,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct NetherWartState {
    age: i32,
}
impl NetherWartState {
    /// This is a value between 0 and 3 (both ends inclusive).\Developers should be careful to respect these bounds as no checking is done at runtime!!!
    pub fn with_age(&mut self, age: i32) -> &mut Self {
        self.age = age;
        self
    }
    pub fn age(&self) -> i32 {
        self.age
    }
}
impl Default for NetherWartState {
    fn default() -> Self {
        NetherWartState {
            age: 0,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct BrewingStandState {
    has_bottle_0: bool,
    has_bottle_1: bool,
    has_bottle_2: bool,
}
impl BrewingStandState {
    pub fn with_has_bottle_0(&mut self, has_bottle_0: bool) -> &mut Self {
        self.has_bottle_0 = has_bottle_0;
        self
    }
    pub fn has_bottle_0(&self) -> bool {
        self.has_bottle_0
    }
    pub fn with_has_bottle_1(&mut self, has_bottle_1: bool) -> &mut Self {
        self.has_bottle_1 = has_bottle_1;
        self
    }
    pub fn has_bottle_1(&self) -> bool {
        self.has_bottle_1
    }
    pub fn with_has_bottle_2(&mut self, has_bottle_2: bool) -> &mut Self {
        self.has_bottle_2 = has_bottle_2;
        self
    }
    pub fn has_bottle_2(&self) -> bool {
        self.has_bottle_2
    }
}
impl Default for BrewingStandState {
    fn default() -> Self {
        BrewingStandState {
            has_bottle_0: false,
            has_bottle_1: false,
            has_bottle_2: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct WaterCauldronState {
    level: i32,
}
impl WaterCauldronState {
    /// This is a value between 1 and 3 (both ends inclusive).\Developers should be careful to respect these bounds as no checking is done at runtime!!!
    pub fn with_level(&mut self, level: i32) -> &mut Self {
        self.level = level - 1;
        self
    }
    pub fn level(&self) -> i32 {
        self.level + 1
    }
}
impl Default for WaterCauldronState {
    fn default() -> Self {
        WaterCauldronState {
            level: 0,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct PowderSnowCauldronState {
    level: i32,
}
impl PowderSnowCauldronState {
    /// This is a value between 1 and 3 (both ends inclusive).\Developers should be careful to respect these bounds as no checking is done at runtime!!!
    pub fn with_level(&mut self, level: i32) -> &mut Self {
        self.level = level - 1;
        self
    }
    pub fn level(&self) -> i32 {
        self.level + 1
    }
}
impl Default for PowderSnowCauldronState {
    fn default() -> Self {
        PowderSnowCauldronState {
            level: 0,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct EndPortalFrameState {
    eye: bool,
    facing: HorizontalFacing,
}
impl EndPortalFrameState {
    pub fn with_eye(&mut self, eye: bool) -> &mut Self {
        self.eye = eye;
        self
    }
    pub fn eye(&self) -> bool {
        self.eye
    }
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
}
impl Default for EndPortalFrameState {
    fn default() -> Self {
        EndPortalFrameState {
            eye: false,
            facing: HorizontalFacing::North,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct RedstoneLampState {
    lit: bool,
}
impl RedstoneLampState {
    pub fn with_lit(&mut self, lit: bool) -> &mut Self {
        self.lit = lit;
        self
    }
    pub fn lit(&self) -> bool {
        self.lit
    }
}
impl Default for RedstoneLampState {
    fn default() -> Self {
        RedstoneLampState {
            lit: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct CocoaState {
    age: i32,
    facing: HorizontalFacing,
}
impl CocoaState {
    /// This is a value between 0 and 2 (both ends inclusive).\Developers should be careful to respect these bounds as no checking is done at runtime!!!
    pub fn with_age(&mut self, age: i32) -> &mut Self {
        self.age = age;
        self
    }
    pub fn age(&self) -> i32 {
        self.age
    }
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
}
impl Default for CocoaState {
    fn default() -> Self {
        CocoaState {
            age: 0,
            facing: HorizontalFacing::North,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct SandstoneStairsState {
    facing: HorizontalFacing,
    half: SingleBlockHalf,
    shape: StairShape,
    waterlogged: bool,
}
impl SandstoneStairsState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_half(&mut self, half: SingleBlockHalf) -> &mut Self {
        self.half = half;
        self
    }
    pub fn half(&self) -> SingleBlockHalf {
        self.half
    }
    pub fn with_shape(&mut self, shape: StairShape) -> &mut Self {
        self.shape = shape;
        self
    }
    pub fn shape(&self) -> StairShape {
        self.shape
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for SandstoneStairsState {
    fn default() -> Self {
        SandstoneStairsState {
            facing: HorizontalFacing::North,
            half: SingleBlockHalf::Bottom,
            shape: StairShape::Straight,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct EnderChestState {
    facing: HorizontalFacing,
    waterlogged: bool,
}
impl EnderChestState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for EnderChestState {
    fn default() -> Self {
        EnderChestState {
            facing: HorizontalFacing::North,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct TripwireHookState {
    attached: bool,
    facing: HorizontalFacing,
    powered: bool,
}
impl TripwireHookState {
    pub fn with_attached(&mut self, attached: bool) -> &mut Self {
        self.attached = attached;
        self
    }
    pub fn attached(&self) -> bool {
        self.attached
    }
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_powered(&mut self, powered: bool) -> &mut Self {
        self.powered = powered;
        self
    }
    pub fn powered(&self) -> bool {
        self.powered
    }
}
impl Default for TripwireHookState {
    fn default() -> Self {
        TripwireHookState {
            attached: false,
            facing: HorizontalFacing::North,
            powered: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct TripwireState {
    attached: bool,
    disarmed: bool,
    east: bool,
    north: bool,
    powered: bool,
    south: bool,
    west: bool,
}
impl TripwireState {
    pub fn with_attached(&mut self, attached: bool) -> &mut Self {
        self.attached = attached;
        self
    }
    pub fn attached(&self) -> bool {
        self.attached
    }
    pub fn with_disarmed(&mut self, disarmed: bool) -> &mut Self {
        self.disarmed = disarmed;
        self
    }
    pub fn disarmed(&self) -> bool {
        self.disarmed
    }
    pub fn with_east(&mut self, east: bool) -> &mut Self {
        self.east = east;
        self
    }
    pub fn east(&self) -> bool {
        self.east
    }
    pub fn with_north(&mut self, north: bool) -> &mut Self {
        self.north = north;
        self
    }
    pub fn north(&self) -> bool {
        self.north
    }
    pub fn with_powered(&mut self, powered: bool) -> &mut Self {
        self.powered = powered;
        self
    }
    pub fn powered(&self) -> bool {
        self.powered
    }
    pub fn with_south(&mut self, south: bool) -> &mut Self {
        self.south = south;
        self
    }
    pub fn south(&self) -> bool {
        self.south
    }
    pub fn with_west(&mut self, west: bool) -> &mut Self {
        self.west = west;
        self
    }
    pub fn west(&self) -> bool {
        self.west
    }
}
impl Default for TripwireState {
    fn default() -> Self {
        TripwireState {
            attached: false,
            disarmed: false,
            east: false,
            north: false,
            powered: false,
            south: false,
            west: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct SpruceStairsState {
    facing: HorizontalFacing,
    half: SingleBlockHalf,
    shape: StairShape,
    waterlogged: bool,
}
impl SpruceStairsState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_half(&mut self, half: SingleBlockHalf) -> &mut Self {
        self.half = half;
        self
    }
    pub fn half(&self) -> SingleBlockHalf {
        self.half
    }
    pub fn with_shape(&mut self, shape: StairShape) -> &mut Self {
        self.shape = shape;
        self
    }
    pub fn shape(&self) -> StairShape {
        self.shape
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for SpruceStairsState {
    fn default() -> Self {
        SpruceStairsState {
            facing: HorizontalFacing::North,
            half: SingleBlockHalf::Bottom,
            shape: StairShape::Straight,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct BirchStairsState {
    facing: HorizontalFacing,
    half: SingleBlockHalf,
    shape: StairShape,
    waterlogged: bool,
}
impl BirchStairsState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_half(&mut self, half: SingleBlockHalf) -> &mut Self {
        self.half = half;
        self
    }
    pub fn half(&self) -> SingleBlockHalf {
        self.half
    }
    pub fn with_shape(&mut self, shape: StairShape) -> &mut Self {
        self.shape = shape;
        self
    }
    pub fn shape(&self) -> StairShape {
        self.shape
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for BirchStairsState {
    fn default() -> Self {
        BirchStairsState {
            facing: HorizontalFacing::North,
            half: SingleBlockHalf::Bottom,
            shape: StairShape::Straight,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct JungleStairsState {
    facing: HorizontalFacing,
    half: SingleBlockHalf,
    shape: StairShape,
    waterlogged: bool,
}
impl JungleStairsState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_half(&mut self, half: SingleBlockHalf) -> &mut Self {
        self.half = half;
        self
    }
    pub fn half(&self) -> SingleBlockHalf {
        self.half
    }
    pub fn with_shape(&mut self, shape: StairShape) -> &mut Self {
        self.shape = shape;
        self
    }
    pub fn shape(&self) -> StairShape {
        self.shape
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for JungleStairsState {
    fn default() -> Self {
        JungleStairsState {
            facing: HorizontalFacing::North,
            half: SingleBlockHalf::Bottom,
            shape: StairShape::Straight,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct CommandBlockState {
    conditional: bool,
    facing: AllFacing,
}
impl CommandBlockState {
    pub fn with_conditional(&mut self, conditional: bool) -> &mut Self {
        self.conditional = conditional;
        self
    }
    pub fn conditional(&self) -> bool {
        self.conditional
    }
    pub fn with_facing(&mut self, facing: AllFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> AllFacing {
        self.facing
    }
}
impl Default for CommandBlockState {
    fn default() -> Self {
        CommandBlockState {
            conditional: false,
            facing: AllFacing::North,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct CobblestoneWallState {
    east: WallType,
    north: WallType,
    south: WallType,
    up: bool,
    waterlogged: bool,
    west: WallType,
}
impl CobblestoneWallState {
    pub fn with_east(&mut self, east: WallType) -> &mut Self {
        self.east = east;
        self
    }
    pub fn east(&self) -> WallType {
        self.east
    }
    pub fn with_north(&mut self, north: WallType) -> &mut Self {
        self.north = north;
        self
    }
    pub fn north(&self) -> WallType {
        self.north
    }
    pub fn with_south(&mut self, south: WallType) -> &mut Self {
        self.south = south;
        self
    }
    pub fn south(&self) -> WallType {
        self.south
    }
    pub fn with_up(&mut self, up: bool) -> &mut Self {
        self.up = up;
        self
    }
    pub fn up(&self) -> bool {
        self.up
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
    pub fn with_west(&mut self, west: WallType) -> &mut Self {
        self.west = west;
        self
    }
    pub fn west(&self) -> WallType {
        self.west
    }
}
impl Default for CobblestoneWallState {
    fn default() -> Self {
        CobblestoneWallState {
            east: WallType::None,
            north: WallType::None,
            south: WallType::None,
            up: true,
            waterlogged: false,
            west: WallType::None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct MossyCobblestoneWallState {
    east: WallType,
    north: WallType,
    south: WallType,
    up: bool,
    waterlogged: bool,
    west: WallType,
}
impl MossyCobblestoneWallState {
    pub fn with_east(&mut self, east: WallType) -> &mut Self {
        self.east = east;
        self
    }
    pub fn east(&self) -> WallType {
        self.east
    }
    pub fn with_north(&mut self, north: WallType) -> &mut Self {
        self.north = north;
        self
    }
    pub fn north(&self) -> WallType {
        self.north
    }
    pub fn with_south(&mut self, south: WallType) -> &mut Self {
        self.south = south;
        self
    }
    pub fn south(&self) -> WallType {
        self.south
    }
    pub fn with_up(&mut self, up: bool) -> &mut Self {
        self.up = up;
        self
    }
    pub fn up(&self) -> bool {
        self.up
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
    pub fn with_west(&mut self, west: WallType) -> &mut Self {
        self.west = west;
        self
    }
    pub fn west(&self) -> WallType {
        self.west
    }
}
impl Default for MossyCobblestoneWallState {
    fn default() -> Self {
        MossyCobblestoneWallState {
            east: WallType::None,
            north: WallType::None,
            south: WallType::None,
            up: true,
            waterlogged: false,
            west: WallType::None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct CarrotsState {
    age: i32,
}
impl CarrotsState {
    /// This is a value between 0 and 7 (both ends inclusive).\Developers should be careful to respect these bounds as no checking is done at runtime!!!
    pub fn with_age(&mut self, age: i32) -> &mut Self {
        self.age = age;
        self
    }
    pub fn age(&self) -> i32 {
        self.age
    }
}
impl Default for CarrotsState {
    fn default() -> Self {
        CarrotsState {
            age: 0,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct PotatoesState {
    age: i32,
}
impl PotatoesState {
    /// This is a value between 0 and 7 (both ends inclusive).\Developers should be careful to respect these bounds as no checking is done at runtime!!!
    pub fn with_age(&mut self, age: i32) -> &mut Self {
        self.age = age;
        self
    }
    pub fn age(&self) -> i32 {
        self.age
    }
}
impl Default for PotatoesState {
    fn default() -> Self {
        PotatoesState {
            age: 0,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct OakButtonState {
    face: Face,
    facing: HorizontalFacing,
    powered: bool,
}
impl OakButtonState {
    pub fn with_face(&mut self, face: Face) -> &mut Self {
        self.face = face;
        self
    }
    pub fn face(&self) -> Face {
        self.face
    }
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_powered(&mut self, powered: bool) -> &mut Self {
        self.powered = powered;
        self
    }
    pub fn powered(&self) -> bool {
        self.powered
    }
}
impl Default for OakButtonState {
    fn default() -> Self {
        OakButtonState {
            face: Face::Wall,
            facing: HorizontalFacing::North,
            powered: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct SpruceButtonState {
    face: Face,
    facing: HorizontalFacing,
    powered: bool,
}
impl SpruceButtonState {
    pub fn with_face(&mut self, face: Face) -> &mut Self {
        self.face = face;
        self
    }
    pub fn face(&self) -> Face {
        self.face
    }
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_powered(&mut self, powered: bool) -> &mut Self {
        self.powered = powered;
        self
    }
    pub fn powered(&self) -> bool {
        self.powered
    }
}
impl Default for SpruceButtonState {
    fn default() -> Self {
        SpruceButtonState {
            face: Face::Wall,
            facing: HorizontalFacing::North,
            powered: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct BirchButtonState {
    face: Face,
    facing: HorizontalFacing,
    powered: bool,
}
impl BirchButtonState {
    pub fn with_face(&mut self, face: Face) -> &mut Self {
        self.face = face;
        self
    }
    pub fn face(&self) -> Face {
        self.face
    }
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_powered(&mut self, powered: bool) -> &mut Self {
        self.powered = powered;
        self
    }
    pub fn powered(&self) -> bool {
        self.powered
    }
}
impl Default for BirchButtonState {
    fn default() -> Self {
        BirchButtonState {
            face: Face::Wall,
            facing: HorizontalFacing::North,
            powered: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct JungleButtonState {
    face: Face,
    facing: HorizontalFacing,
    powered: bool,
}
impl JungleButtonState {
    pub fn with_face(&mut self, face: Face) -> &mut Self {
        self.face = face;
        self
    }
    pub fn face(&self) -> Face {
        self.face
    }
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_powered(&mut self, powered: bool) -> &mut Self {
        self.powered = powered;
        self
    }
    pub fn powered(&self) -> bool {
        self.powered
    }
}
impl Default for JungleButtonState {
    fn default() -> Self {
        JungleButtonState {
            face: Face::Wall,
            facing: HorizontalFacing::North,
            powered: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct AcaciaButtonState {
    face: Face,
    facing: HorizontalFacing,
    powered: bool,
}
impl AcaciaButtonState {
    pub fn with_face(&mut self, face: Face) -> &mut Self {
        self.face = face;
        self
    }
    pub fn face(&self) -> Face {
        self.face
    }
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_powered(&mut self, powered: bool) -> &mut Self {
        self.powered = powered;
        self
    }
    pub fn powered(&self) -> bool {
        self.powered
    }
}
impl Default for AcaciaButtonState {
    fn default() -> Self {
        AcaciaButtonState {
            face: Face::Wall,
            facing: HorizontalFacing::North,
            powered: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct DarkOakButtonState {
    face: Face,
    facing: HorizontalFacing,
    powered: bool,
}
impl DarkOakButtonState {
    pub fn with_face(&mut self, face: Face) -> &mut Self {
        self.face = face;
        self
    }
    pub fn face(&self) -> Face {
        self.face
    }
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_powered(&mut self, powered: bool) -> &mut Self {
        self.powered = powered;
        self
    }
    pub fn powered(&self) -> bool {
        self.powered
    }
}
impl Default for DarkOakButtonState {
    fn default() -> Self {
        DarkOakButtonState {
            face: Face::Wall,
            facing: HorizontalFacing::North,
            powered: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct SkeletonSkullState {
    rotation: i32,
}
impl SkeletonSkullState {
    /// This is a value between 0 and 15 (both ends inclusive).\Developers should be careful to respect these bounds as no checking is done at runtime!!!
    pub fn with_rotation(&mut self, rotation: i32) -> &mut Self {
        self.rotation = rotation;
        self
    }
    pub fn rotation(&self) -> i32 {
        self.rotation
    }
}
impl Default for SkeletonSkullState {
    fn default() -> Self {
        SkeletonSkullState {
            rotation: 0,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct SkeletonWallSkullState {
    facing: HorizontalFacing,
}
impl SkeletonWallSkullState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
}
impl Default for SkeletonWallSkullState {
    fn default() -> Self {
        SkeletonWallSkullState {
            facing: HorizontalFacing::North,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct WitherSkeletonSkullState {
    rotation: i32,
}
impl WitherSkeletonSkullState {
    /// This is a value between 0 and 15 (both ends inclusive).\Developers should be careful to respect these bounds as no checking is done at runtime!!!
    pub fn with_rotation(&mut self, rotation: i32) -> &mut Self {
        self.rotation = rotation;
        self
    }
    pub fn rotation(&self) -> i32 {
        self.rotation
    }
}
impl Default for WitherSkeletonSkullState {
    fn default() -> Self {
        WitherSkeletonSkullState {
            rotation: 0,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct WitherSkeletonWallSkullState {
    facing: HorizontalFacing,
}
impl WitherSkeletonWallSkullState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
}
impl Default for WitherSkeletonWallSkullState {
    fn default() -> Self {
        WitherSkeletonWallSkullState {
            facing: HorizontalFacing::North,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct ZombieHeadState {
    rotation: i32,
}
impl ZombieHeadState {
    /// This is a value between 0 and 15 (both ends inclusive).\Developers should be careful to respect these bounds as no checking is done at runtime!!!
    pub fn with_rotation(&mut self, rotation: i32) -> &mut Self {
        self.rotation = rotation;
        self
    }
    pub fn rotation(&self) -> i32 {
        self.rotation
    }
}
impl Default for ZombieHeadState {
    fn default() -> Self {
        ZombieHeadState {
            rotation: 0,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct ZombieWallHeadState {
    facing: HorizontalFacing,
}
impl ZombieWallHeadState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
}
impl Default for ZombieWallHeadState {
    fn default() -> Self {
        ZombieWallHeadState {
            facing: HorizontalFacing::North,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct PlayerHeadState {
    rotation: i32,
}
impl PlayerHeadState {
    /// This is a value between 0 and 15 (both ends inclusive).\Developers should be careful to respect these bounds as no checking is done at runtime!!!
    pub fn with_rotation(&mut self, rotation: i32) -> &mut Self {
        self.rotation = rotation;
        self
    }
    pub fn rotation(&self) -> i32 {
        self.rotation
    }
}
impl Default for PlayerHeadState {
    fn default() -> Self {
        PlayerHeadState {
            rotation: 0,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct PlayerWallHeadState {
    facing: HorizontalFacing,
}
impl PlayerWallHeadState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
}
impl Default for PlayerWallHeadState {
    fn default() -> Self {
        PlayerWallHeadState {
            facing: HorizontalFacing::North,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct CreeperHeadState {
    rotation: i32,
}
impl CreeperHeadState {
    /// This is a value between 0 and 15 (both ends inclusive).\Developers should be careful to respect these bounds as no checking is done at runtime!!!
    pub fn with_rotation(&mut self, rotation: i32) -> &mut Self {
        self.rotation = rotation;
        self
    }
    pub fn rotation(&self) -> i32 {
        self.rotation
    }
}
impl Default for CreeperHeadState {
    fn default() -> Self {
        CreeperHeadState {
            rotation: 0,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct CreeperWallHeadState {
    facing: HorizontalFacing,
}
impl CreeperWallHeadState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
}
impl Default for CreeperWallHeadState {
    fn default() -> Self {
        CreeperWallHeadState {
            facing: HorizontalFacing::North,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct DragonHeadState {
    rotation: i32,
}
impl DragonHeadState {
    /// This is a value between 0 and 15 (both ends inclusive).\Developers should be careful to respect these bounds as no checking is done at runtime!!!
    pub fn with_rotation(&mut self, rotation: i32) -> &mut Self {
        self.rotation = rotation;
        self
    }
    pub fn rotation(&self) -> i32 {
        self.rotation
    }
}
impl Default for DragonHeadState {
    fn default() -> Self {
        DragonHeadState {
            rotation: 0,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct DragonWallHeadState {
    facing: HorizontalFacing,
}
impl DragonWallHeadState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
}
impl Default for DragonWallHeadState {
    fn default() -> Self {
        DragonWallHeadState {
            facing: HorizontalFacing::North,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct AnvilState {
    facing: HorizontalFacing,
}
impl AnvilState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
}
impl Default for AnvilState {
    fn default() -> Self {
        AnvilState {
            facing: HorizontalFacing::North,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct ChippedAnvilState {
    facing: HorizontalFacing,
}
impl ChippedAnvilState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
}
impl Default for ChippedAnvilState {
    fn default() -> Self {
        ChippedAnvilState {
            facing: HorizontalFacing::North,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct DamagedAnvilState {
    facing: HorizontalFacing,
}
impl DamagedAnvilState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
}
impl Default for DamagedAnvilState {
    fn default() -> Self {
        DamagedAnvilState {
            facing: HorizontalFacing::North,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct TrappedChestState {
    facing: HorizontalFacing,
    typed: ChestType,
    waterlogged: bool,
}
impl TrappedChestState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_typed(&mut self, typed: ChestType) -> &mut Self {
        self.typed = typed;
        self
    }
    pub fn typed(&self) -> ChestType {
        self.typed
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for TrappedChestState {
    fn default() -> Self {
        TrappedChestState {
            facing: HorizontalFacing::North,
            typed: ChestType::Single,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct LightWeightedPressurePlateState {
    power: i32,
}
impl LightWeightedPressurePlateState {
    /// This is a value between 0 and 15 (both ends inclusive).\Developers should be careful to respect these bounds as no checking is done at runtime!!!
    pub fn with_power(&mut self, power: i32) -> &mut Self {
        self.power = power;
        self
    }
    pub fn power(&self) -> i32 {
        self.power
    }
}
impl Default for LightWeightedPressurePlateState {
    fn default() -> Self {
        LightWeightedPressurePlateState {
            power: 0,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct HeavyWeightedPressurePlateState {
    power: i32,
}
impl HeavyWeightedPressurePlateState {
    /// This is a value between 0 and 15 (both ends inclusive).\Developers should be careful to respect these bounds as no checking is done at runtime!!!
    pub fn with_power(&mut self, power: i32) -> &mut Self {
        self.power = power;
        self
    }
    pub fn power(&self) -> i32 {
        self.power
    }
}
impl Default for HeavyWeightedPressurePlateState {
    fn default() -> Self {
        HeavyWeightedPressurePlateState {
            power: 0,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct ComparatorState {
    facing: HorizontalFacing,
    mode: ComparatorMode,
    powered: bool,
}
impl ComparatorState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_mode(&mut self, mode: ComparatorMode) -> &mut Self {
        self.mode = mode;
        self
    }
    pub fn mode(&self) -> ComparatorMode {
        self.mode
    }
    pub fn with_powered(&mut self, powered: bool) -> &mut Self {
        self.powered = powered;
        self
    }
    pub fn powered(&self) -> bool {
        self.powered
    }
}
impl Default for ComparatorState {
    fn default() -> Self {
        ComparatorState {
            facing: HorizontalFacing::North,
            mode: ComparatorMode::Compare,
            powered: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct DaylightDetectorState {
    inverted: bool,
    power: i32,
}
impl DaylightDetectorState {
    pub fn with_inverted(&mut self, inverted: bool) -> &mut Self {
        self.inverted = inverted;
        self
    }
    pub fn inverted(&self) -> bool {
        self.inverted
    }
    /// This is a value between 0 and 15 (both ends inclusive).\Developers should be careful to respect these bounds as no checking is done at runtime!!!
    pub fn with_power(&mut self, power: i32) -> &mut Self {
        self.power = power;
        self
    }
    pub fn power(&self) -> i32 {
        self.power
    }
}
impl Default for DaylightDetectorState {
    fn default() -> Self {
        DaylightDetectorState {
            inverted: false,
            power: 0,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct HopperState {
    enabled: bool,
    facing: HopperFacing,
}
impl HopperState {
    pub fn with_enabled(&mut self, enabled: bool) -> &mut Self {
        self.enabled = enabled;
        self
    }
    pub fn enabled(&self) -> bool {
        self.enabled
    }
    pub fn with_facing(&mut self, facing: HopperFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HopperFacing {
        self.facing
    }
}
impl Default for HopperState {
    fn default() -> Self {
        HopperState {
            enabled: true,
            facing: HopperFacing::Down,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct QuartzPillarState {
    axis: Axis,
}
impl QuartzPillarState {
    pub fn with_axis(&mut self, axis: Axis) -> &mut Self {
        self.axis = axis;
        self
    }
    pub fn axis(&self) -> Axis {
        self.axis
    }
}
impl Default for QuartzPillarState {
    fn default() -> Self {
        QuartzPillarState {
            axis: Axis::Y,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct QuartzStairsState {
    facing: HorizontalFacing,
    half: SingleBlockHalf,
    shape: StairShape,
    waterlogged: bool,
}
impl QuartzStairsState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_half(&mut self, half: SingleBlockHalf) -> &mut Self {
        self.half = half;
        self
    }
    pub fn half(&self) -> SingleBlockHalf {
        self.half
    }
    pub fn with_shape(&mut self, shape: StairShape) -> &mut Self {
        self.shape = shape;
        self
    }
    pub fn shape(&self) -> StairShape {
        self.shape
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for QuartzStairsState {
    fn default() -> Self {
        QuartzStairsState {
            facing: HorizontalFacing::North,
            half: SingleBlockHalf::Bottom,
            shape: StairShape::Straight,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct ActivatorRailState {
    powered: bool,
    shape: StraightRailShape,
    waterlogged: bool,
}
impl ActivatorRailState {
    pub fn with_powered(&mut self, powered: bool) -> &mut Self {
        self.powered = powered;
        self
    }
    pub fn powered(&self) -> bool {
        self.powered
    }
    pub fn with_shape(&mut self, shape: StraightRailShape) -> &mut Self {
        self.shape = shape;
        self
    }
    pub fn shape(&self) -> StraightRailShape {
        self.shape
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for ActivatorRailState {
    fn default() -> Self {
        ActivatorRailState {
            powered: false,
            shape: StraightRailShape::NorthSouth,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct DropperState {
    facing: AllFacing,
    triggered: bool,
}
impl DropperState {
    pub fn with_facing(&mut self, facing: AllFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> AllFacing {
        self.facing
    }
    pub fn with_triggered(&mut self, triggered: bool) -> &mut Self {
        self.triggered = triggered;
        self
    }
    pub fn triggered(&self) -> bool {
        self.triggered
    }
}
impl Default for DropperState {
    fn default() -> Self {
        DropperState {
            facing: AllFacing::North,
            triggered: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct WhiteStainedGlassPaneState {
    east: bool,
    north: bool,
    south: bool,
    waterlogged: bool,
    west: bool,
}
impl WhiteStainedGlassPaneState {
    pub fn with_east(&mut self, east: bool) -> &mut Self {
        self.east = east;
        self
    }
    pub fn east(&self) -> bool {
        self.east
    }
    pub fn with_north(&mut self, north: bool) -> &mut Self {
        self.north = north;
        self
    }
    pub fn north(&self) -> bool {
        self.north
    }
    pub fn with_south(&mut self, south: bool) -> &mut Self {
        self.south = south;
        self
    }
    pub fn south(&self) -> bool {
        self.south
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
    pub fn with_west(&mut self, west: bool) -> &mut Self {
        self.west = west;
        self
    }
    pub fn west(&self) -> bool {
        self.west
    }
}
impl Default for WhiteStainedGlassPaneState {
    fn default() -> Self {
        WhiteStainedGlassPaneState {
            east: false,
            north: false,
            south: false,
            waterlogged: false,
            west: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct OrangeStainedGlassPaneState {
    east: bool,
    north: bool,
    south: bool,
    waterlogged: bool,
    west: bool,
}
impl OrangeStainedGlassPaneState {
    pub fn with_east(&mut self, east: bool) -> &mut Self {
        self.east = east;
        self
    }
    pub fn east(&self) -> bool {
        self.east
    }
    pub fn with_north(&mut self, north: bool) -> &mut Self {
        self.north = north;
        self
    }
    pub fn north(&self) -> bool {
        self.north
    }
    pub fn with_south(&mut self, south: bool) -> &mut Self {
        self.south = south;
        self
    }
    pub fn south(&self) -> bool {
        self.south
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
    pub fn with_west(&mut self, west: bool) -> &mut Self {
        self.west = west;
        self
    }
    pub fn west(&self) -> bool {
        self.west
    }
}
impl Default for OrangeStainedGlassPaneState {
    fn default() -> Self {
        OrangeStainedGlassPaneState {
            east: false,
            north: false,
            south: false,
            waterlogged: false,
            west: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct MagentaStainedGlassPaneState {
    east: bool,
    north: bool,
    south: bool,
    waterlogged: bool,
    west: bool,
}
impl MagentaStainedGlassPaneState {
    pub fn with_east(&mut self, east: bool) -> &mut Self {
        self.east = east;
        self
    }
    pub fn east(&self) -> bool {
        self.east
    }
    pub fn with_north(&mut self, north: bool) -> &mut Self {
        self.north = north;
        self
    }
    pub fn north(&self) -> bool {
        self.north
    }
    pub fn with_south(&mut self, south: bool) -> &mut Self {
        self.south = south;
        self
    }
    pub fn south(&self) -> bool {
        self.south
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
    pub fn with_west(&mut self, west: bool) -> &mut Self {
        self.west = west;
        self
    }
    pub fn west(&self) -> bool {
        self.west
    }
}
impl Default for MagentaStainedGlassPaneState {
    fn default() -> Self {
        MagentaStainedGlassPaneState {
            east: false,
            north: false,
            south: false,
            waterlogged: false,
            west: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct LightBlueStainedGlassPaneState {
    east: bool,
    north: bool,
    south: bool,
    waterlogged: bool,
    west: bool,
}
impl LightBlueStainedGlassPaneState {
    pub fn with_east(&mut self, east: bool) -> &mut Self {
        self.east = east;
        self
    }
    pub fn east(&self) -> bool {
        self.east
    }
    pub fn with_north(&mut self, north: bool) -> &mut Self {
        self.north = north;
        self
    }
    pub fn north(&self) -> bool {
        self.north
    }
    pub fn with_south(&mut self, south: bool) -> &mut Self {
        self.south = south;
        self
    }
    pub fn south(&self) -> bool {
        self.south
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
    pub fn with_west(&mut self, west: bool) -> &mut Self {
        self.west = west;
        self
    }
    pub fn west(&self) -> bool {
        self.west
    }
}
impl Default for LightBlueStainedGlassPaneState {
    fn default() -> Self {
        LightBlueStainedGlassPaneState {
            east: false,
            north: false,
            south: false,
            waterlogged: false,
            west: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct YellowStainedGlassPaneState {
    east: bool,
    north: bool,
    south: bool,
    waterlogged: bool,
    west: bool,
}
impl YellowStainedGlassPaneState {
    pub fn with_east(&mut self, east: bool) -> &mut Self {
        self.east = east;
        self
    }
    pub fn east(&self) -> bool {
        self.east
    }
    pub fn with_north(&mut self, north: bool) -> &mut Self {
        self.north = north;
        self
    }
    pub fn north(&self) -> bool {
        self.north
    }
    pub fn with_south(&mut self, south: bool) -> &mut Self {
        self.south = south;
        self
    }
    pub fn south(&self) -> bool {
        self.south
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
    pub fn with_west(&mut self, west: bool) -> &mut Self {
        self.west = west;
        self
    }
    pub fn west(&self) -> bool {
        self.west
    }
}
impl Default for YellowStainedGlassPaneState {
    fn default() -> Self {
        YellowStainedGlassPaneState {
            east: false,
            north: false,
            south: false,
            waterlogged: false,
            west: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct LimeStainedGlassPaneState {
    east: bool,
    north: bool,
    south: bool,
    waterlogged: bool,
    west: bool,
}
impl LimeStainedGlassPaneState {
    pub fn with_east(&mut self, east: bool) -> &mut Self {
        self.east = east;
        self
    }
    pub fn east(&self) -> bool {
        self.east
    }
    pub fn with_north(&mut self, north: bool) -> &mut Self {
        self.north = north;
        self
    }
    pub fn north(&self) -> bool {
        self.north
    }
    pub fn with_south(&mut self, south: bool) -> &mut Self {
        self.south = south;
        self
    }
    pub fn south(&self) -> bool {
        self.south
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
    pub fn with_west(&mut self, west: bool) -> &mut Self {
        self.west = west;
        self
    }
    pub fn west(&self) -> bool {
        self.west
    }
}
impl Default for LimeStainedGlassPaneState {
    fn default() -> Self {
        LimeStainedGlassPaneState {
            east: false,
            north: false,
            south: false,
            waterlogged: false,
            west: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct PinkStainedGlassPaneState {
    east: bool,
    north: bool,
    south: bool,
    waterlogged: bool,
    west: bool,
}
impl PinkStainedGlassPaneState {
    pub fn with_east(&mut self, east: bool) -> &mut Self {
        self.east = east;
        self
    }
    pub fn east(&self) -> bool {
        self.east
    }
    pub fn with_north(&mut self, north: bool) -> &mut Self {
        self.north = north;
        self
    }
    pub fn north(&self) -> bool {
        self.north
    }
    pub fn with_south(&mut self, south: bool) -> &mut Self {
        self.south = south;
        self
    }
    pub fn south(&self) -> bool {
        self.south
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
    pub fn with_west(&mut self, west: bool) -> &mut Self {
        self.west = west;
        self
    }
    pub fn west(&self) -> bool {
        self.west
    }
}
impl Default for PinkStainedGlassPaneState {
    fn default() -> Self {
        PinkStainedGlassPaneState {
            east: false,
            north: false,
            south: false,
            waterlogged: false,
            west: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct GrayStainedGlassPaneState {
    east: bool,
    north: bool,
    south: bool,
    waterlogged: bool,
    west: bool,
}
impl GrayStainedGlassPaneState {
    pub fn with_east(&mut self, east: bool) -> &mut Self {
        self.east = east;
        self
    }
    pub fn east(&self) -> bool {
        self.east
    }
    pub fn with_north(&mut self, north: bool) -> &mut Self {
        self.north = north;
        self
    }
    pub fn north(&self) -> bool {
        self.north
    }
    pub fn with_south(&mut self, south: bool) -> &mut Self {
        self.south = south;
        self
    }
    pub fn south(&self) -> bool {
        self.south
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
    pub fn with_west(&mut self, west: bool) -> &mut Self {
        self.west = west;
        self
    }
    pub fn west(&self) -> bool {
        self.west
    }
}
impl Default for GrayStainedGlassPaneState {
    fn default() -> Self {
        GrayStainedGlassPaneState {
            east: false,
            north: false,
            south: false,
            waterlogged: false,
            west: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct LightGrayStainedGlassPaneState {
    east: bool,
    north: bool,
    south: bool,
    waterlogged: bool,
    west: bool,
}
impl LightGrayStainedGlassPaneState {
    pub fn with_east(&mut self, east: bool) -> &mut Self {
        self.east = east;
        self
    }
    pub fn east(&self) -> bool {
        self.east
    }
    pub fn with_north(&mut self, north: bool) -> &mut Self {
        self.north = north;
        self
    }
    pub fn north(&self) -> bool {
        self.north
    }
    pub fn with_south(&mut self, south: bool) -> &mut Self {
        self.south = south;
        self
    }
    pub fn south(&self) -> bool {
        self.south
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
    pub fn with_west(&mut self, west: bool) -> &mut Self {
        self.west = west;
        self
    }
    pub fn west(&self) -> bool {
        self.west
    }
}
impl Default for LightGrayStainedGlassPaneState {
    fn default() -> Self {
        LightGrayStainedGlassPaneState {
            east: false,
            north: false,
            south: false,
            waterlogged: false,
            west: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct CyanStainedGlassPaneState {
    east: bool,
    north: bool,
    south: bool,
    waterlogged: bool,
    west: bool,
}
impl CyanStainedGlassPaneState {
    pub fn with_east(&mut self, east: bool) -> &mut Self {
        self.east = east;
        self
    }
    pub fn east(&self) -> bool {
        self.east
    }
    pub fn with_north(&mut self, north: bool) -> &mut Self {
        self.north = north;
        self
    }
    pub fn north(&self) -> bool {
        self.north
    }
    pub fn with_south(&mut self, south: bool) -> &mut Self {
        self.south = south;
        self
    }
    pub fn south(&self) -> bool {
        self.south
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
    pub fn with_west(&mut self, west: bool) -> &mut Self {
        self.west = west;
        self
    }
    pub fn west(&self) -> bool {
        self.west
    }
}
impl Default for CyanStainedGlassPaneState {
    fn default() -> Self {
        CyanStainedGlassPaneState {
            east: false,
            north: false,
            south: false,
            waterlogged: false,
            west: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct PurpleStainedGlassPaneState {
    east: bool,
    north: bool,
    south: bool,
    waterlogged: bool,
    west: bool,
}
impl PurpleStainedGlassPaneState {
    pub fn with_east(&mut self, east: bool) -> &mut Self {
        self.east = east;
        self
    }
    pub fn east(&self) -> bool {
        self.east
    }
    pub fn with_north(&mut self, north: bool) -> &mut Self {
        self.north = north;
        self
    }
    pub fn north(&self) -> bool {
        self.north
    }
    pub fn with_south(&mut self, south: bool) -> &mut Self {
        self.south = south;
        self
    }
    pub fn south(&self) -> bool {
        self.south
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
    pub fn with_west(&mut self, west: bool) -> &mut Self {
        self.west = west;
        self
    }
    pub fn west(&self) -> bool {
        self.west
    }
}
impl Default for PurpleStainedGlassPaneState {
    fn default() -> Self {
        PurpleStainedGlassPaneState {
            east: false,
            north: false,
            south: false,
            waterlogged: false,
            west: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct BlueStainedGlassPaneState {
    east: bool,
    north: bool,
    south: bool,
    waterlogged: bool,
    west: bool,
}
impl BlueStainedGlassPaneState {
    pub fn with_east(&mut self, east: bool) -> &mut Self {
        self.east = east;
        self
    }
    pub fn east(&self) -> bool {
        self.east
    }
    pub fn with_north(&mut self, north: bool) -> &mut Self {
        self.north = north;
        self
    }
    pub fn north(&self) -> bool {
        self.north
    }
    pub fn with_south(&mut self, south: bool) -> &mut Self {
        self.south = south;
        self
    }
    pub fn south(&self) -> bool {
        self.south
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
    pub fn with_west(&mut self, west: bool) -> &mut Self {
        self.west = west;
        self
    }
    pub fn west(&self) -> bool {
        self.west
    }
}
impl Default for BlueStainedGlassPaneState {
    fn default() -> Self {
        BlueStainedGlassPaneState {
            east: false,
            north: false,
            south: false,
            waterlogged: false,
            west: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct BrownStainedGlassPaneState {
    east: bool,
    north: bool,
    south: bool,
    waterlogged: bool,
    west: bool,
}
impl BrownStainedGlassPaneState {
    pub fn with_east(&mut self, east: bool) -> &mut Self {
        self.east = east;
        self
    }
    pub fn east(&self) -> bool {
        self.east
    }
    pub fn with_north(&mut self, north: bool) -> &mut Self {
        self.north = north;
        self
    }
    pub fn north(&self) -> bool {
        self.north
    }
    pub fn with_south(&mut self, south: bool) -> &mut Self {
        self.south = south;
        self
    }
    pub fn south(&self) -> bool {
        self.south
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
    pub fn with_west(&mut self, west: bool) -> &mut Self {
        self.west = west;
        self
    }
    pub fn west(&self) -> bool {
        self.west
    }
}
impl Default for BrownStainedGlassPaneState {
    fn default() -> Self {
        BrownStainedGlassPaneState {
            east: false,
            north: false,
            south: false,
            waterlogged: false,
            west: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct GreenStainedGlassPaneState {
    east: bool,
    north: bool,
    south: bool,
    waterlogged: bool,
    west: bool,
}
impl GreenStainedGlassPaneState {
    pub fn with_east(&mut self, east: bool) -> &mut Self {
        self.east = east;
        self
    }
    pub fn east(&self) -> bool {
        self.east
    }
    pub fn with_north(&mut self, north: bool) -> &mut Self {
        self.north = north;
        self
    }
    pub fn north(&self) -> bool {
        self.north
    }
    pub fn with_south(&mut self, south: bool) -> &mut Self {
        self.south = south;
        self
    }
    pub fn south(&self) -> bool {
        self.south
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
    pub fn with_west(&mut self, west: bool) -> &mut Self {
        self.west = west;
        self
    }
    pub fn west(&self) -> bool {
        self.west
    }
}
impl Default for GreenStainedGlassPaneState {
    fn default() -> Self {
        GreenStainedGlassPaneState {
            east: false,
            north: false,
            south: false,
            waterlogged: false,
            west: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct RedStainedGlassPaneState {
    east: bool,
    north: bool,
    south: bool,
    waterlogged: bool,
    west: bool,
}
impl RedStainedGlassPaneState {
    pub fn with_east(&mut self, east: bool) -> &mut Self {
        self.east = east;
        self
    }
    pub fn east(&self) -> bool {
        self.east
    }
    pub fn with_north(&mut self, north: bool) -> &mut Self {
        self.north = north;
        self
    }
    pub fn north(&self) -> bool {
        self.north
    }
    pub fn with_south(&mut self, south: bool) -> &mut Self {
        self.south = south;
        self
    }
    pub fn south(&self) -> bool {
        self.south
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
    pub fn with_west(&mut self, west: bool) -> &mut Self {
        self.west = west;
        self
    }
    pub fn west(&self) -> bool {
        self.west
    }
}
impl Default for RedStainedGlassPaneState {
    fn default() -> Self {
        RedStainedGlassPaneState {
            east: false,
            north: false,
            south: false,
            waterlogged: false,
            west: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct BlackStainedGlassPaneState {
    east: bool,
    north: bool,
    south: bool,
    waterlogged: bool,
    west: bool,
}
impl BlackStainedGlassPaneState {
    pub fn with_east(&mut self, east: bool) -> &mut Self {
        self.east = east;
        self
    }
    pub fn east(&self) -> bool {
        self.east
    }
    pub fn with_north(&mut self, north: bool) -> &mut Self {
        self.north = north;
        self
    }
    pub fn north(&self) -> bool {
        self.north
    }
    pub fn with_south(&mut self, south: bool) -> &mut Self {
        self.south = south;
        self
    }
    pub fn south(&self) -> bool {
        self.south
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
    pub fn with_west(&mut self, west: bool) -> &mut Self {
        self.west = west;
        self
    }
    pub fn west(&self) -> bool {
        self.west
    }
}
impl Default for BlackStainedGlassPaneState {
    fn default() -> Self {
        BlackStainedGlassPaneState {
            east: false,
            north: false,
            south: false,
            waterlogged: false,
            west: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct AcaciaStairsState {
    facing: HorizontalFacing,
    half: SingleBlockHalf,
    shape: StairShape,
    waterlogged: bool,
}
impl AcaciaStairsState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_half(&mut self, half: SingleBlockHalf) -> &mut Self {
        self.half = half;
        self
    }
    pub fn half(&self) -> SingleBlockHalf {
        self.half
    }
    pub fn with_shape(&mut self, shape: StairShape) -> &mut Self {
        self.shape = shape;
        self
    }
    pub fn shape(&self) -> StairShape {
        self.shape
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for AcaciaStairsState {
    fn default() -> Self {
        AcaciaStairsState {
            facing: HorizontalFacing::North,
            half: SingleBlockHalf::Bottom,
            shape: StairShape::Straight,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct DarkOakStairsState {
    facing: HorizontalFacing,
    half: SingleBlockHalf,
    shape: StairShape,
    waterlogged: bool,
}
impl DarkOakStairsState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_half(&mut self, half: SingleBlockHalf) -> &mut Self {
        self.half = half;
        self
    }
    pub fn half(&self) -> SingleBlockHalf {
        self.half
    }
    pub fn with_shape(&mut self, shape: StairShape) -> &mut Self {
        self.shape = shape;
        self
    }
    pub fn shape(&self) -> StairShape {
        self.shape
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for DarkOakStairsState {
    fn default() -> Self {
        DarkOakStairsState {
            facing: HorizontalFacing::North,
            half: SingleBlockHalf::Bottom,
            shape: StairShape::Straight,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct LightState {
    level: i32,
    waterlogged: bool,
}
impl LightState {
    /// This is a value between 0 and 15 (both ends inclusive).\Developers should be careful to respect these bounds as no checking is done at runtime!!!
    pub fn with_level(&mut self, level: i32) -> &mut Self {
        self.level = level;
        self
    }
    pub fn level(&self) -> i32 {
        self.level
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for LightState {
    fn default() -> Self {
        LightState {
            level: 15,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct IronTrapdoorState {
    facing: HorizontalFacing,
    half: SingleBlockHalf,
    open: bool,
    powered: bool,
    waterlogged: bool,
}
impl IronTrapdoorState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_half(&mut self, half: SingleBlockHalf) -> &mut Self {
        self.half = half;
        self
    }
    pub fn half(&self) -> SingleBlockHalf {
        self.half
    }
    pub fn with_open(&mut self, open: bool) -> &mut Self {
        self.open = open;
        self
    }
    pub fn open(&self) -> bool {
        self.open
    }
    pub fn with_powered(&mut self, powered: bool) -> &mut Self {
        self.powered = powered;
        self
    }
    pub fn powered(&self) -> bool {
        self.powered
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for IronTrapdoorState {
    fn default() -> Self {
        IronTrapdoorState {
            facing: HorizontalFacing::North,
            half: SingleBlockHalf::Bottom,
            open: false,
            powered: false,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct PrismarineStairsState {
    facing: HorizontalFacing,
    half: SingleBlockHalf,
    shape: StairShape,
    waterlogged: bool,
}
impl PrismarineStairsState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_half(&mut self, half: SingleBlockHalf) -> &mut Self {
        self.half = half;
        self
    }
    pub fn half(&self) -> SingleBlockHalf {
        self.half
    }
    pub fn with_shape(&mut self, shape: StairShape) -> &mut Self {
        self.shape = shape;
        self
    }
    pub fn shape(&self) -> StairShape {
        self.shape
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for PrismarineStairsState {
    fn default() -> Self {
        PrismarineStairsState {
            facing: HorizontalFacing::North,
            half: SingleBlockHalf::Bottom,
            shape: StairShape::Straight,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct PrismarineBrickStairsState {
    facing: HorizontalFacing,
    half: SingleBlockHalf,
    shape: StairShape,
    waterlogged: bool,
}
impl PrismarineBrickStairsState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_half(&mut self, half: SingleBlockHalf) -> &mut Self {
        self.half = half;
        self
    }
    pub fn half(&self) -> SingleBlockHalf {
        self.half
    }
    pub fn with_shape(&mut self, shape: StairShape) -> &mut Self {
        self.shape = shape;
        self
    }
    pub fn shape(&self) -> StairShape {
        self.shape
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for PrismarineBrickStairsState {
    fn default() -> Self {
        PrismarineBrickStairsState {
            facing: HorizontalFacing::North,
            half: SingleBlockHalf::Bottom,
            shape: StairShape::Straight,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct DarkPrismarineStairsState {
    facing: HorizontalFacing,
    half: SingleBlockHalf,
    shape: StairShape,
    waterlogged: bool,
}
impl DarkPrismarineStairsState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_half(&mut self, half: SingleBlockHalf) -> &mut Self {
        self.half = half;
        self
    }
    pub fn half(&self) -> SingleBlockHalf {
        self.half
    }
    pub fn with_shape(&mut self, shape: StairShape) -> &mut Self {
        self.shape = shape;
        self
    }
    pub fn shape(&self) -> StairShape {
        self.shape
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for DarkPrismarineStairsState {
    fn default() -> Self {
        DarkPrismarineStairsState {
            facing: HorizontalFacing::North,
            half: SingleBlockHalf::Bottom,
            shape: StairShape::Straight,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct PrismarineSlabState {
    typed: SlabType,
    waterlogged: bool,
}
impl PrismarineSlabState {
    pub fn with_typed(&mut self, typed: SlabType) -> &mut Self {
        self.typed = typed;
        self
    }
    pub fn typed(&self) -> SlabType {
        self.typed
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for PrismarineSlabState {
    fn default() -> Self {
        PrismarineSlabState {
            typed: SlabType::Bottom,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct PrismarineBrickSlabState {
    typed: SlabType,
    waterlogged: bool,
}
impl PrismarineBrickSlabState {
    pub fn with_typed(&mut self, typed: SlabType) -> &mut Self {
        self.typed = typed;
        self
    }
    pub fn typed(&self) -> SlabType {
        self.typed
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for PrismarineBrickSlabState {
    fn default() -> Self {
        PrismarineBrickSlabState {
            typed: SlabType::Bottom,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct DarkPrismarineSlabState {
    typed: SlabType,
    waterlogged: bool,
}
impl DarkPrismarineSlabState {
    pub fn with_typed(&mut self, typed: SlabType) -> &mut Self {
        self.typed = typed;
        self
    }
    pub fn typed(&self) -> SlabType {
        self.typed
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for DarkPrismarineSlabState {
    fn default() -> Self {
        DarkPrismarineSlabState {
            typed: SlabType::Bottom,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct HayBlockState {
    axis: Axis,
}
impl HayBlockState {
    pub fn with_axis(&mut self, axis: Axis) -> &mut Self {
        self.axis = axis;
        self
    }
    pub fn axis(&self) -> Axis {
        self.axis
    }
}
impl Default for HayBlockState {
    fn default() -> Self {
        HayBlockState {
            axis: Axis::Y,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct SunflowerState {
    half: DoubleBlockHalf,
}
impl SunflowerState {
    pub fn with_half(&mut self, half: DoubleBlockHalf) -> &mut Self {
        self.half = half;
        self
    }
    pub fn half(&self) -> DoubleBlockHalf {
        self.half
    }
}
impl Default for SunflowerState {
    fn default() -> Self {
        SunflowerState {
            half: DoubleBlockHalf::Lower,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct LilacState {
    half: DoubleBlockHalf,
}
impl LilacState {
    pub fn with_half(&mut self, half: DoubleBlockHalf) -> &mut Self {
        self.half = half;
        self
    }
    pub fn half(&self) -> DoubleBlockHalf {
        self.half
    }
}
impl Default for LilacState {
    fn default() -> Self {
        LilacState {
            half: DoubleBlockHalf::Lower,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct RoseBushState {
    half: DoubleBlockHalf,
}
impl RoseBushState {
    pub fn with_half(&mut self, half: DoubleBlockHalf) -> &mut Self {
        self.half = half;
        self
    }
    pub fn half(&self) -> DoubleBlockHalf {
        self.half
    }
}
impl Default for RoseBushState {
    fn default() -> Self {
        RoseBushState {
            half: DoubleBlockHalf::Lower,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct PeonyState {
    half: DoubleBlockHalf,
}
impl PeonyState {
    pub fn with_half(&mut self, half: DoubleBlockHalf) -> &mut Self {
        self.half = half;
        self
    }
    pub fn half(&self) -> DoubleBlockHalf {
        self.half
    }
}
impl Default for PeonyState {
    fn default() -> Self {
        PeonyState {
            half: DoubleBlockHalf::Lower,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct TallGrassState {
    half: DoubleBlockHalf,
}
impl TallGrassState {
    pub fn with_half(&mut self, half: DoubleBlockHalf) -> &mut Self {
        self.half = half;
        self
    }
    pub fn half(&self) -> DoubleBlockHalf {
        self.half
    }
}
impl Default for TallGrassState {
    fn default() -> Self {
        TallGrassState {
            half: DoubleBlockHalf::Lower,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct LargeFernState {
    half: DoubleBlockHalf,
}
impl LargeFernState {
    pub fn with_half(&mut self, half: DoubleBlockHalf) -> &mut Self {
        self.half = half;
        self
    }
    pub fn half(&self) -> DoubleBlockHalf {
        self.half
    }
}
impl Default for LargeFernState {
    fn default() -> Self {
        LargeFernState {
            half: DoubleBlockHalf::Lower,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct WhiteBannerState {
    rotation: i32,
}
impl WhiteBannerState {
    /// This is a value between 0 and 15 (both ends inclusive).\Developers should be careful to respect these bounds as no checking is done at runtime!!!
    pub fn with_rotation(&mut self, rotation: i32) -> &mut Self {
        self.rotation = rotation;
        self
    }
    pub fn rotation(&self) -> i32 {
        self.rotation
    }
}
impl Default for WhiteBannerState {
    fn default() -> Self {
        WhiteBannerState {
            rotation: 0,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct OrangeBannerState {
    rotation: i32,
}
impl OrangeBannerState {
    /// This is a value between 0 and 15 (both ends inclusive).\Developers should be careful to respect these bounds as no checking is done at runtime!!!
    pub fn with_rotation(&mut self, rotation: i32) -> &mut Self {
        self.rotation = rotation;
        self
    }
    pub fn rotation(&self) -> i32 {
        self.rotation
    }
}
impl Default for OrangeBannerState {
    fn default() -> Self {
        OrangeBannerState {
            rotation: 0,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct MagentaBannerState {
    rotation: i32,
}
impl MagentaBannerState {
    /// This is a value between 0 and 15 (both ends inclusive).\Developers should be careful to respect these bounds as no checking is done at runtime!!!
    pub fn with_rotation(&mut self, rotation: i32) -> &mut Self {
        self.rotation = rotation;
        self
    }
    pub fn rotation(&self) -> i32 {
        self.rotation
    }
}
impl Default for MagentaBannerState {
    fn default() -> Self {
        MagentaBannerState {
            rotation: 0,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct LightBlueBannerState {
    rotation: i32,
}
impl LightBlueBannerState {
    /// This is a value between 0 and 15 (both ends inclusive).\Developers should be careful to respect these bounds as no checking is done at runtime!!!
    pub fn with_rotation(&mut self, rotation: i32) -> &mut Self {
        self.rotation = rotation;
        self
    }
    pub fn rotation(&self) -> i32 {
        self.rotation
    }
}
impl Default for LightBlueBannerState {
    fn default() -> Self {
        LightBlueBannerState {
            rotation: 0,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct YellowBannerState {
    rotation: i32,
}
impl YellowBannerState {
    /// This is a value between 0 and 15 (both ends inclusive).\Developers should be careful to respect these bounds as no checking is done at runtime!!!
    pub fn with_rotation(&mut self, rotation: i32) -> &mut Self {
        self.rotation = rotation;
        self
    }
    pub fn rotation(&self) -> i32 {
        self.rotation
    }
}
impl Default for YellowBannerState {
    fn default() -> Self {
        YellowBannerState {
            rotation: 0,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct LimeBannerState {
    rotation: i32,
}
impl LimeBannerState {
    /// This is a value between 0 and 15 (both ends inclusive).\Developers should be careful to respect these bounds as no checking is done at runtime!!!
    pub fn with_rotation(&mut self, rotation: i32) -> &mut Self {
        self.rotation = rotation;
        self
    }
    pub fn rotation(&self) -> i32 {
        self.rotation
    }
}
impl Default for LimeBannerState {
    fn default() -> Self {
        LimeBannerState {
            rotation: 0,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct PinkBannerState {
    rotation: i32,
}
impl PinkBannerState {
    /// This is a value between 0 and 15 (both ends inclusive).\Developers should be careful to respect these bounds as no checking is done at runtime!!!
    pub fn with_rotation(&mut self, rotation: i32) -> &mut Self {
        self.rotation = rotation;
        self
    }
    pub fn rotation(&self) -> i32 {
        self.rotation
    }
}
impl Default for PinkBannerState {
    fn default() -> Self {
        PinkBannerState {
            rotation: 0,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct GrayBannerState {
    rotation: i32,
}
impl GrayBannerState {
    /// This is a value between 0 and 15 (both ends inclusive).\Developers should be careful to respect these bounds as no checking is done at runtime!!!
    pub fn with_rotation(&mut self, rotation: i32) -> &mut Self {
        self.rotation = rotation;
        self
    }
    pub fn rotation(&self) -> i32 {
        self.rotation
    }
}
impl Default for GrayBannerState {
    fn default() -> Self {
        GrayBannerState {
            rotation: 0,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct LightGrayBannerState {
    rotation: i32,
}
impl LightGrayBannerState {
    /// This is a value between 0 and 15 (both ends inclusive).\Developers should be careful to respect these bounds as no checking is done at runtime!!!
    pub fn with_rotation(&mut self, rotation: i32) -> &mut Self {
        self.rotation = rotation;
        self
    }
    pub fn rotation(&self) -> i32 {
        self.rotation
    }
}
impl Default for LightGrayBannerState {
    fn default() -> Self {
        LightGrayBannerState {
            rotation: 0,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct CyanBannerState {
    rotation: i32,
}
impl CyanBannerState {
    /// This is a value between 0 and 15 (both ends inclusive).\Developers should be careful to respect these bounds as no checking is done at runtime!!!
    pub fn with_rotation(&mut self, rotation: i32) -> &mut Self {
        self.rotation = rotation;
        self
    }
    pub fn rotation(&self) -> i32 {
        self.rotation
    }
}
impl Default for CyanBannerState {
    fn default() -> Self {
        CyanBannerState {
            rotation: 0,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct PurpleBannerState {
    rotation: i32,
}
impl PurpleBannerState {
    /// This is a value between 0 and 15 (both ends inclusive).\Developers should be careful to respect these bounds as no checking is done at runtime!!!
    pub fn with_rotation(&mut self, rotation: i32) -> &mut Self {
        self.rotation = rotation;
        self
    }
    pub fn rotation(&self) -> i32 {
        self.rotation
    }
}
impl Default for PurpleBannerState {
    fn default() -> Self {
        PurpleBannerState {
            rotation: 0,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct BlueBannerState {
    rotation: i32,
}
impl BlueBannerState {
    /// This is a value between 0 and 15 (both ends inclusive).\Developers should be careful to respect these bounds as no checking is done at runtime!!!
    pub fn with_rotation(&mut self, rotation: i32) -> &mut Self {
        self.rotation = rotation;
        self
    }
    pub fn rotation(&self) -> i32 {
        self.rotation
    }
}
impl Default for BlueBannerState {
    fn default() -> Self {
        BlueBannerState {
            rotation: 0,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct BrownBannerState {
    rotation: i32,
}
impl BrownBannerState {
    /// This is a value between 0 and 15 (both ends inclusive).\Developers should be careful to respect these bounds as no checking is done at runtime!!!
    pub fn with_rotation(&mut self, rotation: i32) -> &mut Self {
        self.rotation = rotation;
        self
    }
    pub fn rotation(&self) -> i32 {
        self.rotation
    }
}
impl Default for BrownBannerState {
    fn default() -> Self {
        BrownBannerState {
            rotation: 0,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct GreenBannerState {
    rotation: i32,
}
impl GreenBannerState {
    /// This is a value between 0 and 15 (both ends inclusive).\Developers should be careful to respect these bounds as no checking is done at runtime!!!
    pub fn with_rotation(&mut self, rotation: i32) -> &mut Self {
        self.rotation = rotation;
        self
    }
    pub fn rotation(&self) -> i32 {
        self.rotation
    }
}
impl Default for GreenBannerState {
    fn default() -> Self {
        GreenBannerState {
            rotation: 0,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct RedBannerState {
    rotation: i32,
}
impl RedBannerState {
    /// This is a value between 0 and 15 (both ends inclusive).\Developers should be careful to respect these bounds as no checking is done at runtime!!!
    pub fn with_rotation(&mut self, rotation: i32) -> &mut Self {
        self.rotation = rotation;
        self
    }
    pub fn rotation(&self) -> i32 {
        self.rotation
    }
}
impl Default for RedBannerState {
    fn default() -> Self {
        RedBannerState {
            rotation: 0,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct BlackBannerState {
    rotation: i32,
}
impl BlackBannerState {
    /// This is a value between 0 and 15 (both ends inclusive).\Developers should be careful to respect these bounds as no checking is done at runtime!!!
    pub fn with_rotation(&mut self, rotation: i32) -> &mut Self {
        self.rotation = rotation;
        self
    }
    pub fn rotation(&self) -> i32 {
        self.rotation
    }
}
impl Default for BlackBannerState {
    fn default() -> Self {
        BlackBannerState {
            rotation: 0,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct WhiteWallBannerState {
    facing: HorizontalFacing,
}
impl WhiteWallBannerState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
}
impl Default for WhiteWallBannerState {
    fn default() -> Self {
        WhiteWallBannerState {
            facing: HorizontalFacing::North,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct OrangeWallBannerState {
    facing: HorizontalFacing,
}
impl OrangeWallBannerState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
}
impl Default for OrangeWallBannerState {
    fn default() -> Self {
        OrangeWallBannerState {
            facing: HorizontalFacing::North,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct MagentaWallBannerState {
    facing: HorizontalFacing,
}
impl MagentaWallBannerState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
}
impl Default for MagentaWallBannerState {
    fn default() -> Self {
        MagentaWallBannerState {
            facing: HorizontalFacing::North,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct LightBlueWallBannerState {
    facing: HorizontalFacing,
}
impl LightBlueWallBannerState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
}
impl Default for LightBlueWallBannerState {
    fn default() -> Self {
        LightBlueWallBannerState {
            facing: HorizontalFacing::North,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct YellowWallBannerState {
    facing: HorizontalFacing,
}
impl YellowWallBannerState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
}
impl Default for YellowWallBannerState {
    fn default() -> Self {
        YellowWallBannerState {
            facing: HorizontalFacing::North,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct LimeWallBannerState {
    facing: HorizontalFacing,
}
impl LimeWallBannerState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
}
impl Default for LimeWallBannerState {
    fn default() -> Self {
        LimeWallBannerState {
            facing: HorizontalFacing::North,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct PinkWallBannerState {
    facing: HorizontalFacing,
}
impl PinkWallBannerState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
}
impl Default for PinkWallBannerState {
    fn default() -> Self {
        PinkWallBannerState {
            facing: HorizontalFacing::North,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct GrayWallBannerState {
    facing: HorizontalFacing,
}
impl GrayWallBannerState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
}
impl Default for GrayWallBannerState {
    fn default() -> Self {
        GrayWallBannerState {
            facing: HorizontalFacing::North,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct LightGrayWallBannerState {
    facing: HorizontalFacing,
}
impl LightGrayWallBannerState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
}
impl Default for LightGrayWallBannerState {
    fn default() -> Self {
        LightGrayWallBannerState {
            facing: HorizontalFacing::North,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct CyanWallBannerState {
    facing: HorizontalFacing,
}
impl CyanWallBannerState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
}
impl Default for CyanWallBannerState {
    fn default() -> Self {
        CyanWallBannerState {
            facing: HorizontalFacing::North,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct PurpleWallBannerState {
    facing: HorizontalFacing,
}
impl PurpleWallBannerState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
}
impl Default for PurpleWallBannerState {
    fn default() -> Self {
        PurpleWallBannerState {
            facing: HorizontalFacing::North,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct BlueWallBannerState {
    facing: HorizontalFacing,
}
impl BlueWallBannerState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
}
impl Default for BlueWallBannerState {
    fn default() -> Self {
        BlueWallBannerState {
            facing: HorizontalFacing::North,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct BrownWallBannerState {
    facing: HorizontalFacing,
}
impl BrownWallBannerState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
}
impl Default for BrownWallBannerState {
    fn default() -> Self {
        BrownWallBannerState {
            facing: HorizontalFacing::North,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct GreenWallBannerState {
    facing: HorizontalFacing,
}
impl GreenWallBannerState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
}
impl Default for GreenWallBannerState {
    fn default() -> Self {
        GreenWallBannerState {
            facing: HorizontalFacing::North,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct RedWallBannerState {
    facing: HorizontalFacing,
}
impl RedWallBannerState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
}
impl Default for RedWallBannerState {
    fn default() -> Self {
        RedWallBannerState {
            facing: HorizontalFacing::North,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct BlackWallBannerState {
    facing: HorizontalFacing,
}
impl BlackWallBannerState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
}
impl Default for BlackWallBannerState {
    fn default() -> Self {
        BlackWallBannerState {
            facing: HorizontalFacing::North,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct RedSandstoneStairsState {
    facing: HorizontalFacing,
    half: SingleBlockHalf,
    shape: StairShape,
    waterlogged: bool,
}
impl RedSandstoneStairsState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_half(&mut self, half: SingleBlockHalf) -> &mut Self {
        self.half = half;
        self
    }
    pub fn half(&self) -> SingleBlockHalf {
        self.half
    }
    pub fn with_shape(&mut self, shape: StairShape) -> &mut Self {
        self.shape = shape;
        self
    }
    pub fn shape(&self) -> StairShape {
        self.shape
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for RedSandstoneStairsState {
    fn default() -> Self {
        RedSandstoneStairsState {
            facing: HorizontalFacing::North,
            half: SingleBlockHalf::Bottom,
            shape: StairShape::Straight,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct OakSlabState {
    typed: SlabType,
    waterlogged: bool,
}
impl OakSlabState {
    pub fn with_typed(&mut self, typed: SlabType) -> &mut Self {
        self.typed = typed;
        self
    }
    pub fn typed(&self) -> SlabType {
        self.typed
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for OakSlabState {
    fn default() -> Self {
        OakSlabState {
            typed: SlabType::Bottom,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct SpruceSlabState {
    typed: SlabType,
    waterlogged: bool,
}
impl SpruceSlabState {
    pub fn with_typed(&mut self, typed: SlabType) -> &mut Self {
        self.typed = typed;
        self
    }
    pub fn typed(&self) -> SlabType {
        self.typed
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for SpruceSlabState {
    fn default() -> Self {
        SpruceSlabState {
            typed: SlabType::Bottom,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct BirchSlabState {
    typed: SlabType,
    waterlogged: bool,
}
impl BirchSlabState {
    pub fn with_typed(&mut self, typed: SlabType) -> &mut Self {
        self.typed = typed;
        self
    }
    pub fn typed(&self) -> SlabType {
        self.typed
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for BirchSlabState {
    fn default() -> Self {
        BirchSlabState {
            typed: SlabType::Bottom,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct JungleSlabState {
    typed: SlabType,
    waterlogged: bool,
}
impl JungleSlabState {
    pub fn with_typed(&mut self, typed: SlabType) -> &mut Self {
        self.typed = typed;
        self
    }
    pub fn typed(&self) -> SlabType {
        self.typed
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for JungleSlabState {
    fn default() -> Self {
        JungleSlabState {
            typed: SlabType::Bottom,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct AcaciaSlabState {
    typed: SlabType,
    waterlogged: bool,
}
impl AcaciaSlabState {
    pub fn with_typed(&mut self, typed: SlabType) -> &mut Self {
        self.typed = typed;
        self
    }
    pub fn typed(&self) -> SlabType {
        self.typed
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for AcaciaSlabState {
    fn default() -> Self {
        AcaciaSlabState {
            typed: SlabType::Bottom,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct DarkOakSlabState {
    typed: SlabType,
    waterlogged: bool,
}
impl DarkOakSlabState {
    pub fn with_typed(&mut self, typed: SlabType) -> &mut Self {
        self.typed = typed;
        self
    }
    pub fn typed(&self) -> SlabType {
        self.typed
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for DarkOakSlabState {
    fn default() -> Self {
        DarkOakSlabState {
            typed: SlabType::Bottom,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct StoneSlabState {
    typed: SlabType,
    waterlogged: bool,
}
impl StoneSlabState {
    pub fn with_typed(&mut self, typed: SlabType) -> &mut Self {
        self.typed = typed;
        self
    }
    pub fn typed(&self) -> SlabType {
        self.typed
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for StoneSlabState {
    fn default() -> Self {
        StoneSlabState {
            typed: SlabType::Bottom,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct SmoothStoneSlabState {
    typed: SlabType,
    waterlogged: bool,
}
impl SmoothStoneSlabState {
    pub fn with_typed(&mut self, typed: SlabType) -> &mut Self {
        self.typed = typed;
        self
    }
    pub fn typed(&self) -> SlabType {
        self.typed
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for SmoothStoneSlabState {
    fn default() -> Self {
        SmoothStoneSlabState {
            typed: SlabType::Bottom,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct SandstoneSlabState {
    typed: SlabType,
    waterlogged: bool,
}
impl SandstoneSlabState {
    pub fn with_typed(&mut self, typed: SlabType) -> &mut Self {
        self.typed = typed;
        self
    }
    pub fn typed(&self) -> SlabType {
        self.typed
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for SandstoneSlabState {
    fn default() -> Self {
        SandstoneSlabState {
            typed: SlabType::Bottom,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct CutSandstoneSlabState {
    typed: SlabType,
    waterlogged: bool,
}
impl CutSandstoneSlabState {
    pub fn with_typed(&mut self, typed: SlabType) -> &mut Self {
        self.typed = typed;
        self
    }
    pub fn typed(&self) -> SlabType {
        self.typed
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for CutSandstoneSlabState {
    fn default() -> Self {
        CutSandstoneSlabState {
            typed: SlabType::Bottom,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct PetrifiedOakSlabState {
    typed: SlabType,
    waterlogged: bool,
}
impl PetrifiedOakSlabState {
    pub fn with_typed(&mut self, typed: SlabType) -> &mut Self {
        self.typed = typed;
        self
    }
    pub fn typed(&self) -> SlabType {
        self.typed
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for PetrifiedOakSlabState {
    fn default() -> Self {
        PetrifiedOakSlabState {
            typed: SlabType::Bottom,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct CobblestoneSlabState {
    typed: SlabType,
    waterlogged: bool,
}
impl CobblestoneSlabState {
    pub fn with_typed(&mut self, typed: SlabType) -> &mut Self {
        self.typed = typed;
        self
    }
    pub fn typed(&self) -> SlabType {
        self.typed
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for CobblestoneSlabState {
    fn default() -> Self {
        CobblestoneSlabState {
            typed: SlabType::Bottom,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct BrickSlabState {
    typed: SlabType,
    waterlogged: bool,
}
impl BrickSlabState {
    pub fn with_typed(&mut self, typed: SlabType) -> &mut Self {
        self.typed = typed;
        self
    }
    pub fn typed(&self) -> SlabType {
        self.typed
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for BrickSlabState {
    fn default() -> Self {
        BrickSlabState {
            typed: SlabType::Bottom,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct StoneBrickSlabState {
    typed: SlabType,
    waterlogged: bool,
}
impl StoneBrickSlabState {
    pub fn with_typed(&mut self, typed: SlabType) -> &mut Self {
        self.typed = typed;
        self
    }
    pub fn typed(&self) -> SlabType {
        self.typed
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for StoneBrickSlabState {
    fn default() -> Self {
        StoneBrickSlabState {
            typed: SlabType::Bottom,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct NetherBrickSlabState {
    typed: SlabType,
    waterlogged: bool,
}
impl NetherBrickSlabState {
    pub fn with_typed(&mut self, typed: SlabType) -> &mut Self {
        self.typed = typed;
        self
    }
    pub fn typed(&self) -> SlabType {
        self.typed
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for NetherBrickSlabState {
    fn default() -> Self {
        NetherBrickSlabState {
            typed: SlabType::Bottom,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct QuartzSlabState {
    typed: SlabType,
    waterlogged: bool,
}
impl QuartzSlabState {
    pub fn with_typed(&mut self, typed: SlabType) -> &mut Self {
        self.typed = typed;
        self
    }
    pub fn typed(&self) -> SlabType {
        self.typed
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for QuartzSlabState {
    fn default() -> Self {
        QuartzSlabState {
            typed: SlabType::Bottom,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct RedSandstoneSlabState {
    typed: SlabType,
    waterlogged: bool,
}
impl RedSandstoneSlabState {
    pub fn with_typed(&mut self, typed: SlabType) -> &mut Self {
        self.typed = typed;
        self
    }
    pub fn typed(&self) -> SlabType {
        self.typed
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for RedSandstoneSlabState {
    fn default() -> Self {
        RedSandstoneSlabState {
            typed: SlabType::Bottom,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct CutRedSandstoneSlabState {
    typed: SlabType,
    waterlogged: bool,
}
impl CutRedSandstoneSlabState {
    pub fn with_typed(&mut self, typed: SlabType) -> &mut Self {
        self.typed = typed;
        self
    }
    pub fn typed(&self) -> SlabType {
        self.typed
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for CutRedSandstoneSlabState {
    fn default() -> Self {
        CutRedSandstoneSlabState {
            typed: SlabType::Bottom,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct PurpurSlabState {
    typed: SlabType,
    waterlogged: bool,
}
impl PurpurSlabState {
    pub fn with_typed(&mut self, typed: SlabType) -> &mut Self {
        self.typed = typed;
        self
    }
    pub fn typed(&self) -> SlabType {
        self.typed
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for PurpurSlabState {
    fn default() -> Self {
        PurpurSlabState {
            typed: SlabType::Bottom,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct SpruceFenceGateState {
    facing: HorizontalFacing,
    in_wall: bool,
    open: bool,
    powered: bool,
}
impl SpruceFenceGateState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_in_wall(&mut self, in_wall: bool) -> &mut Self {
        self.in_wall = in_wall;
        self
    }
    pub fn in_wall(&self) -> bool {
        self.in_wall
    }
    pub fn with_open(&mut self, open: bool) -> &mut Self {
        self.open = open;
        self
    }
    pub fn open(&self) -> bool {
        self.open
    }
    pub fn with_powered(&mut self, powered: bool) -> &mut Self {
        self.powered = powered;
        self
    }
    pub fn powered(&self) -> bool {
        self.powered
    }
}
impl Default for SpruceFenceGateState {
    fn default() -> Self {
        SpruceFenceGateState {
            facing: HorizontalFacing::North,
            in_wall: false,
            open: false,
            powered: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct BirchFenceGateState {
    facing: HorizontalFacing,
    in_wall: bool,
    open: bool,
    powered: bool,
}
impl BirchFenceGateState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_in_wall(&mut self, in_wall: bool) -> &mut Self {
        self.in_wall = in_wall;
        self
    }
    pub fn in_wall(&self) -> bool {
        self.in_wall
    }
    pub fn with_open(&mut self, open: bool) -> &mut Self {
        self.open = open;
        self
    }
    pub fn open(&self) -> bool {
        self.open
    }
    pub fn with_powered(&mut self, powered: bool) -> &mut Self {
        self.powered = powered;
        self
    }
    pub fn powered(&self) -> bool {
        self.powered
    }
}
impl Default for BirchFenceGateState {
    fn default() -> Self {
        BirchFenceGateState {
            facing: HorizontalFacing::North,
            in_wall: false,
            open: false,
            powered: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct JungleFenceGateState {
    facing: HorizontalFacing,
    in_wall: bool,
    open: bool,
    powered: bool,
}
impl JungleFenceGateState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_in_wall(&mut self, in_wall: bool) -> &mut Self {
        self.in_wall = in_wall;
        self
    }
    pub fn in_wall(&self) -> bool {
        self.in_wall
    }
    pub fn with_open(&mut self, open: bool) -> &mut Self {
        self.open = open;
        self
    }
    pub fn open(&self) -> bool {
        self.open
    }
    pub fn with_powered(&mut self, powered: bool) -> &mut Self {
        self.powered = powered;
        self
    }
    pub fn powered(&self) -> bool {
        self.powered
    }
}
impl Default for JungleFenceGateState {
    fn default() -> Self {
        JungleFenceGateState {
            facing: HorizontalFacing::North,
            in_wall: false,
            open: false,
            powered: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct AcaciaFenceGateState {
    facing: HorizontalFacing,
    in_wall: bool,
    open: bool,
    powered: bool,
}
impl AcaciaFenceGateState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_in_wall(&mut self, in_wall: bool) -> &mut Self {
        self.in_wall = in_wall;
        self
    }
    pub fn in_wall(&self) -> bool {
        self.in_wall
    }
    pub fn with_open(&mut self, open: bool) -> &mut Self {
        self.open = open;
        self
    }
    pub fn open(&self) -> bool {
        self.open
    }
    pub fn with_powered(&mut self, powered: bool) -> &mut Self {
        self.powered = powered;
        self
    }
    pub fn powered(&self) -> bool {
        self.powered
    }
}
impl Default for AcaciaFenceGateState {
    fn default() -> Self {
        AcaciaFenceGateState {
            facing: HorizontalFacing::North,
            in_wall: false,
            open: false,
            powered: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct DarkOakFenceGateState {
    facing: HorizontalFacing,
    in_wall: bool,
    open: bool,
    powered: bool,
}
impl DarkOakFenceGateState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_in_wall(&mut self, in_wall: bool) -> &mut Self {
        self.in_wall = in_wall;
        self
    }
    pub fn in_wall(&self) -> bool {
        self.in_wall
    }
    pub fn with_open(&mut self, open: bool) -> &mut Self {
        self.open = open;
        self
    }
    pub fn open(&self) -> bool {
        self.open
    }
    pub fn with_powered(&mut self, powered: bool) -> &mut Self {
        self.powered = powered;
        self
    }
    pub fn powered(&self) -> bool {
        self.powered
    }
}
impl Default for DarkOakFenceGateState {
    fn default() -> Self {
        DarkOakFenceGateState {
            facing: HorizontalFacing::North,
            in_wall: false,
            open: false,
            powered: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct SpruceFenceState {
    east: bool,
    north: bool,
    south: bool,
    waterlogged: bool,
    west: bool,
}
impl SpruceFenceState {
    pub fn with_east(&mut self, east: bool) -> &mut Self {
        self.east = east;
        self
    }
    pub fn east(&self) -> bool {
        self.east
    }
    pub fn with_north(&mut self, north: bool) -> &mut Self {
        self.north = north;
        self
    }
    pub fn north(&self) -> bool {
        self.north
    }
    pub fn with_south(&mut self, south: bool) -> &mut Self {
        self.south = south;
        self
    }
    pub fn south(&self) -> bool {
        self.south
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
    pub fn with_west(&mut self, west: bool) -> &mut Self {
        self.west = west;
        self
    }
    pub fn west(&self) -> bool {
        self.west
    }
}
impl Default for SpruceFenceState {
    fn default() -> Self {
        SpruceFenceState {
            east: false,
            north: false,
            south: false,
            waterlogged: false,
            west: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct BirchFenceState {
    east: bool,
    north: bool,
    south: bool,
    waterlogged: bool,
    west: bool,
}
impl BirchFenceState {
    pub fn with_east(&mut self, east: bool) -> &mut Self {
        self.east = east;
        self
    }
    pub fn east(&self) -> bool {
        self.east
    }
    pub fn with_north(&mut self, north: bool) -> &mut Self {
        self.north = north;
        self
    }
    pub fn north(&self) -> bool {
        self.north
    }
    pub fn with_south(&mut self, south: bool) -> &mut Self {
        self.south = south;
        self
    }
    pub fn south(&self) -> bool {
        self.south
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
    pub fn with_west(&mut self, west: bool) -> &mut Self {
        self.west = west;
        self
    }
    pub fn west(&self) -> bool {
        self.west
    }
}
impl Default for BirchFenceState {
    fn default() -> Self {
        BirchFenceState {
            east: false,
            north: false,
            south: false,
            waterlogged: false,
            west: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct JungleFenceState {
    east: bool,
    north: bool,
    south: bool,
    waterlogged: bool,
    west: bool,
}
impl JungleFenceState {
    pub fn with_east(&mut self, east: bool) -> &mut Self {
        self.east = east;
        self
    }
    pub fn east(&self) -> bool {
        self.east
    }
    pub fn with_north(&mut self, north: bool) -> &mut Self {
        self.north = north;
        self
    }
    pub fn north(&self) -> bool {
        self.north
    }
    pub fn with_south(&mut self, south: bool) -> &mut Self {
        self.south = south;
        self
    }
    pub fn south(&self) -> bool {
        self.south
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
    pub fn with_west(&mut self, west: bool) -> &mut Self {
        self.west = west;
        self
    }
    pub fn west(&self) -> bool {
        self.west
    }
}
impl Default for JungleFenceState {
    fn default() -> Self {
        JungleFenceState {
            east: false,
            north: false,
            south: false,
            waterlogged: false,
            west: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct AcaciaFenceState {
    east: bool,
    north: bool,
    south: bool,
    waterlogged: bool,
    west: bool,
}
impl AcaciaFenceState {
    pub fn with_east(&mut self, east: bool) -> &mut Self {
        self.east = east;
        self
    }
    pub fn east(&self) -> bool {
        self.east
    }
    pub fn with_north(&mut self, north: bool) -> &mut Self {
        self.north = north;
        self
    }
    pub fn north(&self) -> bool {
        self.north
    }
    pub fn with_south(&mut self, south: bool) -> &mut Self {
        self.south = south;
        self
    }
    pub fn south(&self) -> bool {
        self.south
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
    pub fn with_west(&mut self, west: bool) -> &mut Self {
        self.west = west;
        self
    }
    pub fn west(&self) -> bool {
        self.west
    }
}
impl Default for AcaciaFenceState {
    fn default() -> Self {
        AcaciaFenceState {
            east: false,
            north: false,
            south: false,
            waterlogged: false,
            west: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct DarkOakFenceState {
    east: bool,
    north: bool,
    south: bool,
    waterlogged: bool,
    west: bool,
}
impl DarkOakFenceState {
    pub fn with_east(&mut self, east: bool) -> &mut Self {
        self.east = east;
        self
    }
    pub fn east(&self) -> bool {
        self.east
    }
    pub fn with_north(&mut self, north: bool) -> &mut Self {
        self.north = north;
        self
    }
    pub fn north(&self) -> bool {
        self.north
    }
    pub fn with_south(&mut self, south: bool) -> &mut Self {
        self.south = south;
        self
    }
    pub fn south(&self) -> bool {
        self.south
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
    pub fn with_west(&mut self, west: bool) -> &mut Self {
        self.west = west;
        self
    }
    pub fn west(&self) -> bool {
        self.west
    }
}
impl Default for DarkOakFenceState {
    fn default() -> Self {
        DarkOakFenceState {
            east: false,
            north: false,
            south: false,
            waterlogged: false,
            west: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct SpruceDoorState {
    facing: HorizontalFacing,
    half: DoubleBlockHalf,
    hinge: Hinge,
    open: bool,
    powered: bool,
}
impl SpruceDoorState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_half(&mut self, half: DoubleBlockHalf) -> &mut Self {
        self.half = half;
        self
    }
    pub fn half(&self) -> DoubleBlockHalf {
        self.half
    }
    pub fn with_hinge(&mut self, hinge: Hinge) -> &mut Self {
        self.hinge = hinge;
        self
    }
    pub fn hinge(&self) -> Hinge {
        self.hinge
    }
    pub fn with_open(&mut self, open: bool) -> &mut Self {
        self.open = open;
        self
    }
    pub fn open(&self) -> bool {
        self.open
    }
    pub fn with_powered(&mut self, powered: bool) -> &mut Self {
        self.powered = powered;
        self
    }
    pub fn powered(&self) -> bool {
        self.powered
    }
}
impl Default for SpruceDoorState {
    fn default() -> Self {
        SpruceDoorState {
            facing: HorizontalFacing::North,
            half: DoubleBlockHalf::Lower,
            hinge: Hinge::Left,
            open: false,
            powered: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct BirchDoorState {
    facing: HorizontalFacing,
    half: DoubleBlockHalf,
    hinge: Hinge,
    open: bool,
    powered: bool,
}
impl BirchDoorState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_half(&mut self, half: DoubleBlockHalf) -> &mut Self {
        self.half = half;
        self
    }
    pub fn half(&self) -> DoubleBlockHalf {
        self.half
    }
    pub fn with_hinge(&mut self, hinge: Hinge) -> &mut Self {
        self.hinge = hinge;
        self
    }
    pub fn hinge(&self) -> Hinge {
        self.hinge
    }
    pub fn with_open(&mut self, open: bool) -> &mut Self {
        self.open = open;
        self
    }
    pub fn open(&self) -> bool {
        self.open
    }
    pub fn with_powered(&mut self, powered: bool) -> &mut Self {
        self.powered = powered;
        self
    }
    pub fn powered(&self) -> bool {
        self.powered
    }
}
impl Default for BirchDoorState {
    fn default() -> Self {
        BirchDoorState {
            facing: HorizontalFacing::North,
            half: DoubleBlockHalf::Lower,
            hinge: Hinge::Left,
            open: false,
            powered: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct JungleDoorState {
    facing: HorizontalFacing,
    half: DoubleBlockHalf,
    hinge: Hinge,
    open: bool,
    powered: bool,
}
impl JungleDoorState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_half(&mut self, half: DoubleBlockHalf) -> &mut Self {
        self.half = half;
        self
    }
    pub fn half(&self) -> DoubleBlockHalf {
        self.half
    }
    pub fn with_hinge(&mut self, hinge: Hinge) -> &mut Self {
        self.hinge = hinge;
        self
    }
    pub fn hinge(&self) -> Hinge {
        self.hinge
    }
    pub fn with_open(&mut self, open: bool) -> &mut Self {
        self.open = open;
        self
    }
    pub fn open(&self) -> bool {
        self.open
    }
    pub fn with_powered(&mut self, powered: bool) -> &mut Self {
        self.powered = powered;
        self
    }
    pub fn powered(&self) -> bool {
        self.powered
    }
}
impl Default for JungleDoorState {
    fn default() -> Self {
        JungleDoorState {
            facing: HorizontalFacing::North,
            half: DoubleBlockHalf::Lower,
            hinge: Hinge::Left,
            open: false,
            powered: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct AcaciaDoorState {
    facing: HorizontalFacing,
    half: DoubleBlockHalf,
    hinge: Hinge,
    open: bool,
    powered: bool,
}
impl AcaciaDoorState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_half(&mut self, half: DoubleBlockHalf) -> &mut Self {
        self.half = half;
        self
    }
    pub fn half(&self) -> DoubleBlockHalf {
        self.half
    }
    pub fn with_hinge(&mut self, hinge: Hinge) -> &mut Self {
        self.hinge = hinge;
        self
    }
    pub fn hinge(&self) -> Hinge {
        self.hinge
    }
    pub fn with_open(&mut self, open: bool) -> &mut Self {
        self.open = open;
        self
    }
    pub fn open(&self) -> bool {
        self.open
    }
    pub fn with_powered(&mut self, powered: bool) -> &mut Self {
        self.powered = powered;
        self
    }
    pub fn powered(&self) -> bool {
        self.powered
    }
}
impl Default for AcaciaDoorState {
    fn default() -> Self {
        AcaciaDoorState {
            facing: HorizontalFacing::North,
            half: DoubleBlockHalf::Lower,
            hinge: Hinge::Left,
            open: false,
            powered: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct DarkOakDoorState {
    facing: HorizontalFacing,
    half: DoubleBlockHalf,
    hinge: Hinge,
    open: bool,
    powered: bool,
}
impl DarkOakDoorState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_half(&mut self, half: DoubleBlockHalf) -> &mut Self {
        self.half = half;
        self
    }
    pub fn half(&self) -> DoubleBlockHalf {
        self.half
    }
    pub fn with_hinge(&mut self, hinge: Hinge) -> &mut Self {
        self.hinge = hinge;
        self
    }
    pub fn hinge(&self) -> Hinge {
        self.hinge
    }
    pub fn with_open(&mut self, open: bool) -> &mut Self {
        self.open = open;
        self
    }
    pub fn open(&self) -> bool {
        self.open
    }
    pub fn with_powered(&mut self, powered: bool) -> &mut Self {
        self.powered = powered;
        self
    }
    pub fn powered(&self) -> bool {
        self.powered
    }
}
impl Default for DarkOakDoorState {
    fn default() -> Self {
        DarkOakDoorState {
            facing: HorizontalFacing::North,
            half: DoubleBlockHalf::Lower,
            hinge: Hinge::Left,
            open: false,
            powered: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct EndRodState {
    facing: AllFacing,
}
impl EndRodState {
    pub fn with_facing(&mut self, facing: AllFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> AllFacing {
        self.facing
    }
}
impl Default for EndRodState {
    fn default() -> Self {
        EndRodState {
            facing: AllFacing::Up,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct ChorusPlantState {
    down: bool,
    east: bool,
    north: bool,
    south: bool,
    up: bool,
    west: bool,
}
impl ChorusPlantState {
    pub fn with_down(&mut self, down: bool) -> &mut Self {
        self.down = down;
        self
    }
    pub fn down(&self) -> bool {
        self.down
    }
    pub fn with_east(&mut self, east: bool) -> &mut Self {
        self.east = east;
        self
    }
    pub fn east(&self) -> bool {
        self.east
    }
    pub fn with_north(&mut self, north: bool) -> &mut Self {
        self.north = north;
        self
    }
    pub fn north(&self) -> bool {
        self.north
    }
    pub fn with_south(&mut self, south: bool) -> &mut Self {
        self.south = south;
        self
    }
    pub fn south(&self) -> bool {
        self.south
    }
    pub fn with_up(&mut self, up: bool) -> &mut Self {
        self.up = up;
        self
    }
    pub fn up(&self) -> bool {
        self.up
    }
    pub fn with_west(&mut self, west: bool) -> &mut Self {
        self.west = west;
        self
    }
    pub fn west(&self) -> bool {
        self.west
    }
}
impl Default for ChorusPlantState {
    fn default() -> Self {
        ChorusPlantState {
            down: false,
            east: false,
            north: false,
            south: false,
            up: false,
            west: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct ChorusFlowerState {
    age: i32,
}
impl ChorusFlowerState {
    /// This is a value between 0 and 5 (both ends inclusive).\Developers should be careful to respect these bounds as no checking is done at runtime!!!
    pub fn with_age(&mut self, age: i32) -> &mut Self {
        self.age = age;
        self
    }
    pub fn age(&self) -> i32 {
        self.age
    }
}
impl Default for ChorusFlowerState {
    fn default() -> Self {
        ChorusFlowerState {
            age: 0,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct PurpurPillarState {
    axis: Axis,
}
impl PurpurPillarState {
    pub fn with_axis(&mut self, axis: Axis) -> &mut Self {
        self.axis = axis;
        self
    }
    pub fn axis(&self) -> Axis {
        self.axis
    }
}
impl Default for PurpurPillarState {
    fn default() -> Self {
        PurpurPillarState {
            axis: Axis::Y,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct PurpurStairsState {
    facing: HorizontalFacing,
    half: SingleBlockHalf,
    shape: StairShape,
    waterlogged: bool,
}
impl PurpurStairsState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_half(&mut self, half: SingleBlockHalf) -> &mut Self {
        self.half = half;
        self
    }
    pub fn half(&self) -> SingleBlockHalf {
        self.half
    }
    pub fn with_shape(&mut self, shape: StairShape) -> &mut Self {
        self.shape = shape;
        self
    }
    pub fn shape(&self) -> StairShape {
        self.shape
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for PurpurStairsState {
    fn default() -> Self {
        PurpurStairsState {
            facing: HorizontalFacing::North,
            half: SingleBlockHalf::Bottom,
            shape: StairShape::Straight,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct BeetrootsState {
    age: i32,
}
impl BeetrootsState {
    /// This is a value between 0 and 3 (both ends inclusive).\Developers should be careful to respect these bounds as no checking is done at runtime!!!
    pub fn with_age(&mut self, age: i32) -> &mut Self {
        self.age = age;
        self
    }
    pub fn age(&self) -> i32 {
        self.age
    }
}
impl Default for BeetrootsState {
    fn default() -> Self {
        BeetrootsState {
            age: 0,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct RepeatingCommandBlockState {
    conditional: bool,
    facing: AllFacing,
}
impl RepeatingCommandBlockState {
    pub fn with_conditional(&mut self, conditional: bool) -> &mut Self {
        self.conditional = conditional;
        self
    }
    pub fn conditional(&self) -> bool {
        self.conditional
    }
    pub fn with_facing(&mut self, facing: AllFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> AllFacing {
        self.facing
    }
}
impl Default for RepeatingCommandBlockState {
    fn default() -> Self {
        RepeatingCommandBlockState {
            conditional: false,
            facing: AllFacing::North,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct ChainCommandBlockState {
    conditional: bool,
    facing: AllFacing,
}
impl ChainCommandBlockState {
    pub fn with_conditional(&mut self, conditional: bool) -> &mut Self {
        self.conditional = conditional;
        self
    }
    pub fn conditional(&self) -> bool {
        self.conditional
    }
    pub fn with_facing(&mut self, facing: AllFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> AllFacing {
        self.facing
    }
}
impl Default for ChainCommandBlockState {
    fn default() -> Self {
        ChainCommandBlockState {
            conditional: false,
            facing: AllFacing::North,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct FrostedIceState {
    age: i32,
}
impl FrostedIceState {
    /// This is a value between 0 and 3 (both ends inclusive).\Developers should be careful to respect these bounds as no checking is done at runtime!!!
    pub fn with_age(&mut self, age: i32) -> &mut Self {
        self.age = age;
        self
    }
    pub fn age(&self) -> i32 {
        self.age
    }
}
impl Default for FrostedIceState {
    fn default() -> Self {
        FrostedIceState {
            age: 0,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct BoneBlockState {
    axis: Axis,
}
impl BoneBlockState {
    pub fn with_axis(&mut self, axis: Axis) -> &mut Self {
        self.axis = axis;
        self
    }
    pub fn axis(&self) -> Axis {
        self.axis
    }
}
impl Default for BoneBlockState {
    fn default() -> Self {
        BoneBlockState {
            axis: Axis::Y,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct ObserverState {
    facing: AllFacing,
    powered: bool,
}
impl ObserverState {
    pub fn with_facing(&mut self, facing: AllFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> AllFacing {
        self.facing
    }
    pub fn with_powered(&mut self, powered: bool) -> &mut Self {
        self.powered = powered;
        self
    }
    pub fn powered(&self) -> bool {
        self.powered
    }
}
impl Default for ObserverState {
    fn default() -> Self {
        ObserverState {
            facing: AllFacing::South,
            powered: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct ShulkerBoxState {
    facing: AllFacing,
}
impl ShulkerBoxState {
    pub fn with_facing(&mut self, facing: AllFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> AllFacing {
        self.facing
    }
}
impl Default for ShulkerBoxState {
    fn default() -> Self {
        ShulkerBoxState {
            facing: AllFacing::Up,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct WhiteShulkerBoxState {
    facing: AllFacing,
}
impl WhiteShulkerBoxState {
    pub fn with_facing(&mut self, facing: AllFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> AllFacing {
        self.facing
    }
}
impl Default for WhiteShulkerBoxState {
    fn default() -> Self {
        WhiteShulkerBoxState {
            facing: AllFacing::Up,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct OrangeShulkerBoxState {
    facing: AllFacing,
}
impl OrangeShulkerBoxState {
    pub fn with_facing(&mut self, facing: AllFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> AllFacing {
        self.facing
    }
}
impl Default for OrangeShulkerBoxState {
    fn default() -> Self {
        OrangeShulkerBoxState {
            facing: AllFacing::Up,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct MagentaShulkerBoxState {
    facing: AllFacing,
}
impl MagentaShulkerBoxState {
    pub fn with_facing(&mut self, facing: AllFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> AllFacing {
        self.facing
    }
}
impl Default for MagentaShulkerBoxState {
    fn default() -> Self {
        MagentaShulkerBoxState {
            facing: AllFacing::Up,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct LightBlueShulkerBoxState {
    facing: AllFacing,
}
impl LightBlueShulkerBoxState {
    pub fn with_facing(&mut self, facing: AllFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> AllFacing {
        self.facing
    }
}
impl Default for LightBlueShulkerBoxState {
    fn default() -> Self {
        LightBlueShulkerBoxState {
            facing: AllFacing::Up,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct YellowShulkerBoxState {
    facing: AllFacing,
}
impl YellowShulkerBoxState {
    pub fn with_facing(&mut self, facing: AllFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> AllFacing {
        self.facing
    }
}
impl Default for YellowShulkerBoxState {
    fn default() -> Self {
        YellowShulkerBoxState {
            facing: AllFacing::Up,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct LimeShulkerBoxState {
    facing: AllFacing,
}
impl LimeShulkerBoxState {
    pub fn with_facing(&mut self, facing: AllFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> AllFacing {
        self.facing
    }
}
impl Default for LimeShulkerBoxState {
    fn default() -> Self {
        LimeShulkerBoxState {
            facing: AllFacing::Up,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct PinkShulkerBoxState {
    facing: AllFacing,
}
impl PinkShulkerBoxState {
    pub fn with_facing(&mut self, facing: AllFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> AllFacing {
        self.facing
    }
}
impl Default for PinkShulkerBoxState {
    fn default() -> Self {
        PinkShulkerBoxState {
            facing: AllFacing::Up,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct GrayShulkerBoxState {
    facing: AllFacing,
}
impl GrayShulkerBoxState {
    pub fn with_facing(&mut self, facing: AllFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> AllFacing {
        self.facing
    }
}
impl Default for GrayShulkerBoxState {
    fn default() -> Self {
        GrayShulkerBoxState {
            facing: AllFacing::Up,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct LightGrayShulkerBoxState {
    facing: AllFacing,
}
impl LightGrayShulkerBoxState {
    pub fn with_facing(&mut self, facing: AllFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> AllFacing {
        self.facing
    }
}
impl Default for LightGrayShulkerBoxState {
    fn default() -> Self {
        LightGrayShulkerBoxState {
            facing: AllFacing::Up,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct CyanShulkerBoxState {
    facing: AllFacing,
}
impl CyanShulkerBoxState {
    pub fn with_facing(&mut self, facing: AllFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> AllFacing {
        self.facing
    }
}
impl Default for CyanShulkerBoxState {
    fn default() -> Self {
        CyanShulkerBoxState {
            facing: AllFacing::Up,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct PurpleShulkerBoxState {
    facing: AllFacing,
}
impl PurpleShulkerBoxState {
    pub fn with_facing(&mut self, facing: AllFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> AllFacing {
        self.facing
    }
}
impl Default for PurpleShulkerBoxState {
    fn default() -> Self {
        PurpleShulkerBoxState {
            facing: AllFacing::Up,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct BlueShulkerBoxState {
    facing: AllFacing,
}
impl BlueShulkerBoxState {
    pub fn with_facing(&mut self, facing: AllFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> AllFacing {
        self.facing
    }
}
impl Default for BlueShulkerBoxState {
    fn default() -> Self {
        BlueShulkerBoxState {
            facing: AllFacing::Up,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct BrownShulkerBoxState {
    facing: AllFacing,
}
impl BrownShulkerBoxState {
    pub fn with_facing(&mut self, facing: AllFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> AllFacing {
        self.facing
    }
}
impl Default for BrownShulkerBoxState {
    fn default() -> Self {
        BrownShulkerBoxState {
            facing: AllFacing::Up,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct GreenShulkerBoxState {
    facing: AllFacing,
}
impl GreenShulkerBoxState {
    pub fn with_facing(&mut self, facing: AllFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> AllFacing {
        self.facing
    }
}
impl Default for GreenShulkerBoxState {
    fn default() -> Self {
        GreenShulkerBoxState {
            facing: AllFacing::Up,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct RedShulkerBoxState {
    facing: AllFacing,
}
impl RedShulkerBoxState {
    pub fn with_facing(&mut self, facing: AllFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> AllFacing {
        self.facing
    }
}
impl Default for RedShulkerBoxState {
    fn default() -> Self {
        RedShulkerBoxState {
            facing: AllFacing::Up,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct BlackShulkerBoxState {
    facing: AllFacing,
}
impl BlackShulkerBoxState {
    pub fn with_facing(&mut self, facing: AllFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> AllFacing {
        self.facing
    }
}
impl Default for BlackShulkerBoxState {
    fn default() -> Self {
        BlackShulkerBoxState {
            facing: AllFacing::Up,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct WhiteGlazedTerracottaState {
    facing: HorizontalFacing,
}
impl WhiteGlazedTerracottaState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
}
impl Default for WhiteGlazedTerracottaState {
    fn default() -> Self {
        WhiteGlazedTerracottaState {
            facing: HorizontalFacing::North,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct OrangeGlazedTerracottaState {
    facing: HorizontalFacing,
}
impl OrangeGlazedTerracottaState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
}
impl Default for OrangeGlazedTerracottaState {
    fn default() -> Self {
        OrangeGlazedTerracottaState {
            facing: HorizontalFacing::North,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct MagentaGlazedTerracottaState {
    facing: HorizontalFacing,
}
impl MagentaGlazedTerracottaState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
}
impl Default for MagentaGlazedTerracottaState {
    fn default() -> Self {
        MagentaGlazedTerracottaState {
            facing: HorizontalFacing::North,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct LightBlueGlazedTerracottaState {
    facing: HorizontalFacing,
}
impl LightBlueGlazedTerracottaState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
}
impl Default for LightBlueGlazedTerracottaState {
    fn default() -> Self {
        LightBlueGlazedTerracottaState {
            facing: HorizontalFacing::North,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct YellowGlazedTerracottaState {
    facing: HorizontalFacing,
}
impl YellowGlazedTerracottaState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
}
impl Default for YellowGlazedTerracottaState {
    fn default() -> Self {
        YellowGlazedTerracottaState {
            facing: HorizontalFacing::North,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct LimeGlazedTerracottaState {
    facing: HorizontalFacing,
}
impl LimeGlazedTerracottaState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
}
impl Default for LimeGlazedTerracottaState {
    fn default() -> Self {
        LimeGlazedTerracottaState {
            facing: HorizontalFacing::North,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct PinkGlazedTerracottaState {
    facing: HorizontalFacing,
}
impl PinkGlazedTerracottaState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
}
impl Default for PinkGlazedTerracottaState {
    fn default() -> Self {
        PinkGlazedTerracottaState {
            facing: HorizontalFacing::North,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct GrayGlazedTerracottaState {
    facing: HorizontalFacing,
}
impl GrayGlazedTerracottaState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
}
impl Default for GrayGlazedTerracottaState {
    fn default() -> Self {
        GrayGlazedTerracottaState {
            facing: HorizontalFacing::North,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct LightGrayGlazedTerracottaState {
    facing: HorizontalFacing,
}
impl LightGrayGlazedTerracottaState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
}
impl Default for LightGrayGlazedTerracottaState {
    fn default() -> Self {
        LightGrayGlazedTerracottaState {
            facing: HorizontalFacing::North,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct CyanGlazedTerracottaState {
    facing: HorizontalFacing,
}
impl CyanGlazedTerracottaState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
}
impl Default for CyanGlazedTerracottaState {
    fn default() -> Self {
        CyanGlazedTerracottaState {
            facing: HorizontalFacing::North,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct PurpleGlazedTerracottaState {
    facing: HorizontalFacing,
}
impl PurpleGlazedTerracottaState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
}
impl Default for PurpleGlazedTerracottaState {
    fn default() -> Self {
        PurpleGlazedTerracottaState {
            facing: HorizontalFacing::North,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct BlueGlazedTerracottaState {
    facing: HorizontalFacing,
}
impl BlueGlazedTerracottaState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
}
impl Default for BlueGlazedTerracottaState {
    fn default() -> Self {
        BlueGlazedTerracottaState {
            facing: HorizontalFacing::North,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct BrownGlazedTerracottaState {
    facing: HorizontalFacing,
}
impl BrownGlazedTerracottaState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
}
impl Default for BrownGlazedTerracottaState {
    fn default() -> Self {
        BrownGlazedTerracottaState {
            facing: HorizontalFacing::North,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct GreenGlazedTerracottaState {
    facing: HorizontalFacing,
}
impl GreenGlazedTerracottaState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
}
impl Default for GreenGlazedTerracottaState {
    fn default() -> Self {
        GreenGlazedTerracottaState {
            facing: HorizontalFacing::North,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct RedGlazedTerracottaState {
    facing: HorizontalFacing,
}
impl RedGlazedTerracottaState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
}
impl Default for RedGlazedTerracottaState {
    fn default() -> Self {
        RedGlazedTerracottaState {
            facing: HorizontalFacing::North,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct BlackGlazedTerracottaState {
    facing: HorizontalFacing,
}
impl BlackGlazedTerracottaState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
}
impl Default for BlackGlazedTerracottaState {
    fn default() -> Self {
        BlackGlazedTerracottaState {
            facing: HorizontalFacing::North,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct KelpState {
    age: i32,
}
impl KelpState {
    /// This is a value between 0 and 25 (both ends inclusive).\Developers should be careful to respect these bounds as no checking is done at runtime!!!
    pub fn with_age(&mut self, age: i32) -> &mut Self {
        self.age = age;
        self
    }
    pub fn age(&self) -> i32 {
        self.age
    }
}
impl Default for KelpState {
    fn default() -> Self {
        KelpState {
            age: 0,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct TurtleEggState {
    eggs: i32,
    hatch: i32,
}
impl TurtleEggState {
    /// This is a value between 1 and 4 (both ends inclusive).\Developers should be careful to respect these bounds as no checking is done at runtime!!!
    pub fn with_eggs(&mut self, eggs: i32) -> &mut Self {
        self.eggs = eggs - 1;
        self
    }
    pub fn eggs(&self) -> i32 {
        self.eggs + 1
    }
    /// This is a value between 0 and 2 (both ends inclusive).\Developers should be careful to respect these bounds as no checking is done at runtime!!!
    pub fn with_hatch(&mut self, hatch: i32) -> &mut Self {
        self.hatch = hatch;
        self
    }
    pub fn hatch(&self) -> i32 {
        self.hatch
    }
}
impl Default for TurtleEggState {
    fn default() -> Self {
        TurtleEggState {
            eggs: 0,
            hatch: 0,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct DeadTubeCoralState {
    waterlogged: bool,
}
impl DeadTubeCoralState {
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for DeadTubeCoralState {
    fn default() -> Self {
        DeadTubeCoralState {
            waterlogged: true,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct DeadBrainCoralState {
    waterlogged: bool,
}
impl DeadBrainCoralState {
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for DeadBrainCoralState {
    fn default() -> Self {
        DeadBrainCoralState {
            waterlogged: true,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct DeadBubbleCoralState {
    waterlogged: bool,
}
impl DeadBubbleCoralState {
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for DeadBubbleCoralState {
    fn default() -> Self {
        DeadBubbleCoralState {
            waterlogged: true,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct DeadFireCoralState {
    waterlogged: bool,
}
impl DeadFireCoralState {
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for DeadFireCoralState {
    fn default() -> Self {
        DeadFireCoralState {
            waterlogged: true,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct DeadHornCoralState {
    waterlogged: bool,
}
impl DeadHornCoralState {
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for DeadHornCoralState {
    fn default() -> Self {
        DeadHornCoralState {
            waterlogged: true,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct TubeCoralState {
    waterlogged: bool,
}
impl TubeCoralState {
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for TubeCoralState {
    fn default() -> Self {
        TubeCoralState {
            waterlogged: true,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct BrainCoralState {
    waterlogged: bool,
}
impl BrainCoralState {
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for BrainCoralState {
    fn default() -> Self {
        BrainCoralState {
            waterlogged: true,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct BubbleCoralState {
    waterlogged: bool,
}
impl BubbleCoralState {
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for BubbleCoralState {
    fn default() -> Self {
        BubbleCoralState {
            waterlogged: true,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct FireCoralState {
    waterlogged: bool,
}
impl FireCoralState {
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for FireCoralState {
    fn default() -> Self {
        FireCoralState {
            waterlogged: true,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct HornCoralState {
    waterlogged: bool,
}
impl HornCoralState {
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for HornCoralState {
    fn default() -> Self {
        HornCoralState {
            waterlogged: true,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct DeadTubeCoralFanState {
    waterlogged: bool,
}
impl DeadTubeCoralFanState {
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for DeadTubeCoralFanState {
    fn default() -> Self {
        DeadTubeCoralFanState {
            waterlogged: true,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct DeadBrainCoralFanState {
    waterlogged: bool,
}
impl DeadBrainCoralFanState {
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for DeadBrainCoralFanState {
    fn default() -> Self {
        DeadBrainCoralFanState {
            waterlogged: true,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct DeadBubbleCoralFanState {
    waterlogged: bool,
}
impl DeadBubbleCoralFanState {
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for DeadBubbleCoralFanState {
    fn default() -> Self {
        DeadBubbleCoralFanState {
            waterlogged: true,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct DeadFireCoralFanState {
    waterlogged: bool,
}
impl DeadFireCoralFanState {
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for DeadFireCoralFanState {
    fn default() -> Self {
        DeadFireCoralFanState {
            waterlogged: true,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct DeadHornCoralFanState {
    waterlogged: bool,
}
impl DeadHornCoralFanState {
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for DeadHornCoralFanState {
    fn default() -> Self {
        DeadHornCoralFanState {
            waterlogged: true,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct TubeCoralFanState {
    waterlogged: bool,
}
impl TubeCoralFanState {
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for TubeCoralFanState {
    fn default() -> Self {
        TubeCoralFanState {
            waterlogged: true,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct BrainCoralFanState {
    waterlogged: bool,
}
impl BrainCoralFanState {
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for BrainCoralFanState {
    fn default() -> Self {
        BrainCoralFanState {
            waterlogged: true,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct BubbleCoralFanState {
    waterlogged: bool,
}
impl BubbleCoralFanState {
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for BubbleCoralFanState {
    fn default() -> Self {
        BubbleCoralFanState {
            waterlogged: true,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct FireCoralFanState {
    waterlogged: bool,
}
impl FireCoralFanState {
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for FireCoralFanState {
    fn default() -> Self {
        FireCoralFanState {
            waterlogged: true,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct HornCoralFanState {
    waterlogged: bool,
}
impl HornCoralFanState {
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for HornCoralFanState {
    fn default() -> Self {
        HornCoralFanState {
            waterlogged: true,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct DeadTubeCoralWallFanState {
    facing: HorizontalFacing,
    waterlogged: bool,
}
impl DeadTubeCoralWallFanState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for DeadTubeCoralWallFanState {
    fn default() -> Self {
        DeadTubeCoralWallFanState {
            facing: HorizontalFacing::North,
            waterlogged: true,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct DeadBrainCoralWallFanState {
    facing: HorizontalFacing,
    waterlogged: bool,
}
impl DeadBrainCoralWallFanState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for DeadBrainCoralWallFanState {
    fn default() -> Self {
        DeadBrainCoralWallFanState {
            facing: HorizontalFacing::North,
            waterlogged: true,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct DeadBubbleCoralWallFanState {
    facing: HorizontalFacing,
    waterlogged: bool,
}
impl DeadBubbleCoralWallFanState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for DeadBubbleCoralWallFanState {
    fn default() -> Self {
        DeadBubbleCoralWallFanState {
            facing: HorizontalFacing::North,
            waterlogged: true,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct DeadFireCoralWallFanState {
    facing: HorizontalFacing,
    waterlogged: bool,
}
impl DeadFireCoralWallFanState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for DeadFireCoralWallFanState {
    fn default() -> Self {
        DeadFireCoralWallFanState {
            facing: HorizontalFacing::North,
            waterlogged: true,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct DeadHornCoralWallFanState {
    facing: HorizontalFacing,
    waterlogged: bool,
}
impl DeadHornCoralWallFanState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for DeadHornCoralWallFanState {
    fn default() -> Self {
        DeadHornCoralWallFanState {
            facing: HorizontalFacing::North,
            waterlogged: true,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct TubeCoralWallFanState {
    facing: HorizontalFacing,
    waterlogged: bool,
}
impl TubeCoralWallFanState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for TubeCoralWallFanState {
    fn default() -> Self {
        TubeCoralWallFanState {
            facing: HorizontalFacing::North,
            waterlogged: true,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct BrainCoralWallFanState {
    facing: HorizontalFacing,
    waterlogged: bool,
}
impl BrainCoralWallFanState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for BrainCoralWallFanState {
    fn default() -> Self {
        BrainCoralWallFanState {
            facing: HorizontalFacing::North,
            waterlogged: true,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct BubbleCoralWallFanState {
    facing: HorizontalFacing,
    waterlogged: bool,
}
impl BubbleCoralWallFanState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for BubbleCoralWallFanState {
    fn default() -> Self {
        BubbleCoralWallFanState {
            facing: HorizontalFacing::North,
            waterlogged: true,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct FireCoralWallFanState {
    facing: HorizontalFacing,
    waterlogged: bool,
}
impl FireCoralWallFanState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for FireCoralWallFanState {
    fn default() -> Self {
        FireCoralWallFanState {
            facing: HorizontalFacing::North,
            waterlogged: true,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct HornCoralWallFanState {
    facing: HorizontalFacing,
    waterlogged: bool,
}
impl HornCoralWallFanState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for HornCoralWallFanState {
    fn default() -> Self {
        HornCoralWallFanState {
            facing: HorizontalFacing::North,
            waterlogged: true,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct SeaPickleState {
    pickles: i32,
    waterlogged: bool,
}
impl SeaPickleState {
    /// This is a value between 1 and 4 (both ends inclusive).\Developers should be careful to respect these bounds as no checking is done at runtime!!!
    pub fn with_pickles(&mut self, pickles: i32) -> &mut Self {
        self.pickles = pickles - 1;
        self
    }
    pub fn pickles(&self) -> i32 {
        self.pickles + 1
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for SeaPickleState {
    fn default() -> Self {
        SeaPickleState {
            pickles: 0,
            waterlogged: true,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct ConduitState {
    waterlogged: bool,
}
impl ConduitState {
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for ConduitState {
    fn default() -> Self {
        ConduitState {
            waterlogged: true,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct BambooState {
    age: i32,
    leaves: Leaves,
    stage: i32,
}
impl BambooState {
    /// This is a value between 0 and 1 (both ends inclusive).\Developers should be careful to respect these bounds as no checking is done at runtime!!!
    pub fn with_age(&mut self, age: i32) -> &mut Self {
        self.age = age;
        self
    }
    pub fn age(&self) -> i32 {
        self.age
    }
    pub fn with_leaves(&mut self, leaves: Leaves) -> &mut Self {
        self.leaves = leaves;
        self
    }
    pub fn leaves(&self) -> Leaves {
        self.leaves
    }
    /// This is a value between 0 and 1 (both ends inclusive).\Developers should be careful to respect these bounds as no checking is done at runtime!!!
    pub fn with_stage(&mut self, stage: i32) -> &mut Self {
        self.stage = stage;
        self
    }
    pub fn stage(&self) -> i32 {
        self.stage
    }
}
impl Default for BambooState {
    fn default() -> Self {
        BambooState {
            age: 0,
            leaves: Leaves::None,
            stage: 0,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct BubbleColumnState {
    drag: bool,
}
impl BubbleColumnState {
    pub fn with_drag(&mut self, drag: bool) -> &mut Self {
        self.drag = drag;
        self
    }
    pub fn drag(&self) -> bool {
        self.drag
    }
}
impl Default for BubbleColumnState {
    fn default() -> Self {
        BubbleColumnState {
            drag: true,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct PolishedGraniteStairsState {
    facing: HorizontalFacing,
    half: SingleBlockHalf,
    shape: StairShape,
    waterlogged: bool,
}
impl PolishedGraniteStairsState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_half(&mut self, half: SingleBlockHalf) -> &mut Self {
        self.half = half;
        self
    }
    pub fn half(&self) -> SingleBlockHalf {
        self.half
    }
    pub fn with_shape(&mut self, shape: StairShape) -> &mut Self {
        self.shape = shape;
        self
    }
    pub fn shape(&self) -> StairShape {
        self.shape
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for PolishedGraniteStairsState {
    fn default() -> Self {
        PolishedGraniteStairsState {
            facing: HorizontalFacing::North,
            half: SingleBlockHalf::Bottom,
            shape: StairShape::Straight,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct SmoothRedSandstoneStairsState {
    facing: HorizontalFacing,
    half: SingleBlockHalf,
    shape: StairShape,
    waterlogged: bool,
}
impl SmoothRedSandstoneStairsState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_half(&mut self, half: SingleBlockHalf) -> &mut Self {
        self.half = half;
        self
    }
    pub fn half(&self) -> SingleBlockHalf {
        self.half
    }
    pub fn with_shape(&mut self, shape: StairShape) -> &mut Self {
        self.shape = shape;
        self
    }
    pub fn shape(&self) -> StairShape {
        self.shape
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for SmoothRedSandstoneStairsState {
    fn default() -> Self {
        SmoothRedSandstoneStairsState {
            facing: HorizontalFacing::North,
            half: SingleBlockHalf::Bottom,
            shape: StairShape::Straight,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct MossyStoneBrickStairsState {
    facing: HorizontalFacing,
    half: SingleBlockHalf,
    shape: StairShape,
    waterlogged: bool,
}
impl MossyStoneBrickStairsState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_half(&mut self, half: SingleBlockHalf) -> &mut Self {
        self.half = half;
        self
    }
    pub fn half(&self) -> SingleBlockHalf {
        self.half
    }
    pub fn with_shape(&mut self, shape: StairShape) -> &mut Self {
        self.shape = shape;
        self
    }
    pub fn shape(&self) -> StairShape {
        self.shape
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for MossyStoneBrickStairsState {
    fn default() -> Self {
        MossyStoneBrickStairsState {
            facing: HorizontalFacing::North,
            half: SingleBlockHalf::Bottom,
            shape: StairShape::Straight,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct PolishedDioriteStairsState {
    facing: HorizontalFacing,
    half: SingleBlockHalf,
    shape: StairShape,
    waterlogged: bool,
}
impl PolishedDioriteStairsState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_half(&mut self, half: SingleBlockHalf) -> &mut Self {
        self.half = half;
        self
    }
    pub fn half(&self) -> SingleBlockHalf {
        self.half
    }
    pub fn with_shape(&mut self, shape: StairShape) -> &mut Self {
        self.shape = shape;
        self
    }
    pub fn shape(&self) -> StairShape {
        self.shape
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for PolishedDioriteStairsState {
    fn default() -> Self {
        PolishedDioriteStairsState {
            facing: HorizontalFacing::North,
            half: SingleBlockHalf::Bottom,
            shape: StairShape::Straight,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct MossyCobblestoneStairsState {
    facing: HorizontalFacing,
    half: SingleBlockHalf,
    shape: StairShape,
    waterlogged: bool,
}
impl MossyCobblestoneStairsState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_half(&mut self, half: SingleBlockHalf) -> &mut Self {
        self.half = half;
        self
    }
    pub fn half(&self) -> SingleBlockHalf {
        self.half
    }
    pub fn with_shape(&mut self, shape: StairShape) -> &mut Self {
        self.shape = shape;
        self
    }
    pub fn shape(&self) -> StairShape {
        self.shape
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for MossyCobblestoneStairsState {
    fn default() -> Self {
        MossyCobblestoneStairsState {
            facing: HorizontalFacing::North,
            half: SingleBlockHalf::Bottom,
            shape: StairShape::Straight,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct EndStoneBrickStairsState {
    facing: HorizontalFacing,
    half: SingleBlockHalf,
    shape: StairShape,
    waterlogged: bool,
}
impl EndStoneBrickStairsState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_half(&mut self, half: SingleBlockHalf) -> &mut Self {
        self.half = half;
        self
    }
    pub fn half(&self) -> SingleBlockHalf {
        self.half
    }
    pub fn with_shape(&mut self, shape: StairShape) -> &mut Self {
        self.shape = shape;
        self
    }
    pub fn shape(&self) -> StairShape {
        self.shape
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for EndStoneBrickStairsState {
    fn default() -> Self {
        EndStoneBrickStairsState {
            facing: HorizontalFacing::North,
            half: SingleBlockHalf::Bottom,
            shape: StairShape::Straight,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct StoneStairsState {
    facing: HorizontalFacing,
    half: SingleBlockHalf,
    shape: StairShape,
    waterlogged: bool,
}
impl StoneStairsState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_half(&mut self, half: SingleBlockHalf) -> &mut Self {
        self.half = half;
        self
    }
    pub fn half(&self) -> SingleBlockHalf {
        self.half
    }
    pub fn with_shape(&mut self, shape: StairShape) -> &mut Self {
        self.shape = shape;
        self
    }
    pub fn shape(&self) -> StairShape {
        self.shape
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for StoneStairsState {
    fn default() -> Self {
        StoneStairsState {
            facing: HorizontalFacing::North,
            half: SingleBlockHalf::Bottom,
            shape: StairShape::Straight,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct SmoothSandstoneStairsState {
    facing: HorizontalFacing,
    half: SingleBlockHalf,
    shape: StairShape,
    waterlogged: bool,
}
impl SmoothSandstoneStairsState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_half(&mut self, half: SingleBlockHalf) -> &mut Self {
        self.half = half;
        self
    }
    pub fn half(&self) -> SingleBlockHalf {
        self.half
    }
    pub fn with_shape(&mut self, shape: StairShape) -> &mut Self {
        self.shape = shape;
        self
    }
    pub fn shape(&self) -> StairShape {
        self.shape
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for SmoothSandstoneStairsState {
    fn default() -> Self {
        SmoothSandstoneStairsState {
            facing: HorizontalFacing::North,
            half: SingleBlockHalf::Bottom,
            shape: StairShape::Straight,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct SmoothQuartzStairsState {
    facing: HorizontalFacing,
    half: SingleBlockHalf,
    shape: StairShape,
    waterlogged: bool,
}
impl SmoothQuartzStairsState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_half(&mut self, half: SingleBlockHalf) -> &mut Self {
        self.half = half;
        self
    }
    pub fn half(&self) -> SingleBlockHalf {
        self.half
    }
    pub fn with_shape(&mut self, shape: StairShape) -> &mut Self {
        self.shape = shape;
        self
    }
    pub fn shape(&self) -> StairShape {
        self.shape
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for SmoothQuartzStairsState {
    fn default() -> Self {
        SmoothQuartzStairsState {
            facing: HorizontalFacing::North,
            half: SingleBlockHalf::Bottom,
            shape: StairShape::Straight,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct GraniteStairsState {
    facing: HorizontalFacing,
    half: SingleBlockHalf,
    shape: StairShape,
    waterlogged: bool,
}
impl GraniteStairsState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_half(&mut self, half: SingleBlockHalf) -> &mut Self {
        self.half = half;
        self
    }
    pub fn half(&self) -> SingleBlockHalf {
        self.half
    }
    pub fn with_shape(&mut self, shape: StairShape) -> &mut Self {
        self.shape = shape;
        self
    }
    pub fn shape(&self) -> StairShape {
        self.shape
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for GraniteStairsState {
    fn default() -> Self {
        GraniteStairsState {
            facing: HorizontalFacing::North,
            half: SingleBlockHalf::Bottom,
            shape: StairShape::Straight,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct AndesiteStairsState {
    facing: HorizontalFacing,
    half: SingleBlockHalf,
    shape: StairShape,
    waterlogged: bool,
}
impl AndesiteStairsState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_half(&mut self, half: SingleBlockHalf) -> &mut Self {
        self.half = half;
        self
    }
    pub fn half(&self) -> SingleBlockHalf {
        self.half
    }
    pub fn with_shape(&mut self, shape: StairShape) -> &mut Self {
        self.shape = shape;
        self
    }
    pub fn shape(&self) -> StairShape {
        self.shape
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for AndesiteStairsState {
    fn default() -> Self {
        AndesiteStairsState {
            facing: HorizontalFacing::North,
            half: SingleBlockHalf::Bottom,
            shape: StairShape::Straight,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct RedNetherBrickStairsState {
    facing: HorizontalFacing,
    half: SingleBlockHalf,
    shape: StairShape,
    waterlogged: bool,
}
impl RedNetherBrickStairsState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_half(&mut self, half: SingleBlockHalf) -> &mut Self {
        self.half = half;
        self
    }
    pub fn half(&self) -> SingleBlockHalf {
        self.half
    }
    pub fn with_shape(&mut self, shape: StairShape) -> &mut Self {
        self.shape = shape;
        self
    }
    pub fn shape(&self) -> StairShape {
        self.shape
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for RedNetherBrickStairsState {
    fn default() -> Self {
        RedNetherBrickStairsState {
            facing: HorizontalFacing::North,
            half: SingleBlockHalf::Bottom,
            shape: StairShape::Straight,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct PolishedAndesiteStairsState {
    facing: HorizontalFacing,
    half: SingleBlockHalf,
    shape: StairShape,
    waterlogged: bool,
}
impl PolishedAndesiteStairsState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_half(&mut self, half: SingleBlockHalf) -> &mut Self {
        self.half = half;
        self
    }
    pub fn half(&self) -> SingleBlockHalf {
        self.half
    }
    pub fn with_shape(&mut self, shape: StairShape) -> &mut Self {
        self.shape = shape;
        self
    }
    pub fn shape(&self) -> StairShape {
        self.shape
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for PolishedAndesiteStairsState {
    fn default() -> Self {
        PolishedAndesiteStairsState {
            facing: HorizontalFacing::North,
            half: SingleBlockHalf::Bottom,
            shape: StairShape::Straight,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct DioriteStairsState {
    facing: HorizontalFacing,
    half: SingleBlockHalf,
    shape: StairShape,
    waterlogged: bool,
}
impl DioriteStairsState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_half(&mut self, half: SingleBlockHalf) -> &mut Self {
        self.half = half;
        self
    }
    pub fn half(&self) -> SingleBlockHalf {
        self.half
    }
    pub fn with_shape(&mut self, shape: StairShape) -> &mut Self {
        self.shape = shape;
        self
    }
    pub fn shape(&self) -> StairShape {
        self.shape
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for DioriteStairsState {
    fn default() -> Self {
        DioriteStairsState {
            facing: HorizontalFacing::North,
            half: SingleBlockHalf::Bottom,
            shape: StairShape::Straight,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct PolishedGraniteSlabState {
    typed: SlabType,
    waterlogged: bool,
}
impl PolishedGraniteSlabState {
    pub fn with_typed(&mut self, typed: SlabType) -> &mut Self {
        self.typed = typed;
        self
    }
    pub fn typed(&self) -> SlabType {
        self.typed
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for PolishedGraniteSlabState {
    fn default() -> Self {
        PolishedGraniteSlabState {
            typed: SlabType::Bottom,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct SmoothRedSandstoneSlabState {
    typed: SlabType,
    waterlogged: bool,
}
impl SmoothRedSandstoneSlabState {
    pub fn with_typed(&mut self, typed: SlabType) -> &mut Self {
        self.typed = typed;
        self
    }
    pub fn typed(&self) -> SlabType {
        self.typed
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for SmoothRedSandstoneSlabState {
    fn default() -> Self {
        SmoothRedSandstoneSlabState {
            typed: SlabType::Bottom,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct MossyStoneBrickSlabState {
    typed: SlabType,
    waterlogged: bool,
}
impl MossyStoneBrickSlabState {
    pub fn with_typed(&mut self, typed: SlabType) -> &mut Self {
        self.typed = typed;
        self
    }
    pub fn typed(&self) -> SlabType {
        self.typed
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for MossyStoneBrickSlabState {
    fn default() -> Self {
        MossyStoneBrickSlabState {
            typed: SlabType::Bottom,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct PolishedDioriteSlabState {
    typed: SlabType,
    waterlogged: bool,
}
impl PolishedDioriteSlabState {
    pub fn with_typed(&mut self, typed: SlabType) -> &mut Self {
        self.typed = typed;
        self
    }
    pub fn typed(&self) -> SlabType {
        self.typed
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for PolishedDioriteSlabState {
    fn default() -> Self {
        PolishedDioriteSlabState {
            typed: SlabType::Bottom,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct MossyCobblestoneSlabState {
    typed: SlabType,
    waterlogged: bool,
}
impl MossyCobblestoneSlabState {
    pub fn with_typed(&mut self, typed: SlabType) -> &mut Self {
        self.typed = typed;
        self
    }
    pub fn typed(&self) -> SlabType {
        self.typed
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for MossyCobblestoneSlabState {
    fn default() -> Self {
        MossyCobblestoneSlabState {
            typed: SlabType::Bottom,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct EndStoneBrickSlabState {
    typed: SlabType,
    waterlogged: bool,
}
impl EndStoneBrickSlabState {
    pub fn with_typed(&mut self, typed: SlabType) -> &mut Self {
        self.typed = typed;
        self
    }
    pub fn typed(&self) -> SlabType {
        self.typed
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for EndStoneBrickSlabState {
    fn default() -> Self {
        EndStoneBrickSlabState {
            typed: SlabType::Bottom,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct SmoothSandstoneSlabState {
    typed: SlabType,
    waterlogged: bool,
}
impl SmoothSandstoneSlabState {
    pub fn with_typed(&mut self, typed: SlabType) -> &mut Self {
        self.typed = typed;
        self
    }
    pub fn typed(&self) -> SlabType {
        self.typed
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for SmoothSandstoneSlabState {
    fn default() -> Self {
        SmoothSandstoneSlabState {
            typed: SlabType::Bottom,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct SmoothQuartzSlabState {
    typed: SlabType,
    waterlogged: bool,
}
impl SmoothQuartzSlabState {
    pub fn with_typed(&mut self, typed: SlabType) -> &mut Self {
        self.typed = typed;
        self
    }
    pub fn typed(&self) -> SlabType {
        self.typed
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for SmoothQuartzSlabState {
    fn default() -> Self {
        SmoothQuartzSlabState {
            typed: SlabType::Bottom,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct GraniteSlabState {
    typed: SlabType,
    waterlogged: bool,
}
impl GraniteSlabState {
    pub fn with_typed(&mut self, typed: SlabType) -> &mut Self {
        self.typed = typed;
        self
    }
    pub fn typed(&self) -> SlabType {
        self.typed
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for GraniteSlabState {
    fn default() -> Self {
        GraniteSlabState {
            typed: SlabType::Bottom,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct AndesiteSlabState {
    typed: SlabType,
    waterlogged: bool,
}
impl AndesiteSlabState {
    pub fn with_typed(&mut self, typed: SlabType) -> &mut Self {
        self.typed = typed;
        self
    }
    pub fn typed(&self) -> SlabType {
        self.typed
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for AndesiteSlabState {
    fn default() -> Self {
        AndesiteSlabState {
            typed: SlabType::Bottom,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct RedNetherBrickSlabState {
    typed: SlabType,
    waterlogged: bool,
}
impl RedNetherBrickSlabState {
    pub fn with_typed(&mut self, typed: SlabType) -> &mut Self {
        self.typed = typed;
        self
    }
    pub fn typed(&self) -> SlabType {
        self.typed
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for RedNetherBrickSlabState {
    fn default() -> Self {
        RedNetherBrickSlabState {
            typed: SlabType::Bottom,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct PolishedAndesiteSlabState {
    typed: SlabType,
    waterlogged: bool,
}
impl PolishedAndesiteSlabState {
    pub fn with_typed(&mut self, typed: SlabType) -> &mut Self {
        self.typed = typed;
        self
    }
    pub fn typed(&self) -> SlabType {
        self.typed
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for PolishedAndesiteSlabState {
    fn default() -> Self {
        PolishedAndesiteSlabState {
            typed: SlabType::Bottom,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct DioriteSlabState {
    typed: SlabType,
    waterlogged: bool,
}
impl DioriteSlabState {
    pub fn with_typed(&mut self, typed: SlabType) -> &mut Self {
        self.typed = typed;
        self
    }
    pub fn typed(&self) -> SlabType {
        self.typed
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for DioriteSlabState {
    fn default() -> Self {
        DioriteSlabState {
            typed: SlabType::Bottom,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct BrickWallState {
    east: WallType,
    north: WallType,
    south: WallType,
    up: bool,
    waterlogged: bool,
    west: WallType,
}
impl BrickWallState {
    pub fn with_east(&mut self, east: WallType) -> &mut Self {
        self.east = east;
        self
    }
    pub fn east(&self) -> WallType {
        self.east
    }
    pub fn with_north(&mut self, north: WallType) -> &mut Self {
        self.north = north;
        self
    }
    pub fn north(&self) -> WallType {
        self.north
    }
    pub fn with_south(&mut self, south: WallType) -> &mut Self {
        self.south = south;
        self
    }
    pub fn south(&self) -> WallType {
        self.south
    }
    pub fn with_up(&mut self, up: bool) -> &mut Self {
        self.up = up;
        self
    }
    pub fn up(&self) -> bool {
        self.up
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
    pub fn with_west(&mut self, west: WallType) -> &mut Self {
        self.west = west;
        self
    }
    pub fn west(&self) -> WallType {
        self.west
    }
}
impl Default for BrickWallState {
    fn default() -> Self {
        BrickWallState {
            east: WallType::None,
            north: WallType::None,
            south: WallType::None,
            up: true,
            waterlogged: false,
            west: WallType::None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct PrismarineWallState {
    east: WallType,
    north: WallType,
    south: WallType,
    up: bool,
    waterlogged: bool,
    west: WallType,
}
impl PrismarineWallState {
    pub fn with_east(&mut self, east: WallType) -> &mut Self {
        self.east = east;
        self
    }
    pub fn east(&self) -> WallType {
        self.east
    }
    pub fn with_north(&mut self, north: WallType) -> &mut Self {
        self.north = north;
        self
    }
    pub fn north(&self) -> WallType {
        self.north
    }
    pub fn with_south(&mut self, south: WallType) -> &mut Self {
        self.south = south;
        self
    }
    pub fn south(&self) -> WallType {
        self.south
    }
    pub fn with_up(&mut self, up: bool) -> &mut Self {
        self.up = up;
        self
    }
    pub fn up(&self) -> bool {
        self.up
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
    pub fn with_west(&mut self, west: WallType) -> &mut Self {
        self.west = west;
        self
    }
    pub fn west(&self) -> WallType {
        self.west
    }
}
impl Default for PrismarineWallState {
    fn default() -> Self {
        PrismarineWallState {
            east: WallType::None,
            north: WallType::None,
            south: WallType::None,
            up: true,
            waterlogged: false,
            west: WallType::None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct RedSandstoneWallState {
    east: WallType,
    north: WallType,
    south: WallType,
    up: bool,
    waterlogged: bool,
    west: WallType,
}
impl RedSandstoneWallState {
    pub fn with_east(&mut self, east: WallType) -> &mut Self {
        self.east = east;
        self
    }
    pub fn east(&self) -> WallType {
        self.east
    }
    pub fn with_north(&mut self, north: WallType) -> &mut Self {
        self.north = north;
        self
    }
    pub fn north(&self) -> WallType {
        self.north
    }
    pub fn with_south(&mut self, south: WallType) -> &mut Self {
        self.south = south;
        self
    }
    pub fn south(&self) -> WallType {
        self.south
    }
    pub fn with_up(&mut self, up: bool) -> &mut Self {
        self.up = up;
        self
    }
    pub fn up(&self) -> bool {
        self.up
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
    pub fn with_west(&mut self, west: WallType) -> &mut Self {
        self.west = west;
        self
    }
    pub fn west(&self) -> WallType {
        self.west
    }
}
impl Default for RedSandstoneWallState {
    fn default() -> Self {
        RedSandstoneWallState {
            east: WallType::None,
            north: WallType::None,
            south: WallType::None,
            up: true,
            waterlogged: false,
            west: WallType::None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct MossyStoneBrickWallState {
    east: WallType,
    north: WallType,
    south: WallType,
    up: bool,
    waterlogged: bool,
    west: WallType,
}
impl MossyStoneBrickWallState {
    pub fn with_east(&mut self, east: WallType) -> &mut Self {
        self.east = east;
        self
    }
    pub fn east(&self) -> WallType {
        self.east
    }
    pub fn with_north(&mut self, north: WallType) -> &mut Self {
        self.north = north;
        self
    }
    pub fn north(&self) -> WallType {
        self.north
    }
    pub fn with_south(&mut self, south: WallType) -> &mut Self {
        self.south = south;
        self
    }
    pub fn south(&self) -> WallType {
        self.south
    }
    pub fn with_up(&mut self, up: bool) -> &mut Self {
        self.up = up;
        self
    }
    pub fn up(&self) -> bool {
        self.up
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
    pub fn with_west(&mut self, west: WallType) -> &mut Self {
        self.west = west;
        self
    }
    pub fn west(&self) -> WallType {
        self.west
    }
}
impl Default for MossyStoneBrickWallState {
    fn default() -> Self {
        MossyStoneBrickWallState {
            east: WallType::None,
            north: WallType::None,
            south: WallType::None,
            up: true,
            waterlogged: false,
            west: WallType::None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct GraniteWallState {
    east: WallType,
    north: WallType,
    south: WallType,
    up: bool,
    waterlogged: bool,
    west: WallType,
}
impl GraniteWallState {
    pub fn with_east(&mut self, east: WallType) -> &mut Self {
        self.east = east;
        self
    }
    pub fn east(&self) -> WallType {
        self.east
    }
    pub fn with_north(&mut self, north: WallType) -> &mut Self {
        self.north = north;
        self
    }
    pub fn north(&self) -> WallType {
        self.north
    }
    pub fn with_south(&mut self, south: WallType) -> &mut Self {
        self.south = south;
        self
    }
    pub fn south(&self) -> WallType {
        self.south
    }
    pub fn with_up(&mut self, up: bool) -> &mut Self {
        self.up = up;
        self
    }
    pub fn up(&self) -> bool {
        self.up
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
    pub fn with_west(&mut self, west: WallType) -> &mut Self {
        self.west = west;
        self
    }
    pub fn west(&self) -> WallType {
        self.west
    }
}
impl Default for GraniteWallState {
    fn default() -> Self {
        GraniteWallState {
            east: WallType::None,
            north: WallType::None,
            south: WallType::None,
            up: true,
            waterlogged: false,
            west: WallType::None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct StoneBrickWallState {
    east: WallType,
    north: WallType,
    south: WallType,
    up: bool,
    waterlogged: bool,
    west: WallType,
}
impl StoneBrickWallState {
    pub fn with_east(&mut self, east: WallType) -> &mut Self {
        self.east = east;
        self
    }
    pub fn east(&self) -> WallType {
        self.east
    }
    pub fn with_north(&mut self, north: WallType) -> &mut Self {
        self.north = north;
        self
    }
    pub fn north(&self) -> WallType {
        self.north
    }
    pub fn with_south(&mut self, south: WallType) -> &mut Self {
        self.south = south;
        self
    }
    pub fn south(&self) -> WallType {
        self.south
    }
    pub fn with_up(&mut self, up: bool) -> &mut Self {
        self.up = up;
        self
    }
    pub fn up(&self) -> bool {
        self.up
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
    pub fn with_west(&mut self, west: WallType) -> &mut Self {
        self.west = west;
        self
    }
    pub fn west(&self) -> WallType {
        self.west
    }
}
impl Default for StoneBrickWallState {
    fn default() -> Self {
        StoneBrickWallState {
            east: WallType::None,
            north: WallType::None,
            south: WallType::None,
            up: true,
            waterlogged: false,
            west: WallType::None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct NetherBrickWallState {
    east: WallType,
    north: WallType,
    south: WallType,
    up: bool,
    waterlogged: bool,
    west: WallType,
}
impl NetherBrickWallState {
    pub fn with_east(&mut self, east: WallType) -> &mut Self {
        self.east = east;
        self
    }
    pub fn east(&self) -> WallType {
        self.east
    }
    pub fn with_north(&mut self, north: WallType) -> &mut Self {
        self.north = north;
        self
    }
    pub fn north(&self) -> WallType {
        self.north
    }
    pub fn with_south(&mut self, south: WallType) -> &mut Self {
        self.south = south;
        self
    }
    pub fn south(&self) -> WallType {
        self.south
    }
    pub fn with_up(&mut self, up: bool) -> &mut Self {
        self.up = up;
        self
    }
    pub fn up(&self) -> bool {
        self.up
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
    pub fn with_west(&mut self, west: WallType) -> &mut Self {
        self.west = west;
        self
    }
    pub fn west(&self) -> WallType {
        self.west
    }
}
impl Default for NetherBrickWallState {
    fn default() -> Self {
        NetherBrickWallState {
            east: WallType::None,
            north: WallType::None,
            south: WallType::None,
            up: true,
            waterlogged: false,
            west: WallType::None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct AndesiteWallState {
    east: WallType,
    north: WallType,
    south: WallType,
    up: bool,
    waterlogged: bool,
    west: WallType,
}
impl AndesiteWallState {
    pub fn with_east(&mut self, east: WallType) -> &mut Self {
        self.east = east;
        self
    }
    pub fn east(&self) -> WallType {
        self.east
    }
    pub fn with_north(&mut self, north: WallType) -> &mut Self {
        self.north = north;
        self
    }
    pub fn north(&self) -> WallType {
        self.north
    }
    pub fn with_south(&mut self, south: WallType) -> &mut Self {
        self.south = south;
        self
    }
    pub fn south(&self) -> WallType {
        self.south
    }
    pub fn with_up(&mut self, up: bool) -> &mut Self {
        self.up = up;
        self
    }
    pub fn up(&self) -> bool {
        self.up
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
    pub fn with_west(&mut self, west: WallType) -> &mut Self {
        self.west = west;
        self
    }
    pub fn west(&self) -> WallType {
        self.west
    }
}
impl Default for AndesiteWallState {
    fn default() -> Self {
        AndesiteWallState {
            east: WallType::None,
            north: WallType::None,
            south: WallType::None,
            up: true,
            waterlogged: false,
            west: WallType::None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct RedNetherBrickWallState {
    east: WallType,
    north: WallType,
    south: WallType,
    up: bool,
    waterlogged: bool,
    west: WallType,
}
impl RedNetherBrickWallState {
    pub fn with_east(&mut self, east: WallType) -> &mut Self {
        self.east = east;
        self
    }
    pub fn east(&self) -> WallType {
        self.east
    }
    pub fn with_north(&mut self, north: WallType) -> &mut Self {
        self.north = north;
        self
    }
    pub fn north(&self) -> WallType {
        self.north
    }
    pub fn with_south(&mut self, south: WallType) -> &mut Self {
        self.south = south;
        self
    }
    pub fn south(&self) -> WallType {
        self.south
    }
    pub fn with_up(&mut self, up: bool) -> &mut Self {
        self.up = up;
        self
    }
    pub fn up(&self) -> bool {
        self.up
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
    pub fn with_west(&mut self, west: WallType) -> &mut Self {
        self.west = west;
        self
    }
    pub fn west(&self) -> WallType {
        self.west
    }
}
impl Default for RedNetherBrickWallState {
    fn default() -> Self {
        RedNetherBrickWallState {
            east: WallType::None,
            north: WallType::None,
            south: WallType::None,
            up: true,
            waterlogged: false,
            west: WallType::None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct SandstoneWallState {
    east: WallType,
    north: WallType,
    south: WallType,
    up: bool,
    waterlogged: bool,
    west: WallType,
}
impl SandstoneWallState {
    pub fn with_east(&mut self, east: WallType) -> &mut Self {
        self.east = east;
        self
    }
    pub fn east(&self) -> WallType {
        self.east
    }
    pub fn with_north(&mut self, north: WallType) -> &mut Self {
        self.north = north;
        self
    }
    pub fn north(&self) -> WallType {
        self.north
    }
    pub fn with_south(&mut self, south: WallType) -> &mut Self {
        self.south = south;
        self
    }
    pub fn south(&self) -> WallType {
        self.south
    }
    pub fn with_up(&mut self, up: bool) -> &mut Self {
        self.up = up;
        self
    }
    pub fn up(&self) -> bool {
        self.up
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
    pub fn with_west(&mut self, west: WallType) -> &mut Self {
        self.west = west;
        self
    }
    pub fn west(&self) -> WallType {
        self.west
    }
}
impl Default for SandstoneWallState {
    fn default() -> Self {
        SandstoneWallState {
            east: WallType::None,
            north: WallType::None,
            south: WallType::None,
            up: true,
            waterlogged: false,
            west: WallType::None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct EndStoneBrickWallState {
    east: WallType,
    north: WallType,
    south: WallType,
    up: bool,
    waterlogged: bool,
    west: WallType,
}
impl EndStoneBrickWallState {
    pub fn with_east(&mut self, east: WallType) -> &mut Self {
        self.east = east;
        self
    }
    pub fn east(&self) -> WallType {
        self.east
    }
    pub fn with_north(&mut self, north: WallType) -> &mut Self {
        self.north = north;
        self
    }
    pub fn north(&self) -> WallType {
        self.north
    }
    pub fn with_south(&mut self, south: WallType) -> &mut Self {
        self.south = south;
        self
    }
    pub fn south(&self) -> WallType {
        self.south
    }
    pub fn with_up(&mut self, up: bool) -> &mut Self {
        self.up = up;
        self
    }
    pub fn up(&self) -> bool {
        self.up
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
    pub fn with_west(&mut self, west: WallType) -> &mut Self {
        self.west = west;
        self
    }
    pub fn west(&self) -> WallType {
        self.west
    }
}
impl Default for EndStoneBrickWallState {
    fn default() -> Self {
        EndStoneBrickWallState {
            east: WallType::None,
            north: WallType::None,
            south: WallType::None,
            up: true,
            waterlogged: false,
            west: WallType::None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct DioriteWallState {
    east: WallType,
    north: WallType,
    south: WallType,
    up: bool,
    waterlogged: bool,
    west: WallType,
}
impl DioriteWallState {
    pub fn with_east(&mut self, east: WallType) -> &mut Self {
        self.east = east;
        self
    }
    pub fn east(&self) -> WallType {
        self.east
    }
    pub fn with_north(&mut self, north: WallType) -> &mut Self {
        self.north = north;
        self
    }
    pub fn north(&self) -> WallType {
        self.north
    }
    pub fn with_south(&mut self, south: WallType) -> &mut Self {
        self.south = south;
        self
    }
    pub fn south(&self) -> WallType {
        self.south
    }
    pub fn with_up(&mut self, up: bool) -> &mut Self {
        self.up = up;
        self
    }
    pub fn up(&self) -> bool {
        self.up
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
    pub fn with_west(&mut self, west: WallType) -> &mut Self {
        self.west = west;
        self
    }
    pub fn west(&self) -> WallType {
        self.west
    }
}
impl Default for DioriteWallState {
    fn default() -> Self {
        DioriteWallState {
            east: WallType::None,
            north: WallType::None,
            south: WallType::None,
            up: true,
            waterlogged: false,
            west: WallType::None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct ScaffoldingState {
    bottom: bool,
    distance: i32,
    waterlogged: bool,
}
impl ScaffoldingState {
    pub fn with_bottom(&mut self, bottom: bool) -> &mut Self {
        self.bottom = bottom;
        self
    }
    pub fn bottom(&self) -> bool {
        self.bottom
    }
    /// This is a value between 0 and 7 (both ends inclusive).\Developers should be careful to respect these bounds as no checking is done at runtime!!!
    pub fn with_distance(&mut self, distance: i32) -> &mut Self {
        self.distance = distance;
        self
    }
    pub fn distance(&self) -> i32 {
        self.distance
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for ScaffoldingState {
    fn default() -> Self {
        ScaffoldingState {
            bottom: false,
            distance: 7,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct LoomState {
    facing: HorizontalFacing,
}
impl LoomState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
}
impl Default for LoomState {
    fn default() -> Self {
        LoomState {
            facing: HorizontalFacing::North,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct BarrelState {
    facing: AllFacing,
    open: bool,
}
impl BarrelState {
    pub fn with_facing(&mut self, facing: AllFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> AllFacing {
        self.facing
    }
    pub fn with_open(&mut self, open: bool) -> &mut Self {
        self.open = open;
        self
    }
    pub fn open(&self) -> bool {
        self.open
    }
}
impl Default for BarrelState {
    fn default() -> Self {
        BarrelState {
            facing: AllFacing::North,
            open: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct SmokerState {
    facing: HorizontalFacing,
    lit: bool,
}
impl SmokerState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_lit(&mut self, lit: bool) -> &mut Self {
        self.lit = lit;
        self
    }
    pub fn lit(&self) -> bool {
        self.lit
    }
}
impl Default for SmokerState {
    fn default() -> Self {
        SmokerState {
            facing: HorizontalFacing::North,
            lit: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct BlastFurnaceState {
    facing: HorizontalFacing,
    lit: bool,
}
impl BlastFurnaceState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_lit(&mut self, lit: bool) -> &mut Self {
        self.lit = lit;
        self
    }
    pub fn lit(&self) -> bool {
        self.lit
    }
}
impl Default for BlastFurnaceState {
    fn default() -> Self {
        BlastFurnaceState {
            facing: HorizontalFacing::North,
            lit: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct GrindstoneState {
    face: Face,
    facing: HorizontalFacing,
}
impl GrindstoneState {
    pub fn with_face(&mut self, face: Face) -> &mut Self {
        self.face = face;
        self
    }
    pub fn face(&self) -> Face {
        self.face
    }
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
}
impl Default for GrindstoneState {
    fn default() -> Self {
        GrindstoneState {
            face: Face::Wall,
            facing: HorizontalFacing::North,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct LecternState {
    facing: HorizontalFacing,
    has_book: bool,
    powered: bool,
}
impl LecternState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_has_book(&mut self, has_book: bool) -> &mut Self {
        self.has_book = has_book;
        self
    }
    pub fn has_book(&self) -> bool {
        self.has_book
    }
    pub fn with_powered(&mut self, powered: bool) -> &mut Self {
        self.powered = powered;
        self
    }
    pub fn powered(&self) -> bool {
        self.powered
    }
}
impl Default for LecternState {
    fn default() -> Self {
        LecternState {
            facing: HorizontalFacing::North,
            has_book: false,
            powered: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct StonecutterState {
    facing: HorizontalFacing,
}
impl StonecutterState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
}
impl Default for StonecutterState {
    fn default() -> Self {
        StonecutterState {
            facing: HorizontalFacing::North,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct BellState {
    attachment: Attachment,
    facing: HorizontalFacing,
    powered: bool,
}
impl BellState {
    pub fn with_attachment(&mut self, attachment: Attachment) -> &mut Self {
        self.attachment = attachment;
        self
    }
    pub fn attachment(&self) -> Attachment {
        self.attachment
    }
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_powered(&mut self, powered: bool) -> &mut Self {
        self.powered = powered;
        self
    }
    pub fn powered(&self) -> bool {
        self.powered
    }
}
impl Default for BellState {
    fn default() -> Self {
        BellState {
            attachment: Attachment::Floor,
            facing: HorizontalFacing::North,
            powered: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct LanternState {
    hanging: bool,
    waterlogged: bool,
}
impl LanternState {
    pub fn with_hanging(&mut self, hanging: bool) -> &mut Self {
        self.hanging = hanging;
        self
    }
    pub fn hanging(&self) -> bool {
        self.hanging
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for LanternState {
    fn default() -> Self {
        LanternState {
            hanging: false,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct SoulLanternState {
    hanging: bool,
    waterlogged: bool,
}
impl SoulLanternState {
    pub fn with_hanging(&mut self, hanging: bool) -> &mut Self {
        self.hanging = hanging;
        self
    }
    pub fn hanging(&self) -> bool {
        self.hanging
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for SoulLanternState {
    fn default() -> Self {
        SoulLanternState {
            hanging: false,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct CampfireState {
    facing: HorizontalFacing,
    lit: bool,
    signal_fire: bool,
    waterlogged: bool,
}
impl CampfireState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_lit(&mut self, lit: bool) -> &mut Self {
        self.lit = lit;
        self
    }
    pub fn lit(&self) -> bool {
        self.lit
    }
    pub fn with_signal_fire(&mut self, signal_fire: bool) -> &mut Self {
        self.signal_fire = signal_fire;
        self
    }
    pub fn signal_fire(&self) -> bool {
        self.signal_fire
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for CampfireState {
    fn default() -> Self {
        CampfireState {
            facing: HorizontalFacing::North,
            lit: true,
            signal_fire: false,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct SoulCampfireState {
    facing: HorizontalFacing,
    lit: bool,
    signal_fire: bool,
    waterlogged: bool,
}
impl SoulCampfireState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_lit(&mut self, lit: bool) -> &mut Self {
        self.lit = lit;
        self
    }
    pub fn lit(&self) -> bool {
        self.lit
    }
    pub fn with_signal_fire(&mut self, signal_fire: bool) -> &mut Self {
        self.signal_fire = signal_fire;
        self
    }
    pub fn signal_fire(&self) -> bool {
        self.signal_fire
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for SoulCampfireState {
    fn default() -> Self {
        SoulCampfireState {
            facing: HorizontalFacing::North,
            lit: true,
            signal_fire: false,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct SweetBerryBushState {
    age: i32,
}
impl SweetBerryBushState {
    /// This is a value between 0 and 3 (both ends inclusive).\Developers should be careful to respect these bounds as no checking is done at runtime!!!
    pub fn with_age(&mut self, age: i32) -> &mut Self {
        self.age = age;
        self
    }
    pub fn age(&self) -> i32 {
        self.age
    }
}
impl Default for SweetBerryBushState {
    fn default() -> Self {
        SweetBerryBushState {
            age: 0,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct WarpedStemState {
    axis: Axis,
}
impl WarpedStemState {
    pub fn with_axis(&mut self, axis: Axis) -> &mut Self {
        self.axis = axis;
        self
    }
    pub fn axis(&self) -> Axis {
        self.axis
    }
}
impl Default for WarpedStemState {
    fn default() -> Self {
        WarpedStemState {
            axis: Axis::Y,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct StrippedWarpedStemState {
    axis: Axis,
}
impl StrippedWarpedStemState {
    pub fn with_axis(&mut self, axis: Axis) -> &mut Self {
        self.axis = axis;
        self
    }
    pub fn axis(&self) -> Axis {
        self.axis
    }
}
impl Default for StrippedWarpedStemState {
    fn default() -> Self {
        StrippedWarpedStemState {
            axis: Axis::Y,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct WarpedHyphaeState {
    axis: Axis,
}
impl WarpedHyphaeState {
    pub fn with_axis(&mut self, axis: Axis) -> &mut Self {
        self.axis = axis;
        self
    }
    pub fn axis(&self) -> Axis {
        self.axis
    }
}
impl Default for WarpedHyphaeState {
    fn default() -> Self {
        WarpedHyphaeState {
            axis: Axis::Y,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct StrippedWarpedHyphaeState {
    axis: Axis,
}
impl StrippedWarpedHyphaeState {
    pub fn with_axis(&mut self, axis: Axis) -> &mut Self {
        self.axis = axis;
        self
    }
    pub fn axis(&self) -> Axis {
        self.axis
    }
}
impl Default for StrippedWarpedHyphaeState {
    fn default() -> Self {
        StrippedWarpedHyphaeState {
            axis: Axis::Y,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct CrimsonStemState {
    axis: Axis,
}
impl CrimsonStemState {
    pub fn with_axis(&mut self, axis: Axis) -> &mut Self {
        self.axis = axis;
        self
    }
    pub fn axis(&self) -> Axis {
        self.axis
    }
}
impl Default for CrimsonStemState {
    fn default() -> Self {
        CrimsonStemState {
            axis: Axis::Y,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct StrippedCrimsonStemState {
    axis: Axis,
}
impl StrippedCrimsonStemState {
    pub fn with_axis(&mut self, axis: Axis) -> &mut Self {
        self.axis = axis;
        self
    }
    pub fn axis(&self) -> Axis {
        self.axis
    }
}
impl Default for StrippedCrimsonStemState {
    fn default() -> Self {
        StrippedCrimsonStemState {
            axis: Axis::Y,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct CrimsonHyphaeState {
    axis: Axis,
}
impl CrimsonHyphaeState {
    pub fn with_axis(&mut self, axis: Axis) -> &mut Self {
        self.axis = axis;
        self
    }
    pub fn axis(&self) -> Axis {
        self.axis
    }
}
impl Default for CrimsonHyphaeState {
    fn default() -> Self {
        CrimsonHyphaeState {
            axis: Axis::Y,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct StrippedCrimsonHyphaeState {
    axis: Axis,
}
impl StrippedCrimsonHyphaeState {
    pub fn with_axis(&mut self, axis: Axis) -> &mut Self {
        self.axis = axis;
        self
    }
    pub fn axis(&self) -> Axis {
        self.axis
    }
}
impl Default for StrippedCrimsonHyphaeState {
    fn default() -> Self {
        StrippedCrimsonHyphaeState {
            axis: Axis::Y,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct WeepingVinesState {
    age: i32,
}
impl WeepingVinesState {
    /// This is a value between 0 and 25 (both ends inclusive).\Developers should be careful to respect these bounds as no checking is done at runtime!!!
    pub fn with_age(&mut self, age: i32) -> &mut Self {
        self.age = age;
        self
    }
    pub fn age(&self) -> i32 {
        self.age
    }
}
impl Default for WeepingVinesState {
    fn default() -> Self {
        WeepingVinesState {
            age: 0,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct TwistingVinesState {
    age: i32,
}
impl TwistingVinesState {
    /// This is a value between 0 and 25 (both ends inclusive).\Developers should be careful to respect these bounds as no checking is done at runtime!!!
    pub fn with_age(&mut self, age: i32) -> &mut Self {
        self.age = age;
        self
    }
    pub fn age(&self) -> i32 {
        self.age
    }
}
impl Default for TwistingVinesState {
    fn default() -> Self {
        TwistingVinesState {
            age: 0,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct CrimsonSlabState {
    typed: SlabType,
    waterlogged: bool,
}
impl CrimsonSlabState {
    pub fn with_typed(&mut self, typed: SlabType) -> &mut Self {
        self.typed = typed;
        self
    }
    pub fn typed(&self) -> SlabType {
        self.typed
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for CrimsonSlabState {
    fn default() -> Self {
        CrimsonSlabState {
            typed: SlabType::Bottom,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct WarpedSlabState {
    typed: SlabType,
    waterlogged: bool,
}
impl WarpedSlabState {
    pub fn with_typed(&mut self, typed: SlabType) -> &mut Self {
        self.typed = typed;
        self
    }
    pub fn typed(&self) -> SlabType {
        self.typed
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for WarpedSlabState {
    fn default() -> Self {
        WarpedSlabState {
            typed: SlabType::Bottom,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct CrimsonPressurePlateState {
    powered: bool,
}
impl CrimsonPressurePlateState {
    pub fn with_powered(&mut self, powered: bool) -> &mut Self {
        self.powered = powered;
        self
    }
    pub fn powered(&self) -> bool {
        self.powered
    }
}
impl Default for CrimsonPressurePlateState {
    fn default() -> Self {
        CrimsonPressurePlateState {
            powered: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct WarpedPressurePlateState {
    powered: bool,
}
impl WarpedPressurePlateState {
    pub fn with_powered(&mut self, powered: bool) -> &mut Self {
        self.powered = powered;
        self
    }
    pub fn powered(&self) -> bool {
        self.powered
    }
}
impl Default for WarpedPressurePlateState {
    fn default() -> Self {
        WarpedPressurePlateState {
            powered: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct CrimsonFenceState {
    east: bool,
    north: bool,
    south: bool,
    waterlogged: bool,
    west: bool,
}
impl CrimsonFenceState {
    pub fn with_east(&mut self, east: bool) -> &mut Self {
        self.east = east;
        self
    }
    pub fn east(&self) -> bool {
        self.east
    }
    pub fn with_north(&mut self, north: bool) -> &mut Self {
        self.north = north;
        self
    }
    pub fn north(&self) -> bool {
        self.north
    }
    pub fn with_south(&mut self, south: bool) -> &mut Self {
        self.south = south;
        self
    }
    pub fn south(&self) -> bool {
        self.south
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
    pub fn with_west(&mut self, west: bool) -> &mut Self {
        self.west = west;
        self
    }
    pub fn west(&self) -> bool {
        self.west
    }
}
impl Default for CrimsonFenceState {
    fn default() -> Self {
        CrimsonFenceState {
            east: false,
            north: false,
            south: false,
            waterlogged: false,
            west: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct WarpedFenceState {
    east: bool,
    north: bool,
    south: bool,
    waterlogged: bool,
    west: bool,
}
impl WarpedFenceState {
    pub fn with_east(&mut self, east: bool) -> &mut Self {
        self.east = east;
        self
    }
    pub fn east(&self) -> bool {
        self.east
    }
    pub fn with_north(&mut self, north: bool) -> &mut Self {
        self.north = north;
        self
    }
    pub fn north(&self) -> bool {
        self.north
    }
    pub fn with_south(&mut self, south: bool) -> &mut Self {
        self.south = south;
        self
    }
    pub fn south(&self) -> bool {
        self.south
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
    pub fn with_west(&mut self, west: bool) -> &mut Self {
        self.west = west;
        self
    }
    pub fn west(&self) -> bool {
        self.west
    }
}
impl Default for WarpedFenceState {
    fn default() -> Self {
        WarpedFenceState {
            east: false,
            north: false,
            south: false,
            waterlogged: false,
            west: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct CrimsonTrapdoorState {
    facing: HorizontalFacing,
    half: SingleBlockHalf,
    open: bool,
    powered: bool,
    waterlogged: bool,
}
impl CrimsonTrapdoorState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_half(&mut self, half: SingleBlockHalf) -> &mut Self {
        self.half = half;
        self
    }
    pub fn half(&self) -> SingleBlockHalf {
        self.half
    }
    pub fn with_open(&mut self, open: bool) -> &mut Self {
        self.open = open;
        self
    }
    pub fn open(&self) -> bool {
        self.open
    }
    pub fn with_powered(&mut self, powered: bool) -> &mut Self {
        self.powered = powered;
        self
    }
    pub fn powered(&self) -> bool {
        self.powered
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for CrimsonTrapdoorState {
    fn default() -> Self {
        CrimsonTrapdoorState {
            facing: HorizontalFacing::North,
            half: SingleBlockHalf::Bottom,
            open: false,
            powered: false,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct WarpedTrapdoorState {
    facing: HorizontalFacing,
    half: SingleBlockHalf,
    open: bool,
    powered: bool,
    waterlogged: bool,
}
impl WarpedTrapdoorState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_half(&mut self, half: SingleBlockHalf) -> &mut Self {
        self.half = half;
        self
    }
    pub fn half(&self) -> SingleBlockHalf {
        self.half
    }
    pub fn with_open(&mut self, open: bool) -> &mut Self {
        self.open = open;
        self
    }
    pub fn open(&self) -> bool {
        self.open
    }
    pub fn with_powered(&mut self, powered: bool) -> &mut Self {
        self.powered = powered;
        self
    }
    pub fn powered(&self) -> bool {
        self.powered
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for WarpedTrapdoorState {
    fn default() -> Self {
        WarpedTrapdoorState {
            facing: HorizontalFacing::North,
            half: SingleBlockHalf::Bottom,
            open: false,
            powered: false,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct CrimsonFenceGateState {
    facing: HorizontalFacing,
    in_wall: bool,
    open: bool,
    powered: bool,
}
impl CrimsonFenceGateState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_in_wall(&mut self, in_wall: bool) -> &mut Self {
        self.in_wall = in_wall;
        self
    }
    pub fn in_wall(&self) -> bool {
        self.in_wall
    }
    pub fn with_open(&mut self, open: bool) -> &mut Self {
        self.open = open;
        self
    }
    pub fn open(&self) -> bool {
        self.open
    }
    pub fn with_powered(&mut self, powered: bool) -> &mut Self {
        self.powered = powered;
        self
    }
    pub fn powered(&self) -> bool {
        self.powered
    }
}
impl Default for CrimsonFenceGateState {
    fn default() -> Self {
        CrimsonFenceGateState {
            facing: HorizontalFacing::North,
            in_wall: false,
            open: false,
            powered: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct WarpedFenceGateState {
    facing: HorizontalFacing,
    in_wall: bool,
    open: bool,
    powered: bool,
}
impl WarpedFenceGateState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_in_wall(&mut self, in_wall: bool) -> &mut Self {
        self.in_wall = in_wall;
        self
    }
    pub fn in_wall(&self) -> bool {
        self.in_wall
    }
    pub fn with_open(&mut self, open: bool) -> &mut Self {
        self.open = open;
        self
    }
    pub fn open(&self) -> bool {
        self.open
    }
    pub fn with_powered(&mut self, powered: bool) -> &mut Self {
        self.powered = powered;
        self
    }
    pub fn powered(&self) -> bool {
        self.powered
    }
}
impl Default for WarpedFenceGateState {
    fn default() -> Self {
        WarpedFenceGateState {
            facing: HorizontalFacing::North,
            in_wall: false,
            open: false,
            powered: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct CrimsonStairsState {
    facing: HorizontalFacing,
    half: SingleBlockHalf,
    shape: StairShape,
    waterlogged: bool,
}
impl CrimsonStairsState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_half(&mut self, half: SingleBlockHalf) -> &mut Self {
        self.half = half;
        self
    }
    pub fn half(&self) -> SingleBlockHalf {
        self.half
    }
    pub fn with_shape(&mut self, shape: StairShape) -> &mut Self {
        self.shape = shape;
        self
    }
    pub fn shape(&self) -> StairShape {
        self.shape
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for CrimsonStairsState {
    fn default() -> Self {
        CrimsonStairsState {
            facing: HorizontalFacing::North,
            half: SingleBlockHalf::Bottom,
            shape: StairShape::Straight,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct WarpedStairsState {
    facing: HorizontalFacing,
    half: SingleBlockHalf,
    shape: StairShape,
    waterlogged: bool,
}
impl WarpedStairsState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_half(&mut self, half: SingleBlockHalf) -> &mut Self {
        self.half = half;
        self
    }
    pub fn half(&self) -> SingleBlockHalf {
        self.half
    }
    pub fn with_shape(&mut self, shape: StairShape) -> &mut Self {
        self.shape = shape;
        self
    }
    pub fn shape(&self) -> StairShape {
        self.shape
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for WarpedStairsState {
    fn default() -> Self {
        WarpedStairsState {
            facing: HorizontalFacing::North,
            half: SingleBlockHalf::Bottom,
            shape: StairShape::Straight,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct CrimsonButtonState {
    face: Face,
    facing: HorizontalFacing,
    powered: bool,
}
impl CrimsonButtonState {
    pub fn with_face(&mut self, face: Face) -> &mut Self {
        self.face = face;
        self
    }
    pub fn face(&self) -> Face {
        self.face
    }
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_powered(&mut self, powered: bool) -> &mut Self {
        self.powered = powered;
        self
    }
    pub fn powered(&self) -> bool {
        self.powered
    }
}
impl Default for CrimsonButtonState {
    fn default() -> Self {
        CrimsonButtonState {
            face: Face::Wall,
            facing: HorizontalFacing::North,
            powered: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct WarpedButtonState {
    face: Face,
    facing: HorizontalFacing,
    powered: bool,
}
impl WarpedButtonState {
    pub fn with_face(&mut self, face: Face) -> &mut Self {
        self.face = face;
        self
    }
    pub fn face(&self) -> Face {
        self.face
    }
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_powered(&mut self, powered: bool) -> &mut Self {
        self.powered = powered;
        self
    }
    pub fn powered(&self) -> bool {
        self.powered
    }
}
impl Default for WarpedButtonState {
    fn default() -> Self {
        WarpedButtonState {
            face: Face::Wall,
            facing: HorizontalFacing::North,
            powered: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct CrimsonDoorState {
    facing: HorizontalFacing,
    half: DoubleBlockHalf,
    hinge: Hinge,
    open: bool,
    powered: bool,
}
impl CrimsonDoorState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_half(&mut self, half: DoubleBlockHalf) -> &mut Self {
        self.half = half;
        self
    }
    pub fn half(&self) -> DoubleBlockHalf {
        self.half
    }
    pub fn with_hinge(&mut self, hinge: Hinge) -> &mut Self {
        self.hinge = hinge;
        self
    }
    pub fn hinge(&self) -> Hinge {
        self.hinge
    }
    pub fn with_open(&mut self, open: bool) -> &mut Self {
        self.open = open;
        self
    }
    pub fn open(&self) -> bool {
        self.open
    }
    pub fn with_powered(&mut self, powered: bool) -> &mut Self {
        self.powered = powered;
        self
    }
    pub fn powered(&self) -> bool {
        self.powered
    }
}
impl Default for CrimsonDoorState {
    fn default() -> Self {
        CrimsonDoorState {
            facing: HorizontalFacing::North,
            half: DoubleBlockHalf::Lower,
            hinge: Hinge::Left,
            open: false,
            powered: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct WarpedDoorState {
    facing: HorizontalFacing,
    half: DoubleBlockHalf,
    hinge: Hinge,
    open: bool,
    powered: bool,
}
impl WarpedDoorState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_half(&mut self, half: DoubleBlockHalf) -> &mut Self {
        self.half = half;
        self
    }
    pub fn half(&self) -> DoubleBlockHalf {
        self.half
    }
    pub fn with_hinge(&mut self, hinge: Hinge) -> &mut Self {
        self.hinge = hinge;
        self
    }
    pub fn hinge(&self) -> Hinge {
        self.hinge
    }
    pub fn with_open(&mut self, open: bool) -> &mut Self {
        self.open = open;
        self
    }
    pub fn open(&self) -> bool {
        self.open
    }
    pub fn with_powered(&mut self, powered: bool) -> &mut Self {
        self.powered = powered;
        self
    }
    pub fn powered(&self) -> bool {
        self.powered
    }
}
impl Default for WarpedDoorState {
    fn default() -> Self {
        WarpedDoorState {
            facing: HorizontalFacing::North,
            half: DoubleBlockHalf::Lower,
            hinge: Hinge::Left,
            open: false,
            powered: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct CrimsonSignState {
    rotation: i32,
    waterlogged: bool,
}
impl CrimsonSignState {
    /// This is a value between 0 and 15 (both ends inclusive).\Developers should be careful to respect these bounds as no checking is done at runtime!!!
    pub fn with_rotation(&mut self, rotation: i32) -> &mut Self {
        self.rotation = rotation;
        self
    }
    pub fn rotation(&self) -> i32 {
        self.rotation
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for CrimsonSignState {
    fn default() -> Self {
        CrimsonSignState {
            rotation: 0,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct WarpedSignState {
    rotation: i32,
    waterlogged: bool,
}
impl WarpedSignState {
    /// This is a value between 0 and 15 (both ends inclusive).\Developers should be careful to respect these bounds as no checking is done at runtime!!!
    pub fn with_rotation(&mut self, rotation: i32) -> &mut Self {
        self.rotation = rotation;
        self
    }
    pub fn rotation(&self) -> i32 {
        self.rotation
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for WarpedSignState {
    fn default() -> Self {
        WarpedSignState {
            rotation: 0,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct CrimsonWallSignState {
    facing: HorizontalFacing,
    waterlogged: bool,
}
impl CrimsonWallSignState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for CrimsonWallSignState {
    fn default() -> Self {
        CrimsonWallSignState {
            facing: HorizontalFacing::North,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct WarpedWallSignState {
    facing: HorizontalFacing,
    waterlogged: bool,
}
impl WarpedWallSignState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for WarpedWallSignState {
    fn default() -> Self {
        WarpedWallSignState {
            facing: HorizontalFacing::North,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct StructureBlockState {
    mode: StructureBlockMode,
}
impl StructureBlockState {
    pub fn with_mode(&mut self, mode: StructureBlockMode) -> &mut Self {
        self.mode = mode;
        self
    }
    pub fn mode(&self) -> StructureBlockMode {
        self.mode
    }
}
impl Default for StructureBlockState {
    fn default() -> Self {
        StructureBlockState {
            mode: StructureBlockMode::Load,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct JigsawState {
    orientation: Orientation,
}
impl JigsawState {
    pub fn with_orientation(&mut self, orientation: Orientation) -> &mut Self {
        self.orientation = orientation;
        self
    }
    pub fn orientation(&self) -> Orientation {
        self.orientation
    }
}
impl Default for JigsawState {
    fn default() -> Self {
        JigsawState {
            orientation: Orientation::NorthUp,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct ComposterState {
    level: i32,
}
impl ComposterState {
    /// This is a value between 0 and 8 (both ends inclusive).\Developers should be careful to respect these bounds as no checking is done at runtime!!!
    pub fn with_level(&mut self, level: i32) -> &mut Self {
        self.level = level;
        self
    }
    pub fn level(&self) -> i32 {
        self.level
    }
}
impl Default for ComposterState {
    fn default() -> Self {
        ComposterState {
            level: 0,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct TargetState {
    power: i32,
}
impl TargetState {
    /// This is a value between 0 and 15 (both ends inclusive).\Developers should be careful to respect these bounds as no checking is done at runtime!!!
    pub fn with_power(&mut self, power: i32) -> &mut Self {
        self.power = power;
        self
    }
    pub fn power(&self) -> i32 {
        self.power
    }
}
impl Default for TargetState {
    fn default() -> Self {
        TargetState {
            power: 0,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct BeeNestState {
    facing: HorizontalFacing,
    honey_level: i32,
}
impl BeeNestState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    /// This is a value between 0 and 5 (both ends inclusive).\Developers should be careful to respect these bounds as no checking is done at runtime!!!
    pub fn with_honey_level(&mut self, honey_level: i32) -> &mut Self {
        self.honey_level = honey_level;
        self
    }
    pub fn honey_level(&self) -> i32 {
        self.honey_level
    }
}
impl Default for BeeNestState {
    fn default() -> Self {
        BeeNestState {
            facing: HorizontalFacing::North,
            honey_level: 0,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct BeehiveState {
    facing: HorizontalFacing,
    honey_level: i32,
}
impl BeehiveState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    /// This is a value between 0 and 5 (both ends inclusive).\Developers should be careful to respect these bounds as no checking is done at runtime!!!
    pub fn with_honey_level(&mut self, honey_level: i32) -> &mut Self {
        self.honey_level = honey_level;
        self
    }
    pub fn honey_level(&self) -> i32 {
        self.honey_level
    }
}
impl Default for BeehiveState {
    fn default() -> Self {
        BeehiveState {
            facing: HorizontalFacing::North,
            honey_level: 0,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct RespawnAnchorState {
    charges: i32,
}
impl RespawnAnchorState {
    /// This is a value between 0 and 4 (both ends inclusive).\Developers should be careful to respect these bounds as no checking is done at runtime!!!
    pub fn with_charges(&mut self, charges: i32) -> &mut Self {
        self.charges = charges;
        self
    }
    pub fn charges(&self) -> i32 {
        self.charges
    }
}
impl Default for RespawnAnchorState {
    fn default() -> Self {
        RespawnAnchorState {
            charges: 0,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct BlackstoneStairsState {
    facing: HorizontalFacing,
    half: SingleBlockHalf,
    shape: StairShape,
    waterlogged: bool,
}
impl BlackstoneStairsState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_half(&mut self, half: SingleBlockHalf) -> &mut Self {
        self.half = half;
        self
    }
    pub fn half(&self) -> SingleBlockHalf {
        self.half
    }
    pub fn with_shape(&mut self, shape: StairShape) -> &mut Self {
        self.shape = shape;
        self
    }
    pub fn shape(&self) -> StairShape {
        self.shape
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for BlackstoneStairsState {
    fn default() -> Self {
        BlackstoneStairsState {
            facing: HorizontalFacing::North,
            half: SingleBlockHalf::Bottom,
            shape: StairShape::Straight,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct BlackstoneWallState {
    east: WallType,
    north: WallType,
    south: WallType,
    up: bool,
    waterlogged: bool,
    west: WallType,
}
impl BlackstoneWallState {
    pub fn with_east(&mut self, east: WallType) -> &mut Self {
        self.east = east;
        self
    }
    pub fn east(&self) -> WallType {
        self.east
    }
    pub fn with_north(&mut self, north: WallType) -> &mut Self {
        self.north = north;
        self
    }
    pub fn north(&self) -> WallType {
        self.north
    }
    pub fn with_south(&mut self, south: WallType) -> &mut Self {
        self.south = south;
        self
    }
    pub fn south(&self) -> WallType {
        self.south
    }
    pub fn with_up(&mut self, up: bool) -> &mut Self {
        self.up = up;
        self
    }
    pub fn up(&self) -> bool {
        self.up
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
    pub fn with_west(&mut self, west: WallType) -> &mut Self {
        self.west = west;
        self
    }
    pub fn west(&self) -> WallType {
        self.west
    }
}
impl Default for BlackstoneWallState {
    fn default() -> Self {
        BlackstoneWallState {
            east: WallType::None,
            north: WallType::None,
            south: WallType::None,
            up: true,
            waterlogged: false,
            west: WallType::None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct BlackstoneSlabState {
    typed: SlabType,
    waterlogged: bool,
}
impl BlackstoneSlabState {
    pub fn with_typed(&mut self, typed: SlabType) -> &mut Self {
        self.typed = typed;
        self
    }
    pub fn typed(&self) -> SlabType {
        self.typed
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for BlackstoneSlabState {
    fn default() -> Self {
        BlackstoneSlabState {
            typed: SlabType::Bottom,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct PolishedBlackstoneBrickSlabState {
    typed: SlabType,
    waterlogged: bool,
}
impl PolishedBlackstoneBrickSlabState {
    pub fn with_typed(&mut self, typed: SlabType) -> &mut Self {
        self.typed = typed;
        self
    }
    pub fn typed(&self) -> SlabType {
        self.typed
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for PolishedBlackstoneBrickSlabState {
    fn default() -> Self {
        PolishedBlackstoneBrickSlabState {
            typed: SlabType::Bottom,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct PolishedBlackstoneBrickStairsState {
    facing: HorizontalFacing,
    half: SingleBlockHalf,
    shape: StairShape,
    waterlogged: bool,
}
impl PolishedBlackstoneBrickStairsState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_half(&mut self, half: SingleBlockHalf) -> &mut Self {
        self.half = half;
        self
    }
    pub fn half(&self) -> SingleBlockHalf {
        self.half
    }
    pub fn with_shape(&mut self, shape: StairShape) -> &mut Self {
        self.shape = shape;
        self
    }
    pub fn shape(&self) -> StairShape {
        self.shape
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for PolishedBlackstoneBrickStairsState {
    fn default() -> Self {
        PolishedBlackstoneBrickStairsState {
            facing: HorizontalFacing::North,
            half: SingleBlockHalf::Bottom,
            shape: StairShape::Straight,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct PolishedBlackstoneBrickWallState {
    east: WallType,
    north: WallType,
    south: WallType,
    up: bool,
    waterlogged: bool,
    west: WallType,
}
impl PolishedBlackstoneBrickWallState {
    pub fn with_east(&mut self, east: WallType) -> &mut Self {
        self.east = east;
        self
    }
    pub fn east(&self) -> WallType {
        self.east
    }
    pub fn with_north(&mut self, north: WallType) -> &mut Self {
        self.north = north;
        self
    }
    pub fn north(&self) -> WallType {
        self.north
    }
    pub fn with_south(&mut self, south: WallType) -> &mut Self {
        self.south = south;
        self
    }
    pub fn south(&self) -> WallType {
        self.south
    }
    pub fn with_up(&mut self, up: bool) -> &mut Self {
        self.up = up;
        self
    }
    pub fn up(&self) -> bool {
        self.up
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
    pub fn with_west(&mut self, west: WallType) -> &mut Self {
        self.west = west;
        self
    }
    pub fn west(&self) -> WallType {
        self.west
    }
}
impl Default for PolishedBlackstoneBrickWallState {
    fn default() -> Self {
        PolishedBlackstoneBrickWallState {
            east: WallType::None,
            north: WallType::None,
            south: WallType::None,
            up: true,
            waterlogged: false,
            west: WallType::None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct PolishedBlackstoneStairsState {
    facing: HorizontalFacing,
    half: SingleBlockHalf,
    shape: StairShape,
    waterlogged: bool,
}
impl PolishedBlackstoneStairsState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_half(&mut self, half: SingleBlockHalf) -> &mut Self {
        self.half = half;
        self
    }
    pub fn half(&self) -> SingleBlockHalf {
        self.half
    }
    pub fn with_shape(&mut self, shape: StairShape) -> &mut Self {
        self.shape = shape;
        self
    }
    pub fn shape(&self) -> StairShape {
        self.shape
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for PolishedBlackstoneStairsState {
    fn default() -> Self {
        PolishedBlackstoneStairsState {
            facing: HorizontalFacing::North,
            half: SingleBlockHalf::Bottom,
            shape: StairShape::Straight,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct PolishedBlackstoneSlabState {
    typed: SlabType,
    waterlogged: bool,
}
impl PolishedBlackstoneSlabState {
    pub fn with_typed(&mut self, typed: SlabType) -> &mut Self {
        self.typed = typed;
        self
    }
    pub fn typed(&self) -> SlabType {
        self.typed
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for PolishedBlackstoneSlabState {
    fn default() -> Self {
        PolishedBlackstoneSlabState {
            typed: SlabType::Bottom,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct PolishedBlackstonePressurePlateState {
    powered: bool,
}
impl PolishedBlackstonePressurePlateState {
    pub fn with_powered(&mut self, powered: bool) -> &mut Self {
        self.powered = powered;
        self
    }
    pub fn powered(&self) -> bool {
        self.powered
    }
}
impl Default for PolishedBlackstonePressurePlateState {
    fn default() -> Self {
        PolishedBlackstonePressurePlateState {
            powered: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct PolishedBlackstoneButtonState {
    face: Face,
    facing: HorizontalFacing,
    powered: bool,
}
impl PolishedBlackstoneButtonState {
    pub fn with_face(&mut self, face: Face) -> &mut Self {
        self.face = face;
        self
    }
    pub fn face(&self) -> Face {
        self.face
    }
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_powered(&mut self, powered: bool) -> &mut Self {
        self.powered = powered;
        self
    }
    pub fn powered(&self) -> bool {
        self.powered
    }
}
impl Default for PolishedBlackstoneButtonState {
    fn default() -> Self {
        PolishedBlackstoneButtonState {
            face: Face::Wall,
            facing: HorizontalFacing::North,
            powered: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct PolishedBlackstoneWallState {
    east: WallType,
    north: WallType,
    south: WallType,
    up: bool,
    waterlogged: bool,
    west: WallType,
}
impl PolishedBlackstoneWallState {
    pub fn with_east(&mut self, east: WallType) -> &mut Self {
        self.east = east;
        self
    }
    pub fn east(&self) -> WallType {
        self.east
    }
    pub fn with_north(&mut self, north: WallType) -> &mut Self {
        self.north = north;
        self
    }
    pub fn north(&self) -> WallType {
        self.north
    }
    pub fn with_south(&mut self, south: WallType) -> &mut Self {
        self.south = south;
        self
    }
    pub fn south(&self) -> WallType {
        self.south
    }
    pub fn with_up(&mut self, up: bool) -> &mut Self {
        self.up = up;
        self
    }
    pub fn up(&self) -> bool {
        self.up
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
    pub fn with_west(&mut self, west: WallType) -> &mut Self {
        self.west = west;
        self
    }
    pub fn west(&self) -> WallType {
        self.west
    }
}
impl Default for PolishedBlackstoneWallState {
    fn default() -> Self {
        PolishedBlackstoneWallState {
            east: WallType::None,
            north: WallType::None,
            south: WallType::None,
            up: true,
            waterlogged: false,
            west: WallType::None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct CandleState {
    candles: i32,
    lit: bool,
    waterlogged: bool,
}
impl CandleState {
    /// This is a value between 1 and 4 (both ends inclusive).\Developers should be careful to respect these bounds as no checking is done at runtime!!!
    pub fn with_candles(&mut self, candles: i32) -> &mut Self {
        self.candles = candles - 1;
        self
    }
    pub fn candles(&self) -> i32 {
        self.candles + 1
    }
    pub fn with_lit(&mut self, lit: bool) -> &mut Self {
        self.lit = lit;
        self
    }
    pub fn lit(&self) -> bool {
        self.lit
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for CandleState {
    fn default() -> Self {
        CandleState {
            candles: 0,
            lit: false,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct WhiteCandleState {
    candles: i32,
    lit: bool,
    waterlogged: bool,
}
impl WhiteCandleState {
    /// This is a value between 1 and 4 (both ends inclusive).\Developers should be careful to respect these bounds as no checking is done at runtime!!!
    pub fn with_candles(&mut self, candles: i32) -> &mut Self {
        self.candles = candles - 1;
        self
    }
    pub fn candles(&self) -> i32 {
        self.candles + 1
    }
    pub fn with_lit(&mut self, lit: bool) -> &mut Self {
        self.lit = lit;
        self
    }
    pub fn lit(&self) -> bool {
        self.lit
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for WhiteCandleState {
    fn default() -> Self {
        WhiteCandleState {
            candles: 0,
            lit: false,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct OrangeCandleState {
    candles: i32,
    lit: bool,
    waterlogged: bool,
}
impl OrangeCandleState {
    /// This is a value between 1 and 4 (both ends inclusive).\Developers should be careful to respect these bounds as no checking is done at runtime!!!
    pub fn with_candles(&mut self, candles: i32) -> &mut Self {
        self.candles = candles - 1;
        self
    }
    pub fn candles(&self) -> i32 {
        self.candles + 1
    }
    pub fn with_lit(&mut self, lit: bool) -> &mut Self {
        self.lit = lit;
        self
    }
    pub fn lit(&self) -> bool {
        self.lit
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for OrangeCandleState {
    fn default() -> Self {
        OrangeCandleState {
            candles: 0,
            lit: false,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct MagentaCandleState {
    candles: i32,
    lit: bool,
    waterlogged: bool,
}
impl MagentaCandleState {
    /// This is a value between 1 and 4 (both ends inclusive).\Developers should be careful to respect these bounds as no checking is done at runtime!!!
    pub fn with_candles(&mut self, candles: i32) -> &mut Self {
        self.candles = candles - 1;
        self
    }
    pub fn candles(&self) -> i32 {
        self.candles + 1
    }
    pub fn with_lit(&mut self, lit: bool) -> &mut Self {
        self.lit = lit;
        self
    }
    pub fn lit(&self) -> bool {
        self.lit
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for MagentaCandleState {
    fn default() -> Self {
        MagentaCandleState {
            candles: 0,
            lit: false,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct LightBlueCandleState {
    candles: i32,
    lit: bool,
    waterlogged: bool,
}
impl LightBlueCandleState {
    /// This is a value between 1 and 4 (both ends inclusive).\Developers should be careful to respect these bounds as no checking is done at runtime!!!
    pub fn with_candles(&mut self, candles: i32) -> &mut Self {
        self.candles = candles - 1;
        self
    }
    pub fn candles(&self) -> i32 {
        self.candles + 1
    }
    pub fn with_lit(&mut self, lit: bool) -> &mut Self {
        self.lit = lit;
        self
    }
    pub fn lit(&self) -> bool {
        self.lit
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for LightBlueCandleState {
    fn default() -> Self {
        LightBlueCandleState {
            candles: 0,
            lit: false,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct YellowCandleState {
    candles: i32,
    lit: bool,
    waterlogged: bool,
}
impl YellowCandleState {
    /// This is a value between 1 and 4 (both ends inclusive).\Developers should be careful to respect these bounds as no checking is done at runtime!!!
    pub fn with_candles(&mut self, candles: i32) -> &mut Self {
        self.candles = candles - 1;
        self
    }
    pub fn candles(&self) -> i32 {
        self.candles + 1
    }
    pub fn with_lit(&mut self, lit: bool) -> &mut Self {
        self.lit = lit;
        self
    }
    pub fn lit(&self) -> bool {
        self.lit
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for YellowCandleState {
    fn default() -> Self {
        YellowCandleState {
            candles: 0,
            lit: false,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct LimeCandleState {
    candles: i32,
    lit: bool,
    waterlogged: bool,
}
impl LimeCandleState {
    /// This is a value between 1 and 4 (both ends inclusive).\Developers should be careful to respect these bounds as no checking is done at runtime!!!
    pub fn with_candles(&mut self, candles: i32) -> &mut Self {
        self.candles = candles - 1;
        self
    }
    pub fn candles(&self) -> i32 {
        self.candles + 1
    }
    pub fn with_lit(&mut self, lit: bool) -> &mut Self {
        self.lit = lit;
        self
    }
    pub fn lit(&self) -> bool {
        self.lit
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for LimeCandleState {
    fn default() -> Self {
        LimeCandleState {
            candles: 0,
            lit: false,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct PinkCandleState {
    candles: i32,
    lit: bool,
    waterlogged: bool,
}
impl PinkCandleState {
    /// This is a value between 1 and 4 (both ends inclusive).\Developers should be careful to respect these bounds as no checking is done at runtime!!!
    pub fn with_candles(&mut self, candles: i32) -> &mut Self {
        self.candles = candles - 1;
        self
    }
    pub fn candles(&self) -> i32 {
        self.candles + 1
    }
    pub fn with_lit(&mut self, lit: bool) -> &mut Self {
        self.lit = lit;
        self
    }
    pub fn lit(&self) -> bool {
        self.lit
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for PinkCandleState {
    fn default() -> Self {
        PinkCandleState {
            candles: 0,
            lit: false,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct GrayCandleState {
    candles: i32,
    lit: bool,
    waterlogged: bool,
}
impl GrayCandleState {
    /// This is a value between 1 and 4 (both ends inclusive).\Developers should be careful to respect these bounds as no checking is done at runtime!!!
    pub fn with_candles(&mut self, candles: i32) -> &mut Self {
        self.candles = candles - 1;
        self
    }
    pub fn candles(&self) -> i32 {
        self.candles + 1
    }
    pub fn with_lit(&mut self, lit: bool) -> &mut Self {
        self.lit = lit;
        self
    }
    pub fn lit(&self) -> bool {
        self.lit
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for GrayCandleState {
    fn default() -> Self {
        GrayCandleState {
            candles: 0,
            lit: false,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct LightGrayCandleState {
    candles: i32,
    lit: bool,
    waterlogged: bool,
}
impl LightGrayCandleState {
    /// This is a value between 1 and 4 (both ends inclusive).\Developers should be careful to respect these bounds as no checking is done at runtime!!!
    pub fn with_candles(&mut self, candles: i32) -> &mut Self {
        self.candles = candles - 1;
        self
    }
    pub fn candles(&self) -> i32 {
        self.candles + 1
    }
    pub fn with_lit(&mut self, lit: bool) -> &mut Self {
        self.lit = lit;
        self
    }
    pub fn lit(&self) -> bool {
        self.lit
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for LightGrayCandleState {
    fn default() -> Self {
        LightGrayCandleState {
            candles: 0,
            lit: false,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct CyanCandleState {
    candles: i32,
    lit: bool,
    waterlogged: bool,
}
impl CyanCandleState {
    /// This is a value between 1 and 4 (both ends inclusive).\Developers should be careful to respect these bounds as no checking is done at runtime!!!
    pub fn with_candles(&mut self, candles: i32) -> &mut Self {
        self.candles = candles - 1;
        self
    }
    pub fn candles(&self) -> i32 {
        self.candles + 1
    }
    pub fn with_lit(&mut self, lit: bool) -> &mut Self {
        self.lit = lit;
        self
    }
    pub fn lit(&self) -> bool {
        self.lit
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for CyanCandleState {
    fn default() -> Self {
        CyanCandleState {
            candles: 0,
            lit: false,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct PurpleCandleState {
    candles: i32,
    lit: bool,
    waterlogged: bool,
}
impl PurpleCandleState {
    /// This is a value between 1 and 4 (both ends inclusive).\Developers should be careful to respect these bounds as no checking is done at runtime!!!
    pub fn with_candles(&mut self, candles: i32) -> &mut Self {
        self.candles = candles - 1;
        self
    }
    pub fn candles(&self) -> i32 {
        self.candles + 1
    }
    pub fn with_lit(&mut self, lit: bool) -> &mut Self {
        self.lit = lit;
        self
    }
    pub fn lit(&self) -> bool {
        self.lit
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for PurpleCandleState {
    fn default() -> Self {
        PurpleCandleState {
            candles: 0,
            lit: false,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct BlueCandleState {
    candles: i32,
    lit: bool,
    waterlogged: bool,
}
impl BlueCandleState {
    /// This is a value between 1 and 4 (both ends inclusive).\Developers should be careful to respect these bounds as no checking is done at runtime!!!
    pub fn with_candles(&mut self, candles: i32) -> &mut Self {
        self.candles = candles - 1;
        self
    }
    pub fn candles(&self) -> i32 {
        self.candles + 1
    }
    pub fn with_lit(&mut self, lit: bool) -> &mut Self {
        self.lit = lit;
        self
    }
    pub fn lit(&self) -> bool {
        self.lit
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for BlueCandleState {
    fn default() -> Self {
        BlueCandleState {
            candles: 0,
            lit: false,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct BrownCandleState {
    candles: i32,
    lit: bool,
    waterlogged: bool,
}
impl BrownCandleState {
    /// This is a value between 1 and 4 (both ends inclusive).\Developers should be careful to respect these bounds as no checking is done at runtime!!!
    pub fn with_candles(&mut self, candles: i32) -> &mut Self {
        self.candles = candles - 1;
        self
    }
    pub fn candles(&self) -> i32 {
        self.candles + 1
    }
    pub fn with_lit(&mut self, lit: bool) -> &mut Self {
        self.lit = lit;
        self
    }
    pub fn lit(&self) -> bool {
        self.lit
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for BrownCandleState {
    fn default() -> Self {
        BrownCandleState {
            candles: 0,
            lit: false,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct GreenCandleState {
    candles: i32,
    lit: bool,
    waterlogged: bool,
}
impl GreenCandleState {
    /// This is a value between 1 and 4 (both ends inclusive).\Developers should be careful to respect these bounds as no checking is done at runtime!!!
    pub fn with_candles(&mut self, candles: i32) -> &mut Self {
        self.candles = candles - 1;
        self
    }
    pub fn candles(&self) -> i32 {
        self.candles + 1
    }
    pub fn with_lit(&mut self, lit: bool) -> &mut Self {
        self.lit = lit;
        self
    }
    pub fn lit(&self) -> bool {
        self.lit
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for GreenCandleState {
    fn default() -> Self {
        GreenCandleState {
            candles: 0,
            lit: false,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct RedCandleState {
    candles: i32,
    lit: bool,
    waterlogged: bool,
}
impl RedCandleState {
    /// This is a value between 1 and 4 (both ends inclusive).\Developers should be careful to respect these bounds as no checking is done at runtime!!!
    pub fn with_candles(&mut self, candles: i32) -> &mut Self {
        self.candles = candles - 1;
        self
    }
    pub fn candles(&self) -> i32 {
        self.candles + 1
    }
    pub fn with_lit(&mut self, lit: bool) -> &mut Self {
        self.lit = lit;
        self
    }
    pub fn lit(&self) -> bool {
        self.lit
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for RedCandleState {
    fn default() -> Self {
        RedCandleState {
            candles: 0,
            lit: false,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct BlackCandleState {
    candles: i32,
    lit: bool,
    waterlogged: bool,
}
impl BlackCandleState {
    /// This is a value between 1 and 4 (both ends inclusive).\Developers should be careful to respect these bounds as no checking is done at runtime!!!
    pub fn with_candles(&mut self, candles: i32) -> &mut Self {
        self.candles = candles - 1;
        self
    }
    pub fn candles(&self) -> i32 {
        self.candles + 1
    }
    pub fn with_lit(&mut self, lit: bool) -> &mut Self {
        self.lit = lit;
        self
    }
    pub fn lit(&self) -> bool {
        self.lit
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for BlackCandleState {
    fn default() -> Self {
        BlackCandleState {
            candles: 0,
            lit: false,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct CandleCakeState {
    lit: bool,
}
impl CandleCakeState {
    pub fn with_lit(&mut self, lit: bool) -> &mut Self {
        self.lit = lit;
        self
    }
    pub fn lit(&self) -> bool {
        self.lit
    }
}
impl Default for CandleCakeState {
    fn default() -> Self {
        CandleCakeState {
            lit: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct WhiteCandleCakeState {
    lit: bool,
}
impl WhiteCandleCakeState {
    pub fn with_lit(&mut self, lit: bool) -> &mut Self {
        self.lit = lit;
        self
    }
    pub fn lit(&self) -> bool {
        self.lit
    }
}
impl Default for WhiteCandleCakeState {
    fn default() -> Self {
        WhiteCandleCakeState {
            lit: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct OrangeCandleCakeState {
    lit: bool,
}
impl OrangeCandleCakeState {
    pub fn with_lit(&mut self, lit: bool) -> &mut Self {
        self.lit = lit;
        self
    }
    pub fn lit(&self) -> bool {
        self.lit
    }
}
impl Default for OrangeCandleCakeState {
    fn default() -> Self {
        OrangeCandleCakeState {
            lit: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct MagentaCandleCakeState {
    lit: bool,
}
impl MagentaCandleCakeState {
    pub fn with_lit(&mut self, lit: bool) -> &mut Self {
        self.lit = lit;
        self
    }
    pub fn lit(&self) -> bool {
        self.lit
    }
}
impl Default for MagentaCandleCakeState {
    fn default() -> Self {
        MagentaCandleCakeState {
            lit: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct LightBlueCandleCakeState {
    lit: bool,
}
impl LightBlueCandleCakeState {
    pub fn with_lit(&mut self, lit: bool) -> &mut Self {
        self.lit = lit;
        self
    }
    pub fn lit(&self) -> bool {
        self.lit
    }
}
impl Default for LightBlueCandleCakeState {
    fn default() -> Self {
        LightBlueCandleCakeState {
            lit: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct YellowCandleCakeState {
    lit: bool,
}
impl YellowCandleCakeState {
    pub fn with_lit(&mut self, lit: bool) -> &mut Self {
        self.lit = lit;
        self
    }
    pub fn lit(&self) -> bool {
        self.lit
    }
}
impl Default for YellowCandleCakeState {
    fn default() -> Self {
        YellowCandleCakeState {
            lit: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct LimeCandleCakeState {
    lit: bool,
}
impl LimeCandleCakeState {
    pub fn with_lit(&mut self, lit: bool) -> &mut Self {
        self.lit = lit;
        self
    }
    pub fn lit(&self) -> bool {
        self.lit
    }
}
impl Default for LimeCandleCakeState {
    fn default() -> Self {
        LimeCandleCakeState {
            lit: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct PinkCandleCakeState {
    lit: bool,
}
impl PinkCandleCakeState {
    pub fn with_lit(&mut self, lit: bool) -> &mut Self {
        self.lit = lit;
        self
    }
    pub fn lit(&self) -> bool {
        self.lit
    }
}
impl Default for PinkCandleCakeState {
    fn default() -> Self {
        PinkCandleCakeState {
            lit: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct GrayCandleCakeState {
    lit: bool,
}
impl GrayCandleCakeState {
    pub fn with_lit(&mut self, lit: bool) -> &mut Self {
        self.lit = lit;
        self
    }
    pub fn lit(&self) -> bool {
        self.lit
    }
}
impl Default for GrayCandleCakeState {
    fn default() -> Self {
        GrayCandleCakeState {
            lit: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct LightGrayCandleCakeState {
    lit: bool,
}
impl LightGrayCandleCakeState {
    pub fn with_lit(&mut self, lit: bool) -> &mut Self {
        self.lit = lit;
        self
    }
    pub fn lit(&self) -> bool {
        self.lit
    }
}
impl Default for LightGrayCandleCakeState {
    fn default() -> Self {
        LightGrayCandleCakeState {
            lit: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct CyanCandleCakeState {
    lit: bool,
}
impl CyanCandleCakeState {
    pub fn with_lit(&mut self, lit: bool) -> &mut Self {
        self.lit = lit;
        self
    }
    pub fn lit(&self) -> bool {
        self.lit
    }
}
impl Default for CyanCandleCakeState {
    fn default() -> Self {
        CyanCandleCakeState {
            lit: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct PurpleCandleCakeState {
    lit: bool,
}
impl PurpleCandleCakeState {
    pub fn with_lit(&mut self, lit: bool) -> &mut Self {
        self.lit = lit;
        self
    }
    pub fn lit(&self) -> bool {
        self.lit
    }
}
impl Default for PurpleCandleCakeState {
    fn default() -> Self {
        PurpleCandleCakeState {
            lit: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct BlueCandleCakeState {
    lit: bool,
}
impl BlueCandleCakeState {
    pub fn with_lit(&mut self, lit: bool) -> &mut Self {
        self.lit = lit;
        self
    }
    pub fn lit(&self) -> bool {
        self.lit
    }
}
impl Default for BlueCandleCakeState {
    fn default() -> Self {
        BlueCandleCakeState {
            lit: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct BrownCandleCakeState {
    lit: bool,
}
impl BrownCandleCakeState {
    pub fn with_lit(&mut self, lit: bool) -> &mut Self {
        self.lit = lit;
        self
    }
    pub fn lit(&self) -> bool {
        self.lit
    }
}
impl Default for BrownCandleCakeState {
    fn default() -> Self {
        BrownCandleCakeState {
            lit: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct GreenCandleCakeState {
    lit: bool,
}
impl GreenCandleCakeState {
    pub fn with_lit(&mut self, lit: bool) -> &mut Self {
        self.lit = lit;
        self
    }
    pub fn lit(&self) -> bool {
        self.lit
    }
}
impl Default for GreenCandleCakeState {
    fn default() -> Self {
        GreenCandleCakeState {
            lit: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct RedCandleCakeState {
    lit: bool,
}
impl RedCandleCakeState {
    pub fn with_lit(&mut self, lit: bool) -> &mut Self {
        self.lit = lit;
        self
    }
    pub fn lit(&self) -> bool {
        self.lit
    }
}
impl Default for RedCandleCakeState {
    fn default() -> Self {
        RedCandleCakeState {
            lit: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct BlackCandleCakeState {
    lit: bool,
}
impl BlackCandleCakeState {
    pub fn with_lit(&mut self, lit: bool) -> &mut Self {
        self.lit = lit;
        self
    }
    pub fn lit(&self) -> bool {
        self.lit
    }
}
impl Default for BlackCandleCakeState {
    fn default() -> Self {
        BlackCandleCakeState {
            lit: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct AmethystClusterState {
    facing: AllFacing,
    waterlogged: bool,
}
impl AmethystClusterState {
    pub fn with_facing(&mut self, facing: AllFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> AllFacing {
        self.facing
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for AmethystClusterState {
    fn default() -> Self {
        AmethystClusterState {
            facing: AllFacing::Up,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct LargeAmethystBudState {
    facing: AllFacing,
    waterlogged: bool,
}
impl LargeAmethystBudState {
    pub fn with_facing(&mut self, facing: AllFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> AllFacing {
        self.facing
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for LargeAmethystBudState {
    fn default() -> Self {
        LargeAmethystBudState {
            facing: AllFacing::Up,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct MediumAmethystBudState {
    facing: AllFacing,
    waterlogged: bool,
}
impl MediumAmethystBudState {
    pub fn with_facing(&mut self, facing: AllFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> AllFacing {
        self.facing
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for MediumAmethystBudState {
    fn default() -> Self {
        MediumAmethystBudState {
            facing: AllFacing::Up,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct SmallAmethystBudState {
    facing: AllFacing,
    waterlogged: bool,
}
impl SmallAmethystBudState {
    pub fn with_facing(&mut self, facing: AllFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> AllFacing {
        self.facing
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for SmallAmethystBudState {
    fn default() -> Self {
        SmallAmethystBudState {
            facing: AllFacing::Up,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct SculkSensorState {
    power: i32,
    sculk_sensor_phase: SculkSensorPhase,
    waterlogged: bool,
}
impl SculkSensorState {
    /// This is a value between 0 and 15 (both ends inclusive).\Developers should be careful to respect these bounds as no checking is done at runtime!!!
    pub fn with_power(&mut self, power: i32) -> &mut Self {
        self.power = power;
        self
    }
    pub fn power(&self) -> i32 {
        self.power
    }
    pub fn with_sculk_sensor_phase(&mut self, sculk_sensor_phase: SculkSensorPhase) -> &mut Self {
        self.sculk_sensor_phase = sculk_sensor_phase;
        self
    }
    pub fn sculk_sensor_phase(&self) -> SculkSensorPhase {
        self.sculk_sensor_phase
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for SculkSensorState {
    fn default() -> Self {
        SculkSensorState {
            power: 0,
            sculk_sensor_phase: SculkSensorPhase::Inactive,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct OxidizedCutCopperStairsState {
    facing: HorizontalFacing,
    half: SingleBlockHalf,
    shape: StairShape,
    waterlogged: bool,
}
impl OxidizedCutCopperStairsState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_half(&mut self, half: SingleBlockHalf) -> &mut Self {
        self.half = half;
        self
    }
    pub fn half(&self) -> SingleBlockHalf {
        self.half
    }
    pub fn with_shape(&mut self, shape: StairShape) -> &mut Self {
        self.shape = shape;
        self
    }
    pub fn shape(&self) -> StairShape {
        self.shape
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for OxidizedCutCopperStairsState {
    fn default() -> Self {
        OxidizedCutCopperStairsState {
            facing: HorizontalFacing::North,
            half: SingleBlockHalf::Bottom,
            shape: StairShape::Straight,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct WeatheredCutCopperStairsState {
    facing: HorizontalFacing,
    half: SingleBlockHalf,
    shape: StairShape,
    waterlogged: bool,
}
impl WeatheredCutCopperStairsState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_half(&mut self, half: SingleBlockHalf) -> &mut Self {
        self.half = half;
        self
    }
    pub fn half(&self) -> SingleBlockHalf {
        self.half
    }
    pub fn with_shape(&mut self, shape: StairShape) -> &mut Self {
        self.shape = shape;
        self
    }
    pub fn shape(&self) -> StairShape {
        self.shape
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for WeatheredCutCopperStairsState {
    fn default() -> Self {
        WeatheredCutCopperStairsState {
            facing: HorizontalFacing::North,
            half: SingleBlockHalf::Bottom,
            shape: StairShape::Straight,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct ExposedCutCopperStairsState {
    facing: HorizontalFacing,
    half: SingleBlockHalf,
    shape: StairShape,
    waterlogged: bool,
}
impl ExposedCutCopperStairsState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_half(&mut self, half: SingleBlockHalf) -> &mut Self {
        self.half = half;
        self
    }
    pub fn half(&self) -> SingleBlockHalf {
        self.half
    }
    pub fn with_shape(&mut self, shape: StairShape) -> &mut Self {
        self.shape = shape;
        self
    }
    pub fn shape(&self) -> StairShape {
        self.shape
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for ExposedCutCopperStairsState {
    fn default() -> Self {
        ExposedCutCopperStairsState {
            facing: HorizontalFacing::North,
            half: SingleBlockHalf::Bottom,
            shape: StairShape::Straight,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct CutCopperStairsState {
    facing: HorizontalFacing,
    half: SingleBlockHalf,
    shape: StairShape,
    waterlogged: bool,
}
impl CutCopperStairsState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_half(&mut self, half: SingleBlockHalf) -> &mut Self {
        self.half = half;
        self
    }
    pub fn half(&self) -> SingleBlockHalf {
        self.half
    }
    pub fn with_shape(&mut self, shape: StairShape) -> &mut Self {
        self.shape = shape;
        self
    }
    pub fn shape(&self) -> StairShape {
        self.shape
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for CutCopperStairsState {
    fn default() -> Self {
        CutCopperStairsState {
            facing: HorizontalFacing::North,
            half: SingleBlockHalf::Bottom,
            shape: StairShape::Straight,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct OxidizedCutCopperSlabState {
    typed: SlabType,
    waterlogged: bool,
}
impl OxidizedCutCopperSlabState {
    pub fn with_typed(&mut self, typed: SlabType) -> &mut Self {
        self.typed = typed;
        self
    }
    pub fn typed(&self) -> SlabType {
        self.typed
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for OxidizedCutCopperSlabState {
    fn default() -> Self {
        OxidizedCutCopperSlabState {
            typed: SlabType::Bottom,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct WeatheredCutCopperSlabState {
    typed: SlabType,
    waterlogged: bool,
}
impl WeatheredCutCopperSlabState {
    pub fn with_typed(&mut self, typed: SlabType) -> &mut Self {
        self.typed = typed;
        self
    }
    pub fn typed(&self) -> SlabType {
        self.typed
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for WeatheredCutCopperSlabState {
    fn default() -> Self {
        WeatheredCutCopperSlabState {
            typed: SlabType::Bottom,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct ExposedCutCopperSlabState {
    typed: SlabType,
    waterlogged: bool,
}
impl ExposedCutCopperSlabState {
    pub fn with_typed(&mut self, typed: SlabType) -> &mut Self {
        self.typed = typed;
        self
    }
    pub fn typed(&self) -> SlabType {
        self.typed
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for ExposedCutCopperSlabState {
    fn default() -> Self {
        ExposedCutCopperSlabState {
            typed: SlabType::Bottom,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct CutCopperSlabState {
    typed: SlabType,
    waterlogged: bool,
}
impl CutCopperSlabState {
    pub fn with_typed(&mut self, typed: SlabType) -> &mut Self {
        self.typed = typed;
        self
    }
    pub fn typed(&self) -> SlabType {
        self.typed
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for CutCopperSlabState {
    fn default() -> Self {
        CutCopperSlabState {
            typed: SlabType::Bottom,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct WaxedOxidizedCutCopperStairsState {
    facing: HorizontalFacing,
    half: SingleBlockHalf,
    shape: StairShape,
    waterlogged: bool,
}
impl WaxedOxidizedCutCopperStairsState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_half(&mut self, half: SingleBlockHalf) -> &mut Self {
        self.half = half;
        self
    }
    pub fn half(&self) -> SingleBlockHalf {
        self.half
    }
    pub fn with_shape(&mut self, shape: StairShape) -> &mut Self {
        self.shape = shape;
        self
    }
    pub fn shape(&self) -> StairShape {
        self.shape
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for WaxedOxidizedCutCopperStairsState {
    fn default() -> Self {
        WaxedOxidizedCutCopperStairsState {
            facing: HorizontalFacing::North,
            half: SingleBlockHalf::Bottom,
            shape: StairShape::Straight,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct WaxedWeatheredCutCopperStairsState {
    facing: HorizontalFacing,
    half: SingleBlockHalf,
    shape: StairShape,
    waterlogged: bool,
}
impl WaxedWeatheredCutCopperStairsState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_half(&mut self, half: SingleBlockHalf) -> &mut Self {
        self.half = half;
        self
    }
    pub fn half(&self) -> SingleBlockHalf {
        self.half
    }
    pub fn with_shape(&mut self, shape: StairShape) -> &mut Self {
        self.shape = shape;
        self
    }
    pub fn shape(&self) -> StairShape {
        self.shape
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for WaxedWeatheredCutCopperStairsState {
    fn default() -> Self {
        WaxedWeatheredCutCopperStairsState {
            facing: HorizontalFacing::North,
            half: SingleBlockHalf::Bottom,
            shape: StairShape::Straight,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct WaxedExposedCutCopperStairsState {
    facing: HorizontalFacing,
    half: SingleBlockHalf,
    shape: StairShape,
    waterlogged: bool,
}
impl WaxedExposedCutCopperStairsState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_half(&mut self, half: SingleBlockHalf) -> &mut Self {
        self.half = half;
        self
    }
    pub fn half(&self) -> SingleBlockHalf {
        self.half
    }
    pub fn with_shape(&mut self, shape: StairShape) -> &mut Self {
        self.shape = shape;
        self
    }
    pub fn shape(&self) -> StairShape {
        self.shape
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for WaxedExposedCutCopperStairsState {
    fn default() -> Self {
        WaxedExposedCutCopperStairsState {
            facing: HorizontalFacing::North,
            half: SingleBlockHalf::Bottom,
            shape: StairShape::Straight,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct WaxedCutCopperStairsState {
    facing: HorizontalFacing,
    half: SingleBlockHalf,
    shape: StairShape,
    waterlogged: bool,
}
impl WaxedCutCopperStairsState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_half(&mut self, half: SingleBlockHalf) -> &mut Self {
        self.half = half;
        self
    }
    pub fn half(&self) -> SingleBlockHalf {
        self.half
    }
    pub fn with_shape(&mut self, shape: StairShape) -> &mut Self {
        self.shape = shape;
        self
    }
    pub fn shape(&self) -> StairShape {
        self.shape
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for WaxedCutCopperStairsState {
    fn default() -> Self {
        WaxedCutCopperStairsState {
            facing: HorizontalFacing::North,
            half: SingleBlockHalf::Bottom,
            shape: StairShape::Straight,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct WaxedOxidizedCutCopperSlabState {
    typed: SlabType,
    waterlogged: bool,
}
impl WaxedOxidizedCutCopperSlabState {
    pub fn with_typed(&mut self, typed: SlabType) -> &mut Self {
        self.typed = typed;
        self
    }
    pub fn typed(&self) -> SlabType {
        self.typed
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for WaxedOxidizedCutCopperSlabState {
    fn default() -> Self {
        WaxedOxidizedCutCopperSlabState {
            typed: SlabType::Bottom,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct WaxedWeatheredCutCopperSlabState {
    typed: SlabType,
    waterlogged: bool,
}
impl WaxedWeatheredCutCopperSlabState {
    pub fn with_typed(&mut self, typed: SlabType) -> &mut Self {
        self.typed = typed;
        self
    }
    pub fn typed(&self) -> SlabType {
        self.typed
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for WaxedWeatheredCutCopperSlabState {
    fn default() -> Self {
        WaxedWeatheredCutCopperSlabState {
            typed: SlabType::Bottom,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct WaxedExposedCutCopperSlabState {
    typed: SlabType,
    waterlogged: bool,
}
impl WaxedExposedCutCopperSlabState {
    pub fn with_typed(&mut self, typed: SlabType) -> &mut Self {
        self.typed = typed;
        self
    }
    pub fn typed(&self) -> SlabType {
        self.typed
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for WaxedExposedCutCopperSlabState {
    fn default() -> Self {
        WaxedExposedCutCopperSlabState {
            typed: SlabType::Bottom,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct WaxedCutCopperSlabState {
    typed: SlabType,
    waterlogged: bool,
}
impl WaxedCutCopperSlabState {
    pub fn with_typed(&mut self, typed: SlabType) -> &mut Self {
        self.typed = typed;
        self
    }
    pub fn typed(&self) -> SlabType {
        self.typed
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for WaxedCutCopperSlabState {
    fn default() -> Self {
        WaxedCutCopperSlabState {
            typed: SlabType::Bottom,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct LightningRodState {
    facing: AllFacing,
    powered: bool,
    waterlogged: bool,
}
impl LightningRodState {
    pub fn with_facing(&mut self, facing: AllFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> AllFacing {
        self.facing
    }
    pub fn with_powered(&mut self, powered: bool) -> &mut Self {
        self.powered = powered;
        self
    }
    pub fn powered(&self) -> bool {
        self.powered
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for LightningRodState {
    fn default() -> Self {
        LightningRodState {
            facing: AllFacing::Up,
            powered: false,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct PointedDripstoneState {
    thickness: Thickness,
    vertical_direction: VerticalDirection,
    waterlogged: bool,
}
impl PointedDripstoneState {
    pub fn with_thickness(&mut self, thickness: Thickness) -> &mut Self {
        self.thickness = thickness;
        self
    }
    pub fn thickness(&self) -> Thickness {
        self.thickness
    }
    pub fn with_vertical_direction(&mut self, vertical_direction: VerticalDirection) -> &mut Self {
        self.vertical_direction = vertical_direction;
        self
    }
    pub fn vertical_direction(&self) -> VerticalDirection {
        self.vertical_direction
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for PointedDripstoneState {
    fn default() -> Self {
        PointedDripstoneState {
            thickness: Thickness::Tip,
            vertical_direction: VerticalDirection::Up,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct CaveVinesState {
    age: i32,
    berries: bool,
}
impl CaveVinesState {
    /// This is a value between 0 and 25 (both ends inclusive).\Developers should be careful to respect these bounds as no checking is done at runtime!!!
    pub fn with_age(&mut self, age: i32) -> &mut Self {
        self.age = age;
        self
    }
    pub fn age(&self) -> i32 {
        self.age
    }
    pub fn with_berries(&mut self, berries: bool) -> &mut Self {
        self.berries = berries;
        self
    }
    pub fn berries(&self) -> bool {
        self.berries
    }
}
impl Default for CaveVinesState {
    fn default() -> Self {
        CaveVinesState {
            age: 0,
            berries: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct CaveVinesPlantState {
    berries: bool,
}
impl CaveVinesPlantState {
    pub fn with_berries(&mut self, berries: bool) -> &mut Self {
        self.berries = berries;
        self
    }
    pub fn berries(&self) -> bool {
        self.berries
    }
}
impl Default for CaveVinesPlantState {
    fn default() -> Self {
        CaveVinesPlantState {
            berries: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct BigDripleafState {
    facing: HorizontalFacing,
    tilt: Tilt,
    waterlogged: bool,
}
impl BigDripleafState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_tilt(&mut self, tilt: Tilt) -> &mut Self {
        self.tilt = tilt;
        self
    }
    pub fn tilt(&self) -> Tilt {
        self.tilt
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for BigDripleafState {
    fn default() -> Self {
        BigDripleafState {
            facing: HorizontalFacing::North,
            tilt: Tilt::None,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct BigDripleafStemState {
    facing: HorizontalFacing,
    waterlogged: bool,
}
impl BigDripleafStemState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for BigDripleafStemState {
    fn default() -> Self {
        BigDripleafStemState {
            facing: HorizontalFacing::North,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct SmallDripleafState {
    facing: HorizontalFacing,
    half: DoubleBlockHalf,
    waterlogged: bool,
}
impl SmallDripleafState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_half(&mut self, half: DoubleBlockHalf) -> &mut Self {
        self.half = half;
        self
    }
    pub fn half(&self) -> DoubleBlockHalf {
        self.half
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for SmallDripleafState {
    fn default() -> Self {
        SmallDripleafState {
            facing: HorizontalFacing::North,
            half: DoubleBlockHalf::Lower,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct HangingRootsState {
    waterlogged: bool,
}
impl HangingRootsState {
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for HangingRootsState {
    fn default() -> Self {
        HangingRootsState {
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct DeepslateState {
    axis: Axis,
}
impl DeepslateState {
    pub fn with_axis(&mut self, axis: Axis) -> &mut Self {
        self.axis = axis;
        self
    }
    pub fn axis(&self) -> Axis {
        self.axis
    }
}
impl Default for DeepslateState {
    fn default() -> Self {
        DeepslateState {
            axis: Axis::Y,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct CobbledDeepslateStairsState {
    facing: HorizontalFacing,
    half: SingleBlockHalf,
    shape: StairShape,
    waterlogged: bool,
}
impl CobbledDeepslateStairsState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_half(&mut self, half: SingleBlockHalf) -> &mut Self {
        self.half = half;
        self
    }
    pub fn half(&self) -> SingleBlockHalf {
        self.half
    }
    pub fn with_shape(&mut self, shape: StairShape) -> &mut Self {
        self.shape = shape;
        self
    }
    pub fn shape(&self) -> StairShape {
        self.shape
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for CobbledDeepslateStairsState {
    fn default() -> Self {
        CobbledDeepslateStairsState {
            facing: HorizontalFacing::North,
            half: SingleBlockHalf::Bottom,
            shape: StairShape::Straight,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct CobbledDeepslateSlabState {
    typed: SlabType,
    waterlogged: bool,
}
impl CobbledDeepslateSlabState {
    pub fn with_typed(&mut self, typed: SlabType) -> &mut Self {
        self.typed = typed;
        self
    }
    pub fn typed(&self) -> SlabType {
        self.typed
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for CobbledDeepslateSlabState {
    fn default() -> Self {
        CobbledDeepslateSlabState {
            typed: SlabType::Bottom,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct CobbledDeepslateWallState {
    east: WallType,
    north: WallType,
    south: WallType,
    up: bool,
    waterlogged: bool,
    west: WallType,
}
impl CobbledDeepslateWallState {
    pub fn with_east(&mut self, east: WallType) -> &mut Self {
        self.east = east;
        self
    }
    pub fn east(&self) -> WallType {
        self.east
    }
    pub fn with_north(&mut self, north: WallType) -> &mut Self {
        self.north = north;
        self
    }
    pub fn north(&self) -> WallType {
        self.north
    }
    pub fn with_south(&mut self, south: WallType) -> &mut Self {
        self.south = south;
        self
    }
    pub fn south(&self) -> WallType {
        self.south
    }
    pub fn with_up(&mut self, up: bool) -> &mut Self {
        self.up = up;
        self
    }
    pub fn up(&self) -> bool {
        self.up
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
    pub fn with_west(&mut self, west: WallType) -> &mut Self {
        self.west = west;
        self
    }
    pub fn west(&self) -> WallType {
        self.west
    }
}
impl Default for CobbledDeepslateWallState {
    fn default() -> Self {
        CobbledDeepslateWallState {
            east: WallType::None,
            north: WallType::None,
            south: WallType::None,
            up: true,
            waterlogged: false,
            west: WallType::None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct PolishedDeepslateStairsState {
    facing: HorizontalFacing,
    half: SingleBlockHalf,
    shape: StairShape,
    waterlogged: bool,
}
impl PolishedDeepslateStairsState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_half(&mut self, half: SingleBlockHalf) -> &mut Self {
        self.half = half;
        self
    }
    pub fn half(&self) -> SingleBlockHalf {
        self.half
    }
    pub fn with_shape(&mut self, shape: StairShape) -> &mut Self {
        self.shape = shape;
        self
    }
    pub fn shape(&self) -> StairShape {
        self.shape
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for PolishedDeepslateStairsState {
    fn default() -> Self {
        PolishedDeepslateStairsState {
            facing: HorizontalFacing::North,
            half: SingleBlockHalf::Bottom,
            shape: StairShape::Straight,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct PolishedDeepslateSlabState {
    typed: SlabType,
    waterlogged: bool,
}
impl PolishedDeepslateSlabState {
    pub fn with_typed(&mut self, typed: SlabType) -> &mut Self {
        self.typed = typed;
        self
    }
    pub fn typed(&self) -> SlabType {
        self.typed
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for PolishedDeepslateSlabState {
    fn default() -> Self {
        PolishedDeepslateSlabState {
            typed: SlabType::Bottom,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct PolishedDeepslateWallState {
    east: WallType,
    north: WallType,
    south: WallType,
    up: bool,
    waterlogged: bool,
    west: WallType,
}
impl PolishedDeepslateWallState {
    pub fn with_east(&mut self, east: WallType) -> &mut Self {
        self.east = east;
        self
    }
    pub fn east(&self) -> WallType {
        self.east
    }
    pub fn with_north(&mut self, north: WallType) -> &mut Self {
        self.north = north;
        self
    }
    pub fn north(&self) -> WallType {
        self.north
    }
    pub fn with_south(&mut self, south: WallType) -> &mut Self {
        self.south = south;
        self
    }
    pub fn south(&self) -> WallType {
        self.south
    }
    pub fn with_up(&mut self, up: bool) -> &mut Self {
        self.up = up;
        self
    }
    pub fn up(&self) -> bool {
        self.up
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
    pub fn with_west(&mut self, west: WallType) -> &mut Self {
        self.west = west;
        self
    }
    pub fn west(&self) -> WallType {
        self.west
    }
}
impl Default for PolishedDeepslateWallState {
    fn default() -> Self {
        PolishedDeepslateWallState {
            east: WallType::None,
            north: WallType::None,
            south: WallType::None,
            up: true,
            waterlogged: false,
            west: WallType::None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct DeepslateTileStairsState {
    facing: HorizontalFacing,
    half: SingleBlockHalf,
    shape: StairShape,
    waterlogged: bool,
}
impl DeepslateTileStairsState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_half(&mut self, half: SingleBlockHalf) -> &mut Self {
        self.half = half;
        self
    }
    pub fn half(&self) -> SingleBlockHalf {
        self.half
    }
    pub fn with_shape(&mut self, shape: StairShape) -> &mut Self {
        self.shape = shape;
        self
    }
    pub fn shape(&self) -> StairShape {
        self.shape
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for DeepslateTileStairsState {
    fn default() -> Self {
        DeepslateTileStairsState {
            facing: HorizontalFacing::North,
            half: SingleBlockHalf::Bottom,
            shape: StairShape::Straight,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct DeepslateTileSlabState {
    typed: SlabType,
    waterlogged: bool,
}
impl DeepslateTileSlabState {
    pub fn with_typed(&mut self, typed: SlabType) -> &mut Self {
        self.typed = typed;
        self
    }
    pub fn typed(&self) -> SlabType {
        self.typed
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for DeepslateTileSlabState {
    fn default() -> Self {
        DeepslateTileSlabState {
            typed: SlabType::Bottom,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct DeepslateTileWallState {
    east: WallType,
    north: WallType,
    south: WallType,
    up: bool,
    waterlogged: bool,
    west: WallType,
}
impl DeepslateTileWallState {
    pub fn with_east(&mut self, east: WallType) -> &mut Self {
        self.east = east;
        self
    }
    pub fn east(&self) -> WallType {
        self.east
    }
    pub fn with_north(&mut self, north: WallType) -> &mut Self {
        self.north = north;
        self
    }
    pub fn north(&self) -> WallType {
        self.north
    }
    pub fn with_south(&mut self, south: WallType) -> &mut Self {
        self.south = south;
        self
    }
    pub fn south(&self) -> WallType {
        self.south
    }
    pub fn with_up(&mut self, up: bool) -> &mut Self {
        self.up = up;
        self
    }
    pub fn up(&self) -> bool {
        self.up
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
    pub fn with_west(&mut self, west: WallType) -> &mut Self {
        self.west = west;
        self
    }
    pub fn west(&self) -> WallType {
        self.west
    }
}
impl Default for DeepslateTileWallState {
    fn default() -> Self {
        DeepslateTileWallState {
            east: WallType::None,
            north: WallType::None,
            south: WallType::None,
            up: true,
            waterlogged: false,
            west: WallType::None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct DeepslateBrickStairsState {
    facing: HorizontalFacing,
    half: SingleBlockHalf,
    shape: StairShape,
    waterlogged: bool,
}
impl DeepslateBrickStairsState {
    pub fn with_facing(&mut self, facing: HorizontalFacing) -> &mut Self {
        self.facing = facing;
        self
    }
    pub fn facing(&self) -> HorizontalFacing {
        self.facing
    }
    pub fn with_half(&mut self, half: SingleBlockHalf) -> &mut Self {
        self.half = half;
        self
    }
    pub fn half(&self) -> SingleBlockHalf {
        self.half
    }
    pub fn with_shape(&mut self, shape: StairShape) -> &mut Self {
        self.shape = shape;
        self
    }
    pub fn shape(&self) -> StairShape {
        self.shape
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for DeepslateBrickStairsState {
    fn default() -> Self {
        DeepslateBrickStairsState {
            facing: HorizontalFacing::North,
            half: SingleBlockHalf::Bottom,
            shape: StairShape::Straight,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct DeepslateBrickSlabState {
    typed: SlabType,
    waterlogged: bool,
}
impl DeepslateBrickSlabState {
    pub fn with_typed(&mut self, typed: SlabType) -> &mut Self {
        self.typed = typed;
        self
    }
    pub fn typed(&self) -> SlabType {
        self.typed
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
}
impl Default for DeepslateBrickSlabState {
    fn default() -> Self {
        DeepslateBrickSlabState {
            typed: SlabType::Bottom,
            waterlogged: false,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct DeepslateBrickWallState {
    east: WallType,
    north: WallType,
    south: WallType,
    up: bool,
    waterlogged: bool,
    west: WallType,
}
impl DeepslateBrickWallState {
    pub fn with_east(&mut self, east: WallType) -> &mut Self {
        self.east = east;
        self
    }
    pub fn east(&self) -> WallType {
        self.east
    }
    pub fn with_north(&mut self, north: WallType) -> &mut Self {
        self.north = north;
        self
    }
    pub fn north(&self) -> WallType {
        self.north
    }
    pub fn with_south(&mut self, south: WallType) -> &mut Self {
        self.south = south;
        self
    }
    pub fn south(&self) -> WallType {
        self.south
    }
    pub fn with_up(&mut self, up: bool) -> &mut Self {
        self.up = up;
        self
    }
    pub fn up(&self) -> bool {
        self.up
    }
    pub fn with_waterlogged(&mut self, waterlogged: bool) -> &mut Self {
        self.waterlogged = waterlogged;
        self
    }
    pub fn waterlogged(&self) -> bool {
        self.waterlogged
    }
    pub fn with_west(&mut self, west: WallType) -> &mut Self {
        self.west = west;
        self
    }
    pub fn west(&self) -> WallType {
        self.west
    }
}
impl Default for DeepslateBrickWallState {
    fn default() -> Self {
        DeepslateBrickWallState {
            east: WallType::None,
            north: WallType::None,
            south: WallType::None,
            up: true,
            waterlogged: false,
            west: WallType::None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct InfestedDeepslateState {
    axis: Axis,
}
impl InfestedDeepslateState {
    pub fn with_axis(&mut self, axis: Axis) -> &mut Self {
        self.axis = axis;
        self
    }
    pub fn axis(&self) -> Axis {
        self.axis
    }
}
impl Default for InfestedDeepslateState {
    fn default() -> Self {
        InfestedDeepslateState {
            axis: Axis::Y,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum PortalAxis {
    X,
    Z,
}
impl FromStr for PortalAxis {
    type Err = ParseBlockError;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "x" => Ok(PortalAxis::X),
            "z" => Ok(PortalAxis::Z),
            _ => Err(ParseBlockError::InvalidProperty),
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum HorizontalFacing {
    North,
    South,
    West,
    East,
}
impl FromStr for HorizontalFacing {
    type Err = ParseBlockError;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "north" => Ok(HorizontalFacing::North),
            "south" => Ok(HorizontalFacing::South),
            "west" => Ok(HorizontalFacing::West),
            "east" => Ok(HorizontalFacing::East),
            _ => Err(ParseBlockError::InvalidProperty),
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum HopperFacing {
    Down,
    North,
    South,
    West,
    East,
}
impl FromStr for HopperFacing {
    type Err = ParseBlockError;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "down" => Ok(HopperFacing::Down),
            "north" => Ok(HopperFacing::North),
            "south" => Ok(HopperFacing::South),
            "west" => Ok(HopperFacing::West),
            "east" => Ok(HopperFacing::East),
            _ => Err(ParseBlockError::InvalidProperty),
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum AllFacing {
    North,
    East,
    South,
    West,
    Up,
    Down,
}
impl FromStr for AllFacing {
    type Err = ParseBlockError;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "north" => Ok(AllFacing::North),
            "east" => Ok(AllFacing::East),
            "south" => Ok(AllFacing::South),
            "west" => Ok(AllFacing::West),
            "up" => Ok(AllFacing::Up),
            "down" => Ok(AllFacing::Down),
            _ => Err(ParseBlockError::InvalidProperty),
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum DoubleBlockHalf {
    Upper,
    Lower,
}
impl FromStr for DoubleBlockHalf {
    type Err = ParseBlockError;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "upper" => Ok(DoubleBlockHalf::Upper),
            "lower" => Ok(DoubleBlockHalf::Lower),
            _ => Err(ParseBlockError::InvalidProperty),
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum SingleBlockHalf {
    Top,
    Bottom,
}
impl FromStr for SingleBlockHalf {
    type Err = ParseBlockError;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "top" => Ok(SingleBlockHalf::Top),
            "bottom" => Ok(SingleBlockHalf::Bottom),
            _ => Err(ParseBlockError::InvalidProperty),
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum ComparatorMode {
    Compare,
    Subtract,
}
impl FromStr for ComparatorMode {
    type Err = ParseBlockError;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "compare" => Ok(ComparatorMode::Compare),
            "subtract" => Ok(ComparatorMode::Subtract),
            _ => Err(ParseBlockError::InvalidProperty),
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum StructureBlockMode {
    Save,
    Load,
    Corner,
    Data,
}
impl FromStr for StructureBlockMode {
    type Err = ParseBlockError;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "save" => Ok(StructureBlockMode::Save),
            "load" => Ok(StructureBlockMode::Load),
            "corner" => Ok(StructureBlockMode::Corner),
            "data" => Ok(StructureBlockMode::Data),
            _ => Err(ParseBlockError::InvalidProperty),
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum StraightRailShape {
    NorthSouth,
    EastWest,
    AscendingEast,
    AscendingWest,
    AscendingNorth,
    AscendingSouth,
}
impl FromStr for StraightRailShape {
    type Err = ParseBlockError;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "north_south" => Ok(StraightRailShape::NorthSouth),
            "east_west" => Ok(StraightRailShape::EastWest),
            "ascending_east" => Ok(StraightRailShape::AscendingEast),
            "ascending_west" => Ok(StraightRailShape::AscendingWest),
            "ascending_north" => Ok(StraightRailShape::AscendingNorth),
            "ascending_south" => Ok(StraightRailShape::AscendingSouth),
            _ => Err(ParseBlockError::InvalidProperty),
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum RailShape {
    NorthSouth,
    EastWest,
    AscendingEast,
    AscendingWest,
    AscendingNorth,
    AscendingSouth,
    SouthEast,
    SouthWest,
    NorthWest,
    NorthEast,
}
impl FromStr for RailShape {
    type Err = ParseBlockError;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "north_south" => Ok(RailShape::NorthSouth),
            "east_west" => Ok(RailShape::EastWest),
            "ascending_east" => Ok(RailShape::AscendingEast),
            "ascending_west" => Ok(RailShape::AscendingWest),
            "ascending_north" => Ok(RailShape::AscendingNorth),
            "ascending_south" => Ok(RailShape::AscendingSouth),
            "south_east" => Ok(RailShape::SouthEast),
            "south_west" => Ok(RailShape::SouthWest),
            "north_west" => Ok(RailShape::NorthWest),
            "north_east" => Ok(RailShape::NorthEast),
            _ => Err(ParseBlockError::InvalidProperty),
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum StairShape {
    Straight,
    InnerLeft,
    InnerRight,
    OuterLeft,
    OuterRight,
}
impl FromStr for StairShape {
    type Err = ParseBlockError;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "straight" => Ok(StairShape::Straight),
            "inner_left" => Ok(StairShape::InnerLeft),
            "inner_right" => Ok(StairShape::InnerRight),
            "outer_left" => Ok(StairShape::OuterLeft),
            "outer_right" => Ok(StairShape::OuterRight),
            _ => Err(ParseBlockError::InvalidProperty),
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum ChestType {
    Single,
    Left,
    Right,
}
impl FromStr for ChestType {
    type Err = ParseBlockError;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "single" => Ok(ChestType::Single),
            "left" => Ok(ChestType::Left),
            "right" => Ok(ChestType::Right),
            _ => Err(ParseBlockError::InvalidProperty),
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum PistonType {
    Normal,
    Sticky,
}
impl FromStr for PistonType {
    type Err = ParseBlockError;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "normal" => Ok(PistonType::Normal),
            "sticky" => Ok(PistonType::Sticky),
            _ => Err(ParseBlockError::InvalidProperty),
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum RedstoneType {
    Up,
    Side,
    None,
}
impl FromStr for RedstoneType {
    type Err = ParseBlockError;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "up" => Ok(RedstoneType::Up),
            "side" => Ok(RedstoneType::Side),
            "none" => Ok(RedstoneType::None),
            _ => Err(ParseBlockError::InvalidProperty),
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum SlabType {
    Top,
    Bottom,
    Double,
}
impl FromStr for SlabType {
    type Err = ParseBlockError;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "top" => Ok(SlabType::Top),
            "bottom" => Ok(SlabType::Bottom),
            "double" => Ok(SlabType::Double),
            _ => Err(ParseBlockError::InvalidProperty),
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum WallType {
    None,
    Low,
    Tall,
}
impl FromStr for WallType {
    type Err = ParseBlockError;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "none" => Ok(WallType::None),
            "low" => Ok(WallType::Low),
            "tall" => Ok(WallType::Tall),
            _ => Err(ParseBlockError::InvalidProperty),
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum Axis {
    X,
    Y,
    Z,
}
impl FromStr for Axis {
    type Err = ParseBlockError;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "x" => Ok(Axis::X),
            "y" => Ok(Axis::Y),
            "z" => Ok(Axis::Z),
            _ => Err(ParseBlockError::InvalidProperty),
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum Instrument {
    Harp,
    Basedrum,
    Snare,
    Hat,
    Bass,
    Flute,
    Bell,
    Guitar,
    Chime,
    Xylophone,
    IronXylophone,
    CowBell,
    Didgeridoo,
    Bit,
    Banjo,
    Pling,
}
impl FromStr for Instrument {
    type Err = ParseBlockError;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "harp" => Ok(Instrument::Harp),
            "basedrum" => Ok(Instrument::Basedrum),
            "snare" => Ok(Instrument::Snare),
            "hat" => Ok(Instrument::Hat),
            "bass" => Ok(Instrument::Bass),
            "flute" => Ok(Instrument::Flute),
            "bell" => Ok(Instrument::Bell),
            "guitar" => Ok(Instrument::Guitar),
            "chime" => Ok(Instrument::Chime),
            "xylophone" => Ok(Instrument::Xylophone),
            "iron_xylophone" => Ok(Instrument::IronXylophone),
            "cow_bell" => Ok(Instrument::CowBell),
            "didgeridoo" => Ok(Instrument::Didgeridoo),
            "bit" => Ok(Instrument::Bit),
            "banjo" => Ok(Instrument::Banjo),
            "pling" => Ok(Instrument::Pling),
            _ => Err(ParseBlockError::InvalidProperty),
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum Part {
    Head,
    Foot,
}
impl FromStr for Part {
    type Err = ParseBlockError;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "head" => Ok(Part::Head),
            "foot" => Ok(Part::Foot),
            _ => Err(ParseBlockError::InvalidProperty),
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum Hinge {
    Left,
    Right,
}
impl FromStr for Hinge {
    type Err = ParseBlockError;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "left" => Ok(Hinge::Left),
            "right" => Ok(Hinge::Right),
            _ => Err(ParseBlockError::InvalidProperty),
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum Face {
    Floor,
    Wall,
    Ceiling,
}
impl FromStr for Face {
    type Err = ParseBlockError;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "floor" => Ok(Face::Floor),
            "wall" => Ok(Face::Wall),
            "ceiling" => Ok(Face::Ceiling),
            _ => Err(ParseBlockError::InvalidProperty),
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum Leaves {
    None,
    Small,
    Large,
}
impl FromStr for Leaves {
    type Err = ParseBlockError;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "none" => Ok(Leaves::None),
            "small" => Ok(Leaves::Small),
            "large" => Ok(Leaves::Large),
            _ => Err(ParseBlockError::InvalidProperty),
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum Attachment {
    Floor,
    Ceiling,
    SingleWall,
    DoubleWall,
}
impl FromStr for Attachment {
    type Err = ParseBlockError;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "floor" => Ok(Attachment::Floor),
            "ceiling" => Ok(Attachment::Ceiling),
            "single_wall" => Ok(Attachment::SingleWall),
            "double_wall" => Ok(Attachment::DoubleWall),
            _ => Err(ParseBlockError::InvalidProperty),
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum Orientation {
    DownEast,
    DownNorth,
    DownSouth,
    DownWest,
    UpEast,
    UpNorth,
    UpSouth,
    UpWest,
    WestUp,
    EastUp,
    NorthUp,
    SouthUp,
}
impl FromStr for Orientation {
    type Err = ParseBlockError;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "down_east" => Ok(Orientation::DownEast),
            "down_north" => Ok(Orientation::DownNorth),
            "down_south" => Ok(Orientation::DownSouth),
            "down_west" => Ok(Orientation::DownWest),
            "up_east" => Ok(Orientation::UpEast),
            "up_north" => Ok(Orientation::UpNorth),
            "up_south" => Ok(Orientation::UpSouth),
            "up_west" => Ok(Orientation::UpWest),
            "west_up" => Ok(Orientation::WestUp),
            "east_up" => Ok(Orientation::EastUp),
            "north_up" => Ok(Orientation::NorthUp),
            "south_up" => Ok(Orientation::SouthUp),
            _ => Err(ParseBlockError::InvalidProperty),
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum SculkSensorPhase {
    Inactive,
    Active,
    Cooldown,
}
impl FromStr for SculkSensorPhase {
    type Err = ParseBlockError;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "inactive" => Ok(SculkSensorPhase::Inactive),
            "active" => Ok(SculkSensorPhase::Active),
            "cooldown" => Ok(SculkSensorPhase::Cooldown),
            _ => Err(ParseBlockError::InvalidProperty),
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum Thickness {
    TipMerge,
    Tip,
    Frustum,
    Middle,
    Base,
}
impl FromStr for Thickness {
    type Err = ParseBlockError;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "tip_merge" => Ok(Thickness::TipMerge),
            "tip" => Ok(Thickness::Tip),
            "frustum" => Ok(Thickness::Frustum),
            "middle" => Ok(Thickness::Middle),
            "base" => Ok(Thickness::Base),
            _ => Err(ParseBlockError::InvalidProperty),
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum VerticalDirection {
    Up,
    Down,
}
impl FromStr for VerticalDirection {
    type Err = ParseBlockError;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "up" => Ok(VerticalDirection::Up),
            "down" => Ok(VerticalDirection::Down),
            _ => Err(ParseBlockError::InvalidProperty),
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum Tilt {
    None,
    Unstable,
    Partial,
    Full,
}
impl FromStr for Tilt {
    type Err = ParseBlockError;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "none" => Ok(Tilt::None),
            "unstable" => Ok(Tilt::Unstable),
            "partial" => Ok(Tilt::Partial),
            "full" => Ok(Tilt::Full),
            _ => Err(ParseBlockError::InvalidProperty),
        }
    }
}
